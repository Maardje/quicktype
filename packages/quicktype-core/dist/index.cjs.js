'use strict';

var collectionUtils = require('collection-utils');
var pluralize = require('pluralize');
var $bdjGp$base64js = require('base64-js');
var $bdjGp$unicodetrie = require('unicode-trie');
var pako = require('pako');
var URI$1 = require('urijs');
var _wordwrap = require('wordwrap');
var tsNecessities = require('@glideapps/ts-necessities');
var _ = require('lodash');
var readableStream = require('readable-stream');
var fs = require('fs');
var _fetch = require('cross-fetch');
var isURL = require('is-url');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var pluralize__namespace = /*#__PURE__*/_interopNamespaceDefault(pluralize);
var pako__namespace = /*#__PURE__*/_interopNamespaceDefault(pako);
var ___namespace = /*#__PURE__*/_interopNamespaceDefault(_);
var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, [])).next());
    });
}

/* eslint-disable */
// Mersenne Twister from https://gist.github.com/banksean/300494
/*
A C-program for MT19937, with initialization improved 2002/1/26.
Coded by Takuji Nishimura and Makoto Matsumoto.
Before using, initialize the state by using init_genrand(seed)
or init_by_array(init_key, key_length).
Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
3. The names of its contributors may not be used to endorse or promote
products derived from this software without specific prior written
permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Any feedback is very welcome.
http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/
class MersenneTwister {
    constructor(seed) {
        if (seed === undefined) {
            // kept random number same size as time used previously to ensure no unexpected results downstream
            seed = Math.floor(Math.random() * Math.pow(10, 13));
        }
        /* Period parameters */
        this.N = 624;
        this.M = 397;
        this.MATRIX_A = 0x9908b0df; /* constant vector a */
        this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
        this.LOWER_MASK = 0x7fffffff; /* least significant r bits */
        this.mt = new Array(this.N); /* the array for the state vector */
        this.mti = this.N + 1; /* mti==N + 1 means mt[N] is not initialized */
        this.init_genrand(seed);
    }
    /* initializes mt[N] with a seed */
    init_genrand(s) {
        this.mt[0] = s >>> 0;
        for (this.mti = 1; this.mti < this.N; this.mti++) {
            s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
            this.mt[this.mti] =
                ((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253 + this.mti;
            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
            /* In the previous versions, MSBs of the seed affect   */
            /* only MSBs of the array mt[].                        */
            /* 2002/01/09 modified by Makoto Matsumoto             */
            this.mt[this.mti] >>>= 0;
            /* for >32 bit machines */
        }
    }
    /* generates a random number on [0,0xffffffff]-interval */
    genrand_int32() {
        let y;
        let mag01 = [0x0, this.MATRIX_A];
        /* mag01[x] = x * MATRIX_A  for x=0,1 */
        if (this.mti >= this.N) {
            /* generate N words at one time */
            let kk;
            if (this.mti === this.N + 1) {
                /* if init_genrand() has not been called, */
                this.init_genrand(5489); /* a default initial seed is used */
            }
            for (kk = 0; kk < this.N - this.M; kk++) {
                y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
                this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            for (; kk < this.N - 1; kk++) {
                y = (this.mt[kk] & this.UPPER_MASK) | (this.mt[kk + 1] & this.LOWER_MASK);
                this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
            }
            y = (this.mt[this.N - 1] & this.UPPER_MASK) | (this.mt[0] & this.LOWER_MASK);
            this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];
            this.mti = 0;
        }
        y = this.mt[this.mti++];
        /* Tempering */
        y ^= y >>> 11;
        y ^= (y << 7) & 0x9d2c5680;
        y ^= (y << 15) & 0xefc60000;
        y ^= y >>> 18;
        return y >>> 0;
    }
    /* generates a random number on [0,1)-real-interval */
    random() {
        return this.genrand_int32() * (1.0 / 4294967296.0);
        /* divided by 2^32 */
    }
}
// https://github.com/chancejs/chancejs
class Chance {
    constructor(seed) {
        this.seed = seed;
        // If no generator function was provided, use our MT
        this.mt = new MersenneTwister(this.seed);
    }
    random() {
        return this.mt.random();
    }
    /**
     *  Return a random integer
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.integer({min: 1, max: 3});
     *  would return either 1, 2, or 3.
     *
     *  @param {Object} [options={}] can specify a min and/or max
     *  @returns {Number} a single random integer number
     *  @throws {RangeError} min cannot be greater than max
     */
    integer(options) {
        return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
    }
    /**
     *  Return a random natural
     *
     *  NOTE the max and min are INCLUDED in the range. So:
     *  chance.natural({min: 1, max: 3});
     *  would return either 1, 2, or 3.
     *
     *  @param {Object} [options={}] can specify a min and/or maxm or a numerals count.
     *  @returns {Number} a single random integer number
     *  @throws {RangeError} min cannot be greater than max
     */
    natural(options) {
        return this.integer({ min: 0, max: options.max });
    }
    pick(arr) {
        if (arr.length === 0) {
            throw new RangeError("Chance: Cannot pick() from an empty array");
        }
        return arr[this.natural({ max: arr.length - 1 })];
    }
    animal() {
        // if user does not put in any animal type, will return a random animal regardless
        const animalTypeArray = ["desert", "forest", "ocean", "zoo", "farm", "pet", "grassland"];
        return this.pick(animals[this.pick(animalTypeArray)]);
    }
    city() {
        return this.pick(cities);
    }
}
const animals = {
    // list of ocean animals comes from https://owlcation.com/stem/list-of-ocean-animals
    ocean: [
        "Acantharea",
        "Anemone",
        "Angelfish King",
        "Ahi Tuna",
        "Albacore",
        "American Oyster",
        "Anchovy",
        "Armored Snail",
        "Arctic Char",
        "Atlantic Bluefin Tuna",
        "Atlantic Cod",
        "Atlantic Goliath Grouper",
        "Atlantic Trumpetfish",
        "Atlantic Wolffish",
        "Baleen Whale",
        "Banded Butterflyfish",
        "Banded Coral Shrimp",
        "Banded Sea Krait",
        "Barnacle",
        "Barndoor Skate",
        "Barracuda",
        "Basking Shark",
        "Bass",
        "Beluga Whale",
        "Bluebanded Goby",
        "Bluehead Wrasse",
        "Bluefish",
        "Bluestreak Cleaner-Wrasse",
        "Blue Marlin",
        "Blue Shark",
        "Blue Spiny Lobster",
        "Blue Tang",
        "Blue Whale",
        "Broadclub Cuttlefish",
        "Bull Shark",
        "Chambered Nautilus",
        "Chilean Basket Star",
        "Chilean Jack Mackerel",
        "Chinook Salmon",
        "Christmas Tree Worm",
        "Clam",
        "Clown Anemonefish",
        "Clown Triggerfish",
        "Cod",
        "Coelacanth",
        "Cockscomb Cup Coral",
        "Common Fangtooth",
        "Conch",
        "Cookiecutter Shark",
        "Copepod",
        "Coral",
        "Corydoras",
        "Cownose Ray",
        "Crab",
        "Crown-of-Thorns Starfish",
        "Cushion Star",
        "Cuttlefish",
        "California Sea Otters",
        "Dolphin",
        "Dolphinfish",
        "Dory",
        "Devil Fish",
        "Dugong",
        "Dumbo Octopus",
        "Dungeness Crab",
        "Eccentric Sand Dollar",
        "Edible Sea Cucumber",
        "Eel",
        "Elephant Seal",
        "Elkhorn Coral",
        "Emperor Shrimp",
        "Estuarine Crocodile",
        "Fathead Sculpin",
        "Fiddler Crab",
        "Fin Whale",
        "Flameback",
        "Flamingo Tongue Snail",
        "Flashlight Fish",
        "Flatback Turtle",
        "Flatfish",
        "Flying Fish",
        "Flounder",
        "Fluke",
        "French Angelfish",
        "Frilled Shark",
        "Fugu (also called Pufferfish)",
        "Gar",
        "Geoduck",
        "Giant Barrel Sponge",
        "Giant Caribbean Sea Anemone",
        "Giant Clam",
        "Giant Isopod",
        "Giant Kingfish",
        "Giant Oarfish",
        "Giant Pacific Octopus",
        "Giant Pyrosome",
        "Giant Sea Star",
        "Giant Squid",
        "Glowing Sucker Octopus",
        "Giant Tube Worm",
        "Goblin Shark",
        "Goosefish",
        "Great White Shark",
        "Greenland Shark",
        "Grey Atlantic Seal",
        "Grouper",
        "Grunion",
        "Guineafowl Puffer",
        "Haddock",
        "Hake",
        "Halibut",
        "Hammerhead Shark",
        "Hapuka",
        "Harbor Porpoise",
        "Harbor Seal",
        "Hatchetfish",
        "Hawaiian Monk Seal",
        "Hawksbill Turtle",
        "Hector's Dolphin",
        "Hermit Crab",
        "Herring",
        "Hoki",
        "Horn Shark",
        "Horseshoe Crab",
        "Humpback Anglerfish",
        "Humpback Whale",
        "Icefish",
        "Imperator Angelfish",
        "Irukandji Jellyfish",
        "Isopod",
        "Ivory Bush Coral",
        "Japanese Spider Crab",
        "Jellyfish",
        "John Dory",
        "Juan Fernandez Fur Seal",
        "Killer Whale",
        "Kiwa Hirsuta",
        "Krill",
        "Lagoon Triggerfish",
        "Lamprey",
        "Leafy Seadragon",
        "Leopard Seal",
        "Limpet",
        "Ling",
        "Lionfish",
        "Lions Mane Jellyfish",
        "Lobe Coral",
        "Lobster",
        "Loggerhead Turtle",
        "Longnose Sawshark",
        "Longsnout Seahorse",
        "Lophelia Coral",
        "Marrus Orthocanna",
        "Manatee",
        "Manta Ray",
        "Marlin",
        "Megamouth Shark",
        "Mexican Lookdown",
        "Mimic Octopus",
        "Moon Jelly",
        "Mollusk",
        "Monkfish",
        "Moray Eel",
        "Mullet",
        "Mussel",
        "Megaladon",
        "Napoleon Wrasse",
        "Nassau Grouper",
        "Narwhal",
        "Nautilus",
        "Needlefish",
        "Northern Seahorse",
        "North Atlantic Right Whale",
        "Northern Red Snapper",
        "Norway Lobster",
        "Nudibranch",
        "Nurse Shark",
        "Oarfish",
        "Ocean Sunfish",
        "Oceanic Whitetip Shark",
        "Octopus",
        "Olive Sea Snake",
        "Orange Roughy",
        "Ostracod",
        "Otter",
        "Oyster",
        "Pacific Angelshark",
        "Pacific Blackdragon",
        "Pacific Halibut",
        "Pacific Sardine",
        "Pacific Sea Nettle Jellyfish",
        "Pacific White Sided Dolphin",
        "Pantropical Spotted Dolphin",
        "Patagonian Toothfish",
        "Peacock Mantis Shrimp",
        "Pelagic Thresher Shark",
        "Penguin",
        "Peruvian Anchoveta",
        "Pilchard",
        "Pink Salmon",
        "Pinniped",
        "Plankton",
        "Porpoise",
        "Polar Bear",
        "Portuguese Man o' War",
        "Pycnogonid Sea Spider",
        "Quahog",
        "Queen Angelfish",
        "Queen Conch",
        "Queen Parrotfish",
        "Queensland Grouper",
        "Ragfish",
        "Ratfish",
        "Rattail Fish",
        "Ray",
        "Red Drum",
        "Red King Crab",
        "Ringed Seal",
        "Risso's Dolphin",
        "Ross Seals",
        "Sablefish",
        "Salmon",
        "Sand Dollar",
        "Sandbar Shark",
        "Sawfish",
        "Sarcastic Fringehead",
        "Scalloped Hammerhead Shark",
        "Seahorse",
        "Sea Cucumber",
        "Sea Lion",
        "Sea Urchin",
        "Seal",
        "Shark",
        "Shortfin Mako Shark",
        "Shovelnose Guitarfish",
        "Shrimp",
        "Silverside Fish",
        "Skipjack Tuna",
        "Slender Snipe Eel",
        "Smalltooth Sawfish",
        "Smelts",
        "Sockeye Salmon",
        "Southern Stingray",
        "Sponge",
        "Spotted Porcupinefish",
        "Spotted Dolphin",
        "Spotted Eagle Ray",
        "Spotted Moray",
        "Squid",
        "Squidworm",
        "Starfish",
        "Stickleback",
        "Stonefish",
        "Stoplight Loosejaw",
        "Sturgeon",
        "Swordfish",
        "Tan Bristlemouth",
        "Tasseled Wobbegong",
        "Terrible Claw Lobster",
        "Threespot Damselfish",
        "Tiger Prawn",
        "Tiger Shark",
        "Tilefish",
        "Toadfish",
        "Tropical Two-Wing Flyfish",
        "Tuna",
        "Umbrella Squid",
        "Velvet Crab",
        "Venus Flytrap Sea Anemone",
        "Vigtorniella Worm",
        "Viperfish",
        "Vampire Squid",
        "Vaquita",
        "Wahoo",
        "Walrus",
        "West Indian Manatee",
        "Whale",
        "Whale Shark",
        "Whiptail Gulper",
        "White-Beaked Dolphin",
        "White-Ring Garden Eel",
        "White Shrimp",
        "Wobbegong",
        "Wrasse",
        "Wreckfish",
        "Xiphosura",
        "Yellowtail Damselfish",
        "Yelloweye Rockfish",
        "Yellow Cup Black Coral",
        "Yellow Tube Sponge",
        "Yellowfin Tuna",
        "Zebrashark",
        "Zooplankton"
    ],
    // list of desert, grassland, and forest animals comes from http://www.skyenimals.com/
    desert: [
        "Aardwolf",
        "Addax",
        "African Wild Ass",
        "Ant",
        "Antelope",
        "Armadillo",
        "Baboon",
        "Badger",
        "Bat",
        "Bearded Dragon",
        "Beetle",
        "Bird",
        "Black-footed Cat",
        "Boa",
        "Brown Bear",
        "Bustard",
        "Butterfly",
        "Camel",
        "Caracal",
        "Caracara",
        "Caterpillar",
        "Centipede",
        "Cheetah",
        "Chipmunk",
        "Chuckwalla",
        "Climbing Mouse",
        "Coati",
        "Cobra",
        "Cotton Rat",
        "Cougar",
        "Courser",
        "Crane Fly",
        "Crow",
        "Dassie Rat",
        "Dove",
        "Dunnart",
        "Eagle",
        "Echidna",
        "Elephant",
        "Emu",
        "Falcon",
        "Fly",
        "Fox",
        "Frogmouth",
        "Gecko",
        "Geoffroy's Cat",
        "Gerbil",
        "Grasshopper",
        "Guanaco",
        "Gundi",
        "Hamster",
        "Hawk",
        "Hedgehog",
        "Hyena",
        "Hyrax",
        "Jackal",
        "Kangaroo",
        "Kangaroo Rat",
        "Kestrel",
        "Kowari",
        "Kultarr",
        "Leopard",
        "Lion",
        "Macaw",
        "Meerkat",
        "Mouse",
        "Oryx",
        "Ostrich",
        "Owl",
        "Pronghorn",
        "Python",
        "Rabbit",
        "Raccoon",
        "Rattlesnake",
        "Rhinoceros",
        "Sand Cat",
        "Spectacled Bear",
        "Spiny Mouse",
        "Starling",
        "Stick Bug",
        "Tarantula",
        "Tit",
        "Toad",
        "Tortoise",
        "Tyrant Flycatcher",
        "Viper",
        "Vulture",
        "Waxwing",
        "Xerus",
        "Zebra"
    ],
    grassland: [
        "Aardvark",
        "Aardwolf",
        "Accentor",
        "African Buffalo",
        "African Wild Dog",
        "Alpaca",
        "Anaconda",
        "Ant",
        "Anteater",
        "Antelope",
        "Armadillo",
        "Baboon",
        "Badger",
        "Bandicoot",
        "Barbet",
        "Bat",
        "Bee",
        "Bee-eater",
        "Beetle",
        "Bird",
        "Bison",
        "Black-footed Cat",
        "Black-footed Ferret",
        "Bluebird",
        "Boa",
        "Bowerbird",
        "Brown Bear",
        "Bush Dog",
        "Bushshrike",
        "Bustard",
        "Butterfly",
        "Buzzard",
        "Caracal",
        "Caracara",
        "Cardinal",
        "Caterpillar",
        "Cheetah",
        "Chipmunk",
        "Civet",
        "Climbing Mouse",
        "Clouded Leopard",
        "Coati",
        "Cobra",
        "Cockatoo",
        "Cockroach",
        "Common Genet",
        "Cotton Rat",
        "Cougar",
        "Courser",
        "Coyote",
        "Crane",
        "Crane Fly",
        "Cricket",
        "Crow",
        "Culpeo",
        "Death Adder",
        "Deer",
        "Deer Mouse",
        "Dingo",
        "Dinosaur",
        "Dove",
        "Drongo",
        "Duck",
        "Duiker",
        "Dunnart",
        "Eagle",
        "Echidna",
        "Elephant",
        "Elk",
        "Emu",
        "Falcon",
        "Finch",
        "Flea",
        "Fly",
        "Flying Frog",
        "Fox",
        "Frog",
        "Frogmouth",
        "Garter Snake",
        "Gazelle",
        "Gecko",
        "Geoffroy's Cat",
        "Gerbil",
        "Giant Tortoise",
        "Giraffe",
        "Grasshopper",
        "Grison",
        "Groundhog",
        "Grouse",
        "Guanaco",
        "Guinea Pig",
        "Hamster",
        "Harrier",
        "Hartebeest",
        "Hawk",
        "Hedgehog",
        "Helmetshrike",
        "Hippopotamus",
        "Hornbill",
        "Hyena",
        "Hyrax",
        "Impala",
        "Jackal",
        "Jaguar",
        "Jaguarundi",
        "Kangaroo",
        "Kangaroo Rat",
        "Kestrel",
        "Kultarr",
        "Ladybug",
        "Leopard",
        "Lion",
        "Macaw",
        "Meerkat",
        "Mouse",
        "Newt",
        "Oryx",
        "Ostrich",
        "Owl",
        "Pangolin",
        "Pheasant",
        "Prairie Dog",
        "Pronghorn",
        "Przewalski's Horse",
        "Python",
        "Quoll",
        "Rabbit",
        "Raven",
        "Rhinoceros",
        "Shelduck",
        "Sloth Bear",
        "Spectacled Bear",
        "Squirrel",
        "Starling",
        "Stick Bug",
        "Tamandua",
        "Tasmanian Devil",
        "Thornbill",
        "Thrush",
        "Toad",
        "Tortoise"
    ],
    forest: [
        "Agouti",
        "Anaconda",
        "Anoa",
        "Ant",
        "Anteater",
        "Antelope",
        "Armadillo",
        "Asian Black Bear",
        "Aye-aye",
        "Babirusa",
        "Baboon",
        "Badger",
        "Bandicoot",
        "Banteng",
        "Barbet",
        "Basilisk",
        "Bat",
        "Bearded Dragon",
        "Bee",
        "Bee-eater",
        "Beetle",
        "Bettong",
        "Binturong",
        "Bird-of-paradise",
        "Bongo",
        "Bowerbird",
        "Bulbul",
        "Bush Dog",
        "Bushbaby",
        "Bushshrike",
        "Butterfly",
        "Buzzard",
        "Caecilian",
        "Cardinal",
        "Cassowary",
        "Caterpillar",
        "Centipede",
        "Chameleon",
        "Chimpanzee",
        "Cicada",
        "Civet",
        "Clouded Leopard",
        "Coati",
        "Cobra",
        "Cockatoo",
        "Cockroach",
        "Colugo",
        "Cotinga",
        "Cotton Rat",
        "Cougar",
        "Crane Fly",
        "Cricket",
        "Crocodile",
        "Crow",
        "Cuckoo",
        "Cuscus",
        "Death Adder",
        "Deer",
        "Dhole",
        "Dingo",
        "Dinosaur",
        "Drongo",
        "Duck",
        "Duiker",
        "Eagle",
        "Echidna",
        "Elephant",
        "Finch",
        "Flat-headed Cat",
        "Flea",
        "Flowerpecker",
        "Fly",
        "Flying Frog",
        "Fossa",
        "Frog",
        "Frogmouth",
        "Gaur",
        "Gecko",
        "Gorilla",
        "Grison",
        "Hawaiian Honeycreeper",
        "Hawk",
        "Hedgehog",
        "Helmetshrike",
        "Hornbill",
        "Hyrax",
        "Iguana",
        "Jackal",
        "Jaguar",
        "Jaguarundi",
        "Kestrel",
        "Ladybug",
        "Lemur",
        "Leopard",
        "Lion",
        "Macaw",
        "Mandrill",
        "Margay",
        "Monkey",
        "Mouse",
        "Mouse Deer",
        "Newt",
        "Okapi",
        "Old World Flycatcher",
        "Orangutan",
        "Owl",
        "Pangolin",
        "Peafowl",
        "Pheasant",
        "Possum",
        "Python",
        "Quokka",
        "Rabbit",
        "Raccoon",
        "Red Panda",
        "Red River Hog",
        "Rhinoceros",
        "Sloth Bear",
        "Spectacled Bear",
        "Squirrel",
        "Starling",
        "Stick Bug",
        "Sun Bear",
        "Tamandua",
        "Tamarin",
        "Tapir",
        "Tarantula",
        "Thrush",
        "Tiger",
        "Tit",
        "Toad",
        "Tortoise",
        "Toucan",
        "Trogon",
        "Trumpeter",
        "Turaco",
        "Turtle",
        "Tyrant Flycatcher",
        "Viper",
        "Vulture",
        "Wallaby",
        "Warbler",
        "Wasp",
        "Waxwing",
        "Weaver",
        "Weaver-finch",
        "Whistler",
        "White-eye",
        "Whydah",
        "Woodswallow",
        "Worm",
        "Wren",
        "Xenops",
        "Yellowjacket",
        "Accentor",
        "African Buffalo",
        "American Black Bear",
        "Anole",
        "Bird",
        "Bison",
        "Boa",
        "Brown Bear",
        "Chipmunk",
        "Common Genet",
        "Copperhead",
        "Coyote",
        "Deer Mouse",
        "Dormouse",
        "Elk",
        "Emu",
        "Fisher",
        "Fox",
        "Garter Snake",
        "Giant Panda",
        "Giant Tortoise",
        "Groundhog",
        "Grouse",
        "Guanaco",
        "Himalayan Tahr",
        "Kangaroo",
        "Koala",
        "Numbat",
        "Quoll",
        "Raccoon dog",
        "Tasmanian Devil",
        "Thornbill",
        "Turkey",
        "Vole",
        "Weasel",
        "Wildcat",
        "Wolf",
        "Wombat",
        "Woodchuck",
        "Woodpecker"
    ],
    // list of farm animals comes from https://www.buzzle.com/articles/farm-animals-list.html
    farm: [
        "Alpaca",
        "Buffalo",
        "Banteng",
        "Cow",
        "Cat",
        "Chicken",
        "Carp",
        "Camel",
        "Donkey",
        "Dog",
        "Duck",
        "Emu",
        "Goat",
        "Gayal",
        "Guinea",
        "Goose",
        "Horse",
        "Honey",
        "Llama",
        "Pig",
        "Pigeon",
        "Rhea",
        "Rabbit",
        "Sheep",
        "Silkworm",
        "Turkey",
        "Yak",
        "Zebu"
    ],
    // list of pet animals comes from https://www.dogbreedinfo.com/pets/pet.htm
    pet: [
        "Bearded Dragon",
        "Birds",
        "Burro",
        "Cats",
        "Chameleons",
        "Chickens",
        "Chinchillas",
        "Chinese Water Dragon",
        "Cows",
        "Dogs",
        "Donkey",
        "Ducks",
        "Ferrets",
        "Fish",
        "Geckos",
        "Geese",
        "Gerbils",
        "Goats",
        "Guinea Fowl",
        "Guinea Pigs",
        "Hamsters",
        "Hedgehogs",
        "Horses",
        "Iguanas",
        "Llamas",
        "Lizards",
        "Mice",
        "Mule",
        "Peafowl",
        "Pigs and Hogs",
        "Pigeons",
        "Ponies",
        "Pot Bellied Pig",
        "Rabbits",
        "Rats",
        "Sheep",
        "Skinks",
        "Snakes",
        "Stick Insects",
        "Sugar Gliders",
        "Tarantula",
        "Turkeys",
        "Turtles"
    ],
    // list of zoo animals comes from https://bronxzoo.com/animals
    zoo: [
        "Aardvark",
        "African Wild Dog",
        "Aldabra Tortoise",
        "American Alligator",
        "American Bison",
        "Amur Tiger",
        "Anaconda",
        "Andean Condor",
        "Asian Elephant",
        "Baby Doll Sheep",
        "Bald Eagle",
        "Barred Owl",
        "Blue Iguana",
        "Boer Goat",
        "California Sea Lion",
        "Caribbean Flamingo",
        "Chinchilla",
        "Collared Lemur",
        "Coquerel's Sifaka",
        "Cuban Amazon Parrot",
        "Ebony Langur",
        "Fennec Fox",
        "Fossa",
        "Gelada",
        "Giant Anteater",
        "Giraffe",
        "Gorilla",
        "Grizzly Bear",
        "Henkel's Leaf-tailed Gecko",
        "Indian Gharial",
        "Indian Rhinoceros",
        "King Cobra",
        "King Vulture",
        "Komodo Dragon",
        "Linne's Two-toed Sloth",
        "Lion",
        "Little Penguin",
        "Madagascar Tree Boa",
        "Magellanic Penguin",
        "Malayan Tapir",
        "Malayan Tiger",
        "Matschies Tree Kangaroo",
        "Mini Donkey",
        "Monarch Butterfly",
        "Nile crocodile",
        "North American Porcupine",
        "Nubian Ibex",
        "Okapi",
        "Poison Dart Frog",
        "Polar Bear",
        "Pygmy Marmoset",
        "Radiated Tortoise",
        "Red Panda",
        "Red Ruffed Lemur",
        "Ring-tailed Lemur",
        "Ring-tailed Mongoose",
        "Rock Hyrax",
        "Small Clawed Asian Otter",
        "Snow Leopard",
        "Snowy Owl",
        "Southern White-faced Owl",
        "Southern White Rhinocerous",
        "Squirrel Monkey",
        "Tufted Puffin",
        "White Cheeked Gibbon",
        "White-throated Bee Eater",
        "Zebra"
    ]
};
// Source: https://en.wikipedia.org/wiki/List_of_population_centers_by_latitude
const cities = [
    "Alert",
    "Nord",
    "Eureka",
    "Ny-Ålesund",
    "Longyearbyen",
    "Qaanaaq",
    "Grise Fiord",
    "Dikson",
    "Upernavik",
    "Tiksi",
    "Belushya Guba",
    "Barrow",
    "Honningsvåg",
    "Hammerfest",
    "Deadhorse",
    "Nuorgam",
    "Vadsø",
    "Alta",
    "Utsjoki",
    "Kirkenes",
    "Tromsø",
    "Tuktoyaktuk",
    "Norilsk",
    "Murmansk",
    "Harstad",
    "Narvik",
    "Inuvik",
    "Kiruna",
    "Verkhoyansk",
    "Bodø",
    "Gällivare",
    "Kemijärvi",
    "Rovaniemi",
    "Ísafjörður",
    "Kuusamo",
    "Tornio",
    "Boden",
    "Haparanda",
    "Kemi",
    "Akureyri",
    "Luleå",
    "Pudasjärvi",
    "Piteå",
    "Oulu",
    "Fairbanks",
    "Skellefteå",
    "Anadyr",
    "Arkhangelsk",
    "Nome",
    "Nuuk (Godthåb)",
    "Reykjavík",
    "Umeå",
    "Iqaluit",
    "Stjørdal",
    "Trondheim",
    "Örnsköldsvik",
    "Östersund",
    "Vaasa",
    "Kuopio",
    "Yellowknife",
    "Sundsvall",
    "Jyväskylä",
    "Yakutsk",
    "Tórshavn",
    "Petrozavodsk",
    "Tampere",
    "Anchorage",
    "Lillehammer",
    "Lahti",
    "Qaqortoq",
    "Whitehorse",
    "Turku",
    "Bergen",
    "Vantaa",
    "Lerwick",
    "Espoo",
    "Helsinki",
    "Oslo",
    "Saint Petersburg",
    "Uppsala",
    "Fritz Creek",
    "Magadan",
    "Tallinn",
    "Stockholm",
    "Sarpsborg",
    "Örebro",
    "Vologda",
    "Norrköping",
    "Linköping",
    "Tartu",
    "Juneau",
    "Arendal",
    "Kristiansand",
    "Perm",
    "Valga",
    "Gothenburg",
    "Visby",
    "Yaroslavl",
    "Inverness",
    "Aberdeen",
    "Sitka",
    "Riga",
    "Izhevsk",
    "Yekaterinburg",
    "Fort McMurray",
    "Dundee",
    "Nizhny Novgorod",
    "Stirling",
    "Bratsk",
    "Aarhus",
    "Krasnoyarsk",
    "Edinburgh",
    "Glasgow",
    "Kazan",
    "Moscow",
    "Copenhagen",
    "Malmö",
    "Esbjerg",
    "Odense",
    "Grande Prairie",
    "Chelyabinsk",
    "Novosibirsk",
    "Derry",
    "Omsk",
    "Newcastle upon Tyne",
    "Sunderland",
    "Petropavl",
    "Flensburg",
    "Ufa",
    "Kaliningrad",
    "Vilnius",
    "Belfast",
    "Middlesbrough",
    "Gdynia",
    "Gdańsk",
    "Kiel",
    "Douglas",
    "Rostock",
    "Lancaster",
    "York",
    "Prince George",
    "Minsk",
    "Bradford",
    "Leeds",
    "Hamburg",
    "Edmonton",
    "Tolyatti",
    "Manchester",
    "Liverpool",
    "Sheffield",
    "Dublin",
    "Groningen",
    "Samara",
    "Bremen",
    "Petropavlovsk-Kamchatsky",
    "Nottingham",
    "Derby",
    "Leicester",
    "Norwich",
    "Peterborough",
    "Berlin",
    "Birmingham",
    "Gomel",
    "Coventry",
    "Poznań",
    "Haarlem",
    "Amsterdam",
    "Hannover",
    "Irkutsk",
    "Warsaw",
    "Enschede",
    "Cambridge",
    "Leiden",
    "Saskatoon",
    "Utrecht",
    "The Hague",
    "Münster",
    "Rotterdam",
    "Cork",
    "Adak",
    "Gloucester",
    "Oxford",
    "Voronezh",
    "Swansea",
    "Saratov",
    "Dortmund",
    "London",
    "Cardiff",
    "Greenwich",
    "Bristol",
    "Bath",
    "Leipzig",
    "Düsseldorf",
    "Antwerp",
    "Astana",
    "Winchester",
    "Calgary",
    "Ghent",
    "Dresden",
    "Erfurt",
    "Calais",
    "Cologne",
    "Southampton",
    "Maastricht",
    "Brussels",
    "Brighton and Hove",
    "Portsmouth",
    "Exeter",
    "Kamloops",
    "Lille",
    "Regina",
    "Kiev",
    "Charleroi",
    "Plymouth",
    "Frankfurt am Main",
    "Prague",
    "Kraków",
    "Kharkiv",
    "Winnipeg",
    "Kelowna",
    "Lviv",
    "Luxembourg",
    "Le Havre",
    "Nuremberg",
    "Rouen",
    "Vancouver",
    "Paris",
    "Stuttgart",
    "Bellingham",
    "Volgograd",
    "Strasbourg",
    "Dnipro",
    "Victoria",
    "Saguenay",
    "Brest",
    "Thunder Bay",
    "Linz",
    "Vienna",
    "Bratislava",
    "Munich",
    "Donetsk",
    "Ulaanbaatar",
    "Orléans",
    "Salzburg",
    "Seattle",
    "St. John's",
    "Basel",
    "Budapest",
    "Qiqihar",
    "Zürich",
    "Innsbruck",
    "Rostov-on-Don",
    "Nantes",
    "Vaduz",
    "Atyrau",
    "Graz",
    "Chişinău",
    "Bern",
    "Tiraspol",
    "Quebec City",
    "Bismarck",
    "Duluth",
    "Saint-Pierre",
    "Cluj-Napoca",
    "Moscow",
    "Helena",
    "Sault Ste. Marie",
    "Lausanne",
    "Sudbury",
    "Odessa",
    "North Bay",
    "Charlottetown",
    "Geneva",
    "Moncton",
    "Ljubljana",
    "Fredericton",
    "Zagreb",
    "Lyon",
    "Harbin",
    "New Glasgow",
    "Portland",
    "Montreal",
    "Milan",
    "Venice",
    "Ottawa",
    "Wakkanai",
    "Saint John",
    "Novi Sad",
    "Turin",
    "Krasnodar",
    "Minneapolis",
    "Simferopol",
    "Halifax",
    "Bordeaux",
    "Belgrade",
    "Šabac",
    "Drobeta Turnu Severin",
    "Bologna",
    "Bucharest",
    "Ravenna",
    "Genoa",
    "Pierre",
    "Craiova",
    "Augusta",
    "Montpelier",
    "Bath",
    "San Marino",
    "Changchun",
    "Sarajevo",
    "Yarmouth",
    "Ürümqi",
    "Florence",
    "Asahikawa",
    "Monaco",
    "Nice",
    "Toronto",
    "Boise",
    "Toulouse",
    "Sochi",
    "Cannes",
    "Gijón",
    "Sioux Falls",
    "Split",
    "Oviedo",
    "Nemuro",
    "San Sebastián",
    "Marseille",
    "Almaty",
    "Bilbao",
    "Concord",
    "Rochester",
    "Vladivostok",
    "Sapporo",
    "Milwaukee",
    "Sukhumi",
    "Kushiro",
    "London",
    "Follonica",
    "Obihiro",
    "Buffalo",
    "Santiago de Compostela",
    "Bishkek",
    "Vitoria-Gasteiz",
    "Sofia",
    "Pristina",
    "Andorra la Vella",
    "Nukus",
    "Podgorica",
    "Boston",
    "Detroit",
    "Windsor",
    "Vigo",
    "Tskhinvali",
    "Avezzano",
    "Skopje",
    "Colchester",
    "Rome",
    "Vatican City",
    "Chicago",
    "Providence",
    "Shenyang",
    "Chongjin",
    "Hartford",
    "Hakodate",
    "Tbilisi",
    "Valladolid",
    "Zaragoza",
    "Des Moines",
    "Braga",
    "Cleveland",
    "Barcelona",
    "Tirana",
    "Tashkent",
    "Porto",
    "Cheyenne",
    "Bari",
    "Fort Wayne",
    "Istanbul",
    "Trabzon",
    "Namangan",
    "Naples",
    "Aomori",
    "Lincoln",
    "Eureka",
    "Salt Lake City",
    "Jersey City",
    "New York City",
    "Thessaloniki",
    "Lleida",
    "Pittsburgh",
    "Baku",
    "Madrid",
    "Trenton",
    "Bursa",
    "Yerevan",
    "Boulder",
    "Columbus",
    "Ankara",
    "Philadelphia",
    "Beijing",
    "Stepanakert",
    "Forked River",
    "Eskisehir",
    "Indianapolis",
    "Denver",
    "Akita",
    "Morioka",
    "Palma",
    "Reno",
    "Flores Island",
    "Valencia",
    "Baltimore",
    "Cagliari",
    "Dover",
    "Wonsan",
    "Tianjin",
    "Cincinnati",
    "Kansas City",
    "Pyongyang",
    "Ibiza",
    "Dalian",
    "Washington",
    "Lisbon",
    "St. Louis",
    "Horta",
    "Sacramento",
    "Dushanbe",
    "Angra do Heroísmo",
    "Halkida",
    "İzmir",
    "Charleston",
    "Alicante",
    "Sendai",
    "Louisville",
    "Yamagata",
    "Messina",
    "Palermo",
    "Tabriz",
    "Shijiazhuang",
    "Trapani",
    "Athena",
    "Kaesong",
    "Ashgabat",
    "Niigata",
    "Taiyuan",
    "Konya",
    "Ponta Delgada",
    "Oakland",
    "San Francisco",
    "Fukushima",
    "Wichita",
    "Seoul",
    "San Jose",
    "Catania",
    "Incheon",
    "Sevilla",
    "Mugla",
    "Springfield",
    "Gaziantep",
    "Adana",
    "Virginia Beach",
    "Almería",
    "Tunis",
    "Mersin",
    "Algiers",
    "Málaga",
    "Toyama",
    "Jinan",
    "Nagano",
    "Xining",
    "Handan",
    "Kanazawa",
    "Utsunomiya",
    "Maebashi",
    "Mito",
    "Mosul",
    "Mashhad",
    "Arbil",
    "Las Vegas",
    "Nashville",
    "Gibraltar",
    "Tulsa",
    "Fukui",
    "Qingdao",
    "Lanzhou",
    "Knoxville",
    "Valletta",
    "Birkirkara",
    "Los Alamos",
    "Daegu",
    "Raleigh",
    "Tangier",
    "Tehran",
    "Tokyo",
    "Santa Fe",
    "Kōfu",
    "Chiba",
    "Latakia",
    "Kawasaki",
    "Tottori",
    "Oklahoma City",
    "Matsue",
    "Kirkuk",
    "Yokohama",
    "Gifu",
    "Tiaret",
    "Heraklion",
    "Melilla",
    "Charlotte",
    "Nagoya",
    "Busan",
    "Nicosia",
    "Memphis",
    "Albuquerque",
    "Ōtsu",
    "Kyoto",
    "Shizuoka",
    "Zhengzhou",
    "Little Rock",
    "Sfax",
    "Tsu",
    "Osaka",
    "Kōbe",
    "Nara",
    "Okayama",
    "Kabul",
    "Santa Barbara",
    "Hiroshima",
    "Takamatsu",
    "Xi'an",
    "Wakayama",
    "Wilmington",
    "Yamaguchi",
    "Arak",
    "Srinagar",
    "Tokushima",
    "Los Angeles",
    "Rabat",
    "Peshawar",
    "Columbia",
    "Riverside",
    "Beirut",
    "Matsuyama",
    "Atlanta",
    "Islamabad",
    "Birmingham",
    "Rawalpindi",
    "Fukuoka",
    "Kōchi",
    "Casablanca",
    "Damascus",
    "Phoenix",
    "Lubbock",
    "Baghdad",
    "Saga",
    "Ōita",
    "Tripoli",
    "Charleston",
    "Dallas",
    "Nagasaki",
    "Kumamoto",
    "San Diego",
    "Mexicali",
    "Funchal",
    "El Centro",
    "Isfahan",
    "Karbala",
    "Tijuana",
    "Shreveport",
    "Jackson",
    "Hamilton",
    "Tucson",
    "Benghazi",
    "Tel Aviv",
    "Nanjing",
    "Najaf",
    "Amman",
    "Miyazaki",
    "Ramallah",
    "Ensenada",
    "El Paso",
    "Jerusalem",
    "Ciudad Juárez",
    "Amritsar",
    "Marrakech",
    "Kandahar",
    "Kagoshima",
    "Lahore",
    "Gaza",
    "Faisalabad",
    "Port Said",
    "Alexandria",
    "Shanghai",
    "Shimla",
    "Ludhiana",
    "Chandigarh",
    "Mobile",
    "Chengdu",
    "Wuhan",
    "Basra",
    "Agadir",
    "Jacksonville",
    "Austin",
    "Hangzhou",
    "Multan",
    "Cairo",
    "New Orleans",
    "Suez",
    "Houston",
    "Lhasa",
    "Chongqing",
    "Eilat",
    "San Antonio",
    "Kuwait City",
    "Shigatse",
    "Hermosillo",
    "Chihuahua",
    "New Delhi",
    "Santa Cruz de Tenerife",
    "Orlando",
    "Las Palmas de Gran Canaria",
    "Tampa",
    "Corpus Christi",
    "Maspalomas",
    "Kathmandu",
    "Dibrugarh",
    "Thimphu",
    "Gangtok",
    "Agra",
    "El Aaiún",
    "Sabha",
    "Jaipur",
    "Lucknow",
    "Siliguri",
    "Tezpur",
    "Kanpur",
    "Dammam",
    "Naha",
    "Manama",
    "Guwahati",
    "Brownsville",
    "Miami",
    "Luxor",
    "Monterrey",
    "Patna",
    "Shillong",
    "Torreón",
    "Kulpahar",
    "Doha",
    "Dubai",
    "Hyderabad",
    "Nassau",
    "Kunming",
    "Taipei",
    "Karachi",
    "Culiacán",
    "Riyadh",
    "Key West",
    "Medina",
    "Abu Dhabi",
    "Al Ain",
    "Taichung",
    "Durango",
    "Agartala",
    "Dhaka",
    "Muscat",
    "Havana",
    "Guangzhou",
    "Ahmedabad",
    "Dongguan",
    "Tainan",
    "Cabo San Lucas",
    "Nanning",
    "Kaohsiung",
    "Kolkata (Calcutta)",
    "Shenzhen",
    "Chittagong",
    "Hong Kong",
    "Tampico",
    "San Luis Potosí",
    "Aguascalientes",
    "Jeddah",
    "Cockburn Town",
    "Mecca",
    "Honolulu",
    "Chhattisgarh",
    "Cancún",
    "Surat",
    "Nagpur",
    "León",
    "Hanoi",
    "Mérida",
    "Hai Phong",
    "Zapopan",
    "Puerto Vallarta",
    "Guadalajara",
    "Querétaro",
    "Haikou",
    "Santiago de Cuba",
    "Chiang Rai",
    "Naypyidaw",
    "Hilo",
    "George Town",
    "Veracruz",
    "Puebla",
    "Mumbai",
    "Chiang Mai",
    "Port-au-Prince",
    "Pune",
    "Santo Domingo",
    "San Juan",
    "Road Town",
    "Charlotte Amalie",
    "The Valley",
    "Nouakchott",
    "Kingston",
    "Vientiane",
    "Visakhapatnam",
    "Belize City",
    "Udon Thani",
    "Hyderabad",
    "Basseterre",
    "Belmopan",
    "St. John's",
    "Salalah",
    "Acapulco",
    "Yangon",
    "Timbuktu",
    "Huế",
    "Khon Kaen",
    "Da Nang",
    "Basse-Terre",
    "Omdurman",
    "Khartoum",
    "Sana'a",
    "Asmara",
    "Roseau",
    "Saipan",
    "Son My",
    "Nakhon Ratchasima",
    "Praia",
    "Tapachula",
    "Quetzaltenango",
    "Thiès",
    "Dakar",
    "Quezon City",
    "Guatemala City",
    "Fort-de-France",
    "Manila",
    "Makati",
    "Ayutthaya",
    "Tegucigalpa",
    "Castries",
    "Bangkok",
    "San Salvador",
    "Niamey",
    "Dededo",
    "Hagåtña",
    "Banjul",
    "Serekunda",
    "Siem Reap",
    "Brikama",
    "Kingstown",
    "Bridgetown",
    "Chennai (Madras)",
    "Bangalore",
    "Pattaya",
    "Koulikoro",
    "Bamako",
    "Chinandega",
    "Oranjestad",
    "Ouagadougou",
    "Managua",
    "Willemstad",
    "N'Djamena",
    "St. George's",
    "Kano",
    "Bissau",
    "Port Blair",
    "Djibouti",
    "Phnom Penh",
    "Bobo-Dioulasso",
    "Barranquilla",
    "Ho Chi Minh City",
    "Iloilo City",
    "Port of Spain",
    "Maracaibo",
    "Liberia",
    "Caracas",
    "Chaguanas",
    "Cartagena",
    "San Fernando",
    "Cebu City",
    "Maracay",
    "Valencia",
    "Alajuela",
    "Limón",
    "Jaffna",
    "Hargeisa",
    "Puntarenas",
    "Kochi",
    "San José",
    "Tagbilaran",
    "Conakry",
    "Tamale",
    "Surat Thani",
    "Abuja",
    "Addis Ababa",
    "Panama City",
    "Mérida",
    "Moundou",
    "Trivandrum",
    "Freetown",
    "Ciudad Bolívar",
    "Cúcuta",
    "Phuket",
    "San Cristóbal",
    "Nzérékoré",
    "Batticaloa",
    "Melekeok",
    "Weno",
    "Ibadan",
    "Koror",
    "Kandy",
    "Majuro",
    "Davao City",
    "Hat Yai",
    "Colombo",
    "Palikir",
    "Sri Jayawardenapura-Kotte",
    "Zamboanga City",
    "Yamoussoukro",
    "Georgetown",
    "Kumasi",
    "Porto-Novo",
    "Lagos",
    "Enugu",
    "Cotonou",
    "Benin City",
    "Monrovia",
    "Medellín",
    "Lomé",
    "Kota Bharu",
    "Alor Setar",
    "Kota Kinabalu",
    "Paramaribo",
    "Puerto Ayacucho",
    "Accra",
    "Banda Aceh",
    "George Town",
    "Abidjan",
    "Cayenne",
    "Sekondi-Takoradi",
    "Bandar Seri Begawan",
    "Juba",
    "Port Harcourt",
    "Ipoh",
    "Bogotá",
    "Miri",
    "Bangui",
    "Malé",
    "Douala",
    "Yaoundé",
    "Malabo",
    "Medan",
    "Santiago de Cali",
    "Kuala Lumpur",
    "Boa Vista",
    "Malacca Town",
    "Mogadishu",
    "Kuching",
    "Johor Bahru",
    "South Tarawa",
    "Singapore",
    "Pekanbaru",
    "Libreville",
    "São Tomé",
    "Kampala",
    "Entebbe",
    "Mbandaka",
    "Macapá",
    "Pontianak",
    "Quito",
    "Kismayo",
    "Yaren District",
    "Padang",
    "Balikpapan",
    "Nairobi",
    "Belém",
    "Kigali",
    "Guayaquil",
    "Mwanza",
    "São Luís",
    "Jayapura",
    "Palembang",
    "Manaus",
    "Bujumbura",
    "Sobral",
    "Ambon",
    "Fortaleza",
    "Iquitos",
    "Fernando de Noronha",
    "Mombasa",
    "Brazzaville",
    "Kinshasa",
    "Victoria",
    "Teresina",
    "Makassar",
    "Imperatriz",
    "Natal",
    "Zanzibar City",
    "Dodoma",
    "Jakarta",
    "Bogor",
    "Dar es Salaam",
    "Bandung",
    "Semarang",
    "João Pessoa",
    "Juazeiro do Norte",
    "Campina Grande",
    "Surabaya",
    "Yogyakarta",
    "Malang",
    "Recife",
    "Trujillo",
    "Caruaru",
    "Funafuti",
    "Dili",
    "Denpasar",
    "Porto Velho",
    "Luanda",
    "Garanhuns",
    "Nukulaelae",
    "Petrolina",
    "Honiara",
    "Port Moresby",
    "Maceió",
    "Rio Branco",
    "Aracaju",
    "Palmas",
    "Lubumbashi",
    "Moroni",
    "Sinop",
    "Lima",
    "Darwin",
    "Huambo",
    "Mamoudzou",
    "Ndola",
    "Salvador",
    "Ayacucho",
    "Mata-Utu",
    "Cusco",
    "Apia",
    "Lilongwe",
    "Pago Pago",
    "Ilhéus",
    "Lusaka",
    "Cuiabá",
    "Blantyre",
    "Brasília",
    "Jamestown",
    "Arequipa",
    "Labasa",
    "Rabi Island",
    "La Paz",
    "Goiânia",
    "Cairns",
    "Papeete",
    "Port Vila",
    "Santa Cruz de la Sierra",
    "Livingstone",
    "Harare",
    "Suva",
    "Arica",
    "Governador Valadares",
    "Uberlândia",
    "Antananarivo",
    "Mutare",
    "Sucre",
    "Alofi",
    "Townsville",
    "Gweru",
    "Belo Horizonte",
    "Port Louis",
    "Bulawayo",
    "Iquique",
    "Port Hedland",
    "Vitória",
    "Campo Grande",
    "São José do Rio Preto",
    "Saint-Denis",
    "Nukuʻalofa",
    "Francistown",
    "Ribeirão Preto",
    "Avarua",
    "Juiz de Fora",
    "Poços de Caldas",
    "Araraquara",
    "Nouméa",
    "Bauru",
    "Calama",
    "Windhoek",
    "Assis",
    "Campinas",
    "Rio de Janeiro",
    "São José dos Campos",
    "Rockhampton",
    "São Paulo",
    "Antofagasta",
    "Polokwane",
    "Gaborone",
    "Salta",
    "Adamstown",
    "Asunción",
    "Curitiba",
    "Nelspruit",
    "Ciudad del Este",
    "Pretoria",
    "Mafikeng",
    "Maputo",
    "Johannesburg",
    "Mbabane",
    "Lobamba",
    "Manzini",
    "San Miguel de Tucumán",
    "Hanga Roa",
    "Copiapó",
    "Brisbane",
    "Corrientes",
    "Florianópolis",
    "Gold Coast",
    "Kimberley",
    "Kingston",
    "Bloemfontein",
    "Maseru",
    "Pietermaritzburg",
    "Durban",
    "La Serena",
    "Córdoba",
    "Santa Fe",
    "Pelotas",
    "Perth",
    "San Juan",
    "Mandurah",
    "Bhisho",
    "Mendoza",
    "Newcastle",
    "Rosario",
    "Viña del Mar",
    "Valparaíso",
    "Santiago",
    "Chuí",
    "Sydney",
    "Cape Town",
    "Port Elizabeth",
    "Wollongong",
    "Buenos Aires",
    "Montevideo",
    "Adelaide",
    "Canberra",
    "Concepción",
    "Auckland",
    "Edinburgh of the Seven Seas",
    "Hamilton",
    "Melbourne",
    "Mar del Plata",
    "Geelong",
    "Bahía Blanca",
    "Temuco",
    "Neuquén",
    "Hastings",
    "Valdivia",
    "San Carlos de Bariloche",
    "Nelson",
    "Wellington",
    "Puerto Montt",
    "Launceston, Tasmania",
    "Hobart",
    "Trelew",
    "Christchurch",
    "Waitangi",
    "Puerto Aisén",
    "Coihaique",
    "Comodoro Rivadavia",
    "Dunedin",
    "Invercargill",
    "Río Gallegos",
    "Stanley",
    "Punta Arenas",
    "Grytviken",
    "Ushuaia",
    "Puerto Williams",
    "Puerto Toro",
    "Villa Las Estrellas",
    "Esperanza",
    "Rothera",
    "Concordia"
];

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}


var $f4087201da764553$exports = {};
$f4087201da764553$exports = JSON.parse('{"categories":["Cc","Zs","Po","Sc","Ps","Pe","Sm","Pd","Nd","Lu","Sk","Pc","Ll","So","Lo","Pi","Cf","No","Pf","Lt","Lm","Mn","Me","Mc","Nl","Zl","Zp","Cs","Co"],"combiningClasses":["Not_Reordered","Above","Above_Right","Below","Attached_Above_Right","Attached_Below","Overlay","Iota_Subscript","Double_Below","Double_Above","Below_Right","Above_Left","CCC10","CCC11","CCC12","CCC13","CCC14","CCC15","CCC16","CCC17","CCC18","CCC19","CCC20","CCC21","CCC22","CCC23","CCC24","CCC25","CCC30","CCC31","CCC32","CCC27","CCC28","CCC29","CCC33","CCC34","CCC35","CCC36","Nukta","Virama","CCC84","CCC91","CCC103","CCC107","CCC118","CCC122","CCC129","CCC130","CCC132","Attached_Above","Below_Left","Left","Kana_Voicing","CCC26","Right"],"scripts":["Common","Latin","Bopomofo","Inherited","Greek","Coptic","Cyrillic","Armenian","Hebrew","Arabic","Syriac","Thaana","Nko","Samaritan","Mandaic","Devanagari","Bengali","Gurmukhi","Gujarati","Oriya","Tamil","Telugu","Kannada","Malayalam","Sinhala","Thai","Lao","Tibetan","Myanmar","Georgian","Hangul","Ethiopic","Cherokee","Canadian_Aboriginal","Ogham","Runic","Tagalog","Hanunoo","Buhid","Tagbanwa","Khmer","Mongolian","Limbu","Tai_Le","New_Tai_Lue","Buginese","Tai_Tham","Balinese","Sundanese","Batak","Lepcha","Ol_Chiki","Braille","Glagolitic","Tifinagh","Han","Hiragana","Katakana","Yi","Lisu","Vai","Bamum","Syloti_Nagri","Phags_Pa","Saurashtra","Kayah_Li","Rejang","Javanese","Cham","Tai_Viet","Meetei_Mayek","null","Linear_B","Lycian","Carian","Old_Italic","Gothic","Old_Permic","Ugaritic","Old_Persian","Deseret","Shavian","Osmanya","Osage","Elbasan","Caucasian_Albanian","Linear_A","Cypriot","Imperial_Aramaic","Palmyrene","Nabataean","Hatran","Phoenician","Lydian","Meroitic_Hieroglyphs","Meroitic_Cursive","Kharoshthi","Old_South_Arabian","Old_North_Arabian","Manichaean","Avestan","Inscriptional_Parthian","Inscriptional_Pahlavi","Psalter_Pahlavi","Old_Turkic","Old_Hungarian","Hanifi_Rohingya","Old_Sogdian","Sogdian","Elymaic","Brahmi","Kaithi","Sora_Sompeng","Chakma","Mahajani","Sharada","Khojki","Multani","Khudawadi","Grantha","Newa","Tirhuta","Siddham","Modi","Takri","Ahom","Dogra","Warang_Citi","Nandinagari","Zanabazar_Square","Soyombo","Pau_Cin_Hau","Bhaiksuki","Marchen","Masaram_Gondi","Gunjala_Gondi","Makasar","Cuneiform","Egyptian_Hieroglyphs","Anatolian_Hieroglyphs","Mro","Bassa_Vah","Pahawh_Hmong","Medefaidrin","Miao","Tangut","Nushu","Duployan","SignWriting","Nyiakeng_Puachue_Hmong","Wancho","Mende_Kikakui","Adlam"],"eaw":["N","Na","A","W","H","F"]}');


const $747425b437e121da$var$trie = new ($bdjGp$unicodetrie)(($bdjGp$base64js).toByteArray("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"));
const $747425b437e121da$var$log2 = Math.log2 || ((n)=>Math.log(n) / Math.LN2);
const $747425b437e121da$var$bits = (n)=>$747425b437e121da$var$log2(n) + 1 | 0;
// compute the number of bits stored for each field
const $747425b437e121da$var$CATEGORY_BITS = $747425b437e121da$var$bits(((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).categories.length - 1);
const $747425b437e121da$var$COMBINING_BITS = $747425b437e121da$var$bits(((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).combiningClasses.length - 1);
const $747425b437e121da$var$SCRIPT_BITS = $747425b437e121da$var$bits(((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).scripts.length - 1);
const $747425b437e121da$var$EAW_BITS = $747425b437e121da$var$bits(((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).eaw.length - 1);
const $747425b437e121da$var$NUMBER_BITS = 10;
// compute shift and mask values for each field
const $747425b437e121da$var$CATEGORY_SHIFT = $747425b437e121da$var$COMBINING_BITS + $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$COMBINING_SHIFT = $747425b437e121da$var$SCRIPT_BITS + $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$SCRIPT_SHIFT = $747425b437e121da$var$EAW_BITS + $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$EAW_SHIFT = $747425b437e121da$var$NUMBER_BITS;
const $747425b437e121da$var$CATEGORY_MASK = (1 << $747425b437e121da$var$CATEGORY_BITS) - 1;
const $747425b437e121da$var$COMBINING_MASK = (1 << $747425b437e121da$var$COMBINING_BITS) - 1;
const $747425b437e121da$var$SCRIPT_MASK = (1 << $747425b437e121da$var$SCRIPT_BITS) - 1;
const $747425b437e121da$var$EAW_MASK = (1 << $747425b437e121da$var$EAW_BITS) - 1;
const $747425b437e121da$var$NUMBER_MASK = (1 << $747425b437e121da$var$NUMBER_BITS) - 1;
function $747425b437e121da$export$410364bbb673ddbc(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return ((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).categories[val >> $747425b437e121da$var$CATEGORY_SHIFT & $747425b437e121da$var$CATEGORY_MASK];
}
function $747425b437e121da$export$c03b919c6651ed55(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return ((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).combiningClasses[val >> $747425b437e121da$var$COMBINING_SHIFT & $747425b437e121da$var$COMBINING_MASK];
}
function $747425b437e121da$export$941569448d136665(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return ((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).scripts[val >> $747425b437e121da$var$SCRIPT_SHIFT & $747425b437e121da$var$SCRIPT_MASK];
}
function $747425b437e121da$export$92f6187db8ca6d26(codePoint) {
    const val = $747425b437e121da$var$trie.get(codePoint);
    return ((/*@__PURE__*/$parcel$interopDefault($f4087201da764553$exports))).eaw[val >> $747425b437e121da$var$EAW_SHIFT & $747425b437e121da$var$EAW_MASK];
}
function $747425b437e121da$export$7d1258ebb7625a0d(codePoint) {
    let val = $747425b437e121da$var$trie.get(codePoint);
    let num = val & $747425b437e121da$var$NUMBER_MASK;
    if (num === 0) return null;
    else if (num <= 50) return num - 1;
    else if (num < 0x1e0) {
        const numerator = (num >> 4) - 12;
        const denominator = (num & 0xf) + 1;
        return numerator / denominator;
    } else if (num < 0x300) {
        val = (num >> 5) - 14;
        let exp = (num & 0x1f) + 2;
        while(exp > 0){
            val *= 10;
            exp--;
        }
        return val;
    } else {
        val = (num >> 2) - 0xbf;
        let exp = (num & 3) + 1;
        while(exp > 0){
            val *= 60;
            exp--;
        }
        return val;
    }
}
function $747425b437e121da$export$52c8ea63abd07594(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Nl";
}
function $747425b437e121da$export$727d9dbc4fbb948f(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Nd";
}
function $747425b437e121da$export$a5b49f4dc6a07d2c(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Pc" || category === "Pd" || category === "Pe" || category === "Pf" || category === "Pi" || category === "Po" || category === "Ps";
}
function $747425b437e121da$export$7b6804e8df61fcf5(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Ll";
}
function $747425b437e121da$export$aebd617640818cda(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lu";
}
function $747425b437e121da$export$de8b4ee23b2cf823(codePoint) {
    return $747425b437e121da$export$410364bbb673ddbc(codePoint) === "Lt";
}
function $747425b437e121da$export$3c52dd84024ae72c(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Zs" || category === "Zl" || category === "Zp";
}
function $747425b437e121da$export$a11bdcffe109e74b(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Nd" || category === "No" || category === "Nl" || category === "Lu" || category === "Ll" || category === "Lt" || category === "Lm" || category === "Lo" || category === "Me" || category === "Mc";
}
function $747425b437e121da$export$e33ad6871e762338(codePoint) {
    const category = $747425b437e121da$export$410364bbb673ddbc(codePoint);
    return category === "Mn" || category === "Me" || category === "Mc";
}
var // Backwards compatibility.
$747425b437e121da$export$2e2bcd8739ae039 = {
    getCategory: $747425b437e121da$export$410364bbb673ddbc,
    getCombiningClass: $747425b437e121da$export$c03b919c6651ed55,
    getScript: $747425b437e121da$export$941569448d136665,
    getEastAsianWidth: $747425b437e121da$export$92f6187db8ca6d26,
    getNumericValue: $747425b437e121da$export$7d1258ebb7625a0d,
    isAlphabetic: $747425b437e121da$export$52c8ea63abd07594,
    isDigit: $747425b437e121da$export$727d9dbc4fbb948f,
    isPunctuation: $747425b437e121da$export$a5b49f4dc6a07d2c,
    isLowerCase: $747425b437e121da$export$7b6804e8df61fcf5,
    isUpperCase: $747425b437e121da$export$aebd617640818cda,
    isTitleCase: $747425b437e121da$export$de8b4ee23b2cf823,
    isWhiteSpace: $747425b437e121da$export$3c52dd84024ae72c,
    isBaseForm: $747425b437e121da$export$a11bdcffe109e74b,
    isMark: $747425b437e121da$export$e33ad6871e762338
};

const errorMessages = {
    InternalError: "Internal error: ${message}",
    // Misc
    MiscJSONParseError: "Syntax error in ${description} JSON ${address}: ${message}",
    MiscReadError: "Cannot read from file or URL ${fileOrURL}: ${message}",
    MiscUnicodeHighSurrogateWithoutLowSurrogate: "Malformed unicode: High surrogate not followed by low surrogate",
    MiscInvalidMinMaxConstraint: "Invalid min-max constraint: ${min}-${max}",
    // Inference
    InferenceJSONReferenceNotRooted: "JSON reference doesn't start with '#/': ${reference}",
    InferenceJSONReferenceToUnion: "JSON reference points to a union type: ${reference}",
    InferenceJSONReferenceWrongProperty: "JSON reference points to a non-existant property: ${reference}",
    InferenceJSONReferenceInvalidArrayIndex: "JSON reference uses invalid array index: ${reference}",
    // JSON Schema input
    SchemaArrayIsInvalidSchema: "An array is not a valid JSON Schema at ${ref}",
    SchemaNullIsInvalidSchema: "null is not a valid JSON Schema at ${ref}",
    SchemaRefMustBeString: "$ref must be a string, but is an ${actual} at ${ref}",
    SchemaAdditionalTypesForbidRequired: "Can't have non-specified required properties but forbidden additionalTypes at ${ref}",
    SchemaNoTypeSpecified: "JSON Schema must specify at least one type at ${ref}",
    SchemaInvalidType: "Invalid type ${type} in JSON Schema at ${ref}",
    SchemaFalseNotSupported: 'Schema "false" is not supported at ${ref}',
    SchemaInvalidJSONSchemaType: "Value of type ${type} is not valid JSON Schema at ${ref}",
    SchemaRequiredMustBeStringOrStringArray: "`required` must be string or array of strings, but is ${actual} at ${ref}",
    SchemaRequiredElementMustBeString: "`required` must contain only strings, but it has ${element}, at ${ref}",
    SchemaTypeMustBeStringOrStringArray: "`type` must be string or array of strings, but is ${actual}",
    SchemaTypeElementMustBeString: "`type` must contain only strings, but it has ${element}",
    SchemaArrayItemsMustBeStringOrArray: "Array items must be an array or an object, but is ${actual}",
    SchemaIDMustHaveAddress: "$id ${id} doesn't have an address at ${ref}",
    SchemaWrongAccessorEntryArrayLength: "Accessor entry array must have the same number of entries as the ${operation} at ${ref}",
    SchemaSetOperationCasesIsNotArray: "${operation} cases must be an array, but is ${cases}, at ${ref}",
    SchemaMoreThanOneUnionMemberName: "More than one name given for union member: ${names}",
    SchemaCannotGetTypesFromBoolean: "Schema value to get top-level types from must be an object, but is boolean, at ${ref}",
    SchemaCannotIndexArrayWithNonNumber: "Trying to index array in schema with key that is not a number, but is ${actual} at ${ref}",
    SchemaIndexNotInArray: "Index ${index} out of range of schema array at ${ref}",
    SchemaKeyNotInObject: "Key ${key} not in schema object at ${ref}",
    SchemaFetchError: "Could not fetch schema ${address}, referred to from ${base}",
    SchemaFetchErrorTopLevel: "Could not fetch top-level schema ${address}",
    SchemaFetchErrorAdditional: "Could not fetch additional schema ${address}",
    // GraphQL input
    GraphQLNoQueriesDefined: "GraphQL file doesn't have any queries defined.",
    // Driver
    DriverUnknownSourceLanguage: "Unknown source language ${lang}",
    DriverUnknownOutputLanguage: "Unknown output language ${lang}",
    DriverMoreThanOneInputGiven: "More than one input given for top-level ${topLevel}",
    DriverCannotInferNameForSchema: "Cannot infer name for schema ${uri}",
    DriverNoGraphQLQueryGiven: "Please specify at least one GraphQL query as input",
    DriverNoGraphQLSchemaInDir: "No GraphQL schema in ${dir}",
    DriverMoreThanOneGraphQLSchemaInDir: "More than one GraphQL schema in ${dir}",
    DriverSourceLangMustBeGraphQL: "If a GraphQL schema is specified, the source language must be GraphQL",
    DriverGraphQLSchemaNeeded: "Please specify a GraphQL schema with --graphql-schema or --graphql-introspect",
    DriverInputFileDoesNotExist: "Input file ${filename} does not exist",
    DriverCannotMixJSONWithOtherSamples: "Cannot mix JSON samples with JSON Schems, GraphQL, or TypeScript in input subdirectory ${dir}",
    DriverCannotMixNonJSONInputs: "Cannot mix JSON Schema, GraphQL, and TypeScript in an input subdirectory ${dir}",
    DriverUnknownDebugOption: "Unknown debug option ${option}",
    DriverNoLanguageOrExtension: "Please specify a language (--lang) or an output file extension",
    DriverCLIOptionParsingFailed: "Option parsing failed: ${message}",
    // IR
    IRNoForwardDeclarableTypeInCycle: "Cannot resolve cycle because it doesn't contain types that can be forward declared",
    IRTypeAttributesNotPropagated: "Type attributes for ${count} types were not carried over to the new graph: ${indexes}",
    IRNoEmptyUnions: "Trying to make an empty union - do you have an impossible type in your schema?",
    // Rendering
    RendererUnknownOptionValue: "Unknown value ${value} for option ${name}",
    // TypeScript input
    TypeScriptCompilerError: "TypeScript error: ${message}"
};
class QuickTypeError extends Error {
    constructor(errorMessage, messageName, userMessage, properties) {
        super(userMessage);
        this.errorMessage = errorMessage;
        this.messageName = messageName;
        this.userMessage = userMessage;
        this.properties = properties;
    }
}
function messageError(kind, properties) {
    const message = errorMessages[kind];
    let userMessage = message;
    const propertiesMap = properties;
    for (const name of Object.getOwnPropertyNames(propertiesMap)) {
        let value = propertiesMap[name];
        if (typeof value === "object" && typeof value.toString === "function") {
            value = value.toString();
        }
        else if (typeof value.message === "string") {
            value = value.message;
        }
        else if (typeof value !== "string") {
            value = JSON.stringify(value);
        }
        userMessage = userMessage.replace("${" + name + "}", value);
    }
    throw new QuickTypeError(message, kind, userMessage, propertiesMap);
}
function messageAssert(assertion, kind, properties) {
    if (assertion)
        return;
    return messageError(kind, properties);
}

/**
 *  base64.ts
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 *
 * @author Dan Kogai (https://github.com/dankogai)
 */
const version = '3.7.7';
/**
 * @deprecated use lowercase `version`.
 */
const VERSION = version;
const _hasBuffer = typeof Buffer === 'function';
const _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
const _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a) => {
    let tab = {};
    a.forEach((c, i) => tab[c] = i);
    return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === 'function'
    ? Uint8Array.from.bind(Uint8Array)
    : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src
    .replace(/=/g, '').replace(/[+\/]/g, (m0) => m0 == '+' ? '-' : '_');
const _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, '');
/**
 * polyfill version of `btoa`
 */
const btoaPolyfill = (bin) => {
    // console.log('polyfilled');
    let u32, c0, c1, c2, asc = '';
    const pad = bin.length % 3;
    for (let i = 0; i < bin.length;) {
        if ((c0 = bin.charCodeAt(i++)) > 255 ||
            (c1 = bin.charCodeAt(i++)) > 255 ||
            (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError('invalid character found');
        u32 = (c0 << 16) | (c1 << 8) | c2;
        asc += b64chs[u32 >> 18 & 63]
            + b64chs[u32 >> 12 & 63]
            + b64chs[u32 >> 6 & 63]
            + b64chs[u32 & 63];
    }
    return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
/**
 * does what `window.btoa` of web browsers do.
 * @param {String} bin binary string
 * @returns {string} Base64-encoded string
 */
const _btoa = typeof btoa === 'function' ? (bin) => btoa(bin)
    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')
        : btoaPolyfill;
const _fromUint8Array = _hasBuffer
    ? (u8a) => Buffer.from(u8a).toString('base64')
    : (u8a) => {
        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
        const maxargs = 0x1000;
        let strs = [];
        for (let i = 0, l = u8a.length; i < l; i += maxargs) {
            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(''));
    };
/**
 * converts a Uint8Array to a Base64 string.
 * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
 * @returns {string} Base64 string
 */
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const utob = (src: string) => unescape(encodeURIComponent(src));
// reverting good old fationed regexp
const cb_utob = (c) => {
    if (c.length < 2) {
        var cc = c.charCodeAt(0);
        return cc < 0x80 ? c
            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                + _fromCC(0x80 | (cc & 0x3f)))
                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                    + _fromCC(0x80 | (cc & 0x3f)));
    }
    else {
        var cc = 0x10000
            + (c.charCodeAt(0) - 0xD800) * 0x400
            + (c.charCodeAt(1) - 0xDC00);
        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
            + _fromCC(0x80 | (cc & 0x3f)));
    }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-8 string
 * @returns {string} UTF-16 string
 */
const utob = (u) => u.replace(re_utob, cb_utob);
//
const _encode = _hasBuffer
    ? (s) => Buffer.from(s, 'utf8').toString('base64')
    : _TE
        ? (s) => _fromUint8Array(_TE.encode(s))
        : (s) => _btoa(utob(s));
/**
 * converts a UTF-8-encoded string to a Base64 string.
 * @param {boolean} [urlsafe] if `true` make the result URL-safe
 * @returns {string} Base64 string
 */
const encode = (src, urlsafe = false) => urlsafe
    ? _mkUriSafe(_encode(src))
    : _encode(src);
/**
 * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
 * @returns {string} Base64 string
 */
const encodeURI = (src) => encode(src, true);
// This trick is found broken https://github.com/dankogai/js-base64/issues/130
// const btou = (src: string) => decodeURIComponent(escape(src));
// reverting good old fationed regexp
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
    switch (cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                | ((0x3f & cccc.charCodeAt(1)) << 12)
                | ((0x3f & cccc.charCodeAt(2)) << 6)
                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
            return (_fromCC((offset >>> 10) + 0xD800)
                + _fromCC((offset & 0x3FF) + 0xDC00));
        case 3:
            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                | ((0x3f & cccc.charCodeAt(1)) << 6)
                | (0x3f & cccc.charCodeAt(2)));
        default:
            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                | (0x3f & cccc.charCodeAt(1)));
    }
};
/**
 * @deprecated should have been internal use only.
 * @param {string} src UTF-16 string
 * @returns {string} UTF-8 string
 */
const btou = (b) => b.replace(re_btou, cb_btou);
/**
 * polyfill version of `atob`
 */
const atobPolyfill = (asc) => {
    // console.log('polyfilled');
    asc = asc.replace(/\s+/g, '');
    if (!b64re.test(asc))
        throw new TypeError('malformed base64.');
    asc += '=='.slice(2 - (asc.length & 3));
    let u24, bin = '', r1, r2;
    for (let i = 0; i < asc.length;) {
        u24 = b64tab[asc.charAt(i++)] << 18
            | b64tab[asc.charAt(i++)] << 12
            | (r1 = b64tab[asc.charAt(i++)]) << 6
            | (r2 = b64tab[asc.charAt(i++)]);
        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
    }
    return bin;
};
/**
 * does what `window.atob` of web browsers do.
 * @param {String} asc Base64-encoded string
 * @returns {string} binary string
 */
const _atob = typeof atob === 'function' ? (asc) => atob(_tidyB64(asc))
    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')
        : atobPolyfill;
//
const _toUint8Array = _hasBuffer
    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))
    : (a) => _U8Afrom(_atob(a).split('').map(c => c.charCodeAt(0)));
/**
 * converts a Base64 string to a Uint8Array.
 */
const toUint8Array = (a) => _toUint8Array(_unURI(a));
//
const _decode = _hasBuffer
    ? (a) => Buffer.from(a, 'base64').toString('utf8')
    : _TD
        ? (a) => _TD.decode(_toUint8Array(a))
        : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));
/**
 * converts a Base64 string to a UTF-8 string.
 * @param {String} src Base64 string.  Both normal and URL-safe are supported
 * @returns {string} UTF-8 string
 */
const decode = (src) => _decode(_unURI(src));
/**
 * check if a value is a valid Base64 string
 * @param {String} src a value to check
  */
const isValid = (src) => {
    if (typeof src !== 'string')
        return false;
    const s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
    return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
//
const _noEnum = (v) => {
    return {
        value: v, enumerable: false, writable: true, configurable: true
    };
};
/**
 * extend String.prototype with relevant methods
 */
const extendString = function () {
    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
    _add('fromBase64', function () { return decode(this); });
    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
    _add('toBase64URI', function () { return encode(this, true); });
    _add('toBase64URL', function () { return encode(this, true); });
    _add('toUint8Array', function () { return toUint8Array(this); });
};
/**
 * extend Uint8Array.prototype with relevant methods
 */
const extendUint8Array = function () {
    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
    _add('toBase64URI', function () { return fromUint8Array(this, true); });
    _add('toBase64URL', function () { return fromUint8Array(this, true); });
};
/**
 * extend Builtin prototypes with relevant methods
 */
const extendBuiltins = () => {
    extendString();
    extendUint8Array();
};
const gBase64 = {
    version: version,
    VERSION: VERSION,
    atob: _atob,
    atobPolyfill: atobPolyfill,
    btoa: _btoa,
    btoaPolyfill: btoaPolyfill,
    fromBase64: decode,
    toBase64: encode,
    encode: encode,
    encodeURI: encodeURI,
    encodeURL: encodeURI,
    utob: utob,
    btou: btou,
    decode: decode,
    isValid: isValid,
    fromUint8Array: fromUint8Array,
    toUint8Array: toUint8Array,
    extendString: extendString,
    extendUint8Array: extendUint8Array,
    extendBuiltins: extendBuiltins
};

const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR$1 = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode$1(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR$1:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (isNode$1(ctrl) || isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (isMap(node))
        return visitor.Map?.(key, node, path);
    if (isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (isPair(node))
        return visitor.Pair?.(key, node, path);
    if (isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
            const tags = {};
            visit(doc.contents, (_key, node) => {
                if (isNode$1(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (isScalar(ref.node) || isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

class Alias extends NodeBase {
    constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends NodeBase {
    constructor(value) {
        super(SCALAR$1);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (isDocument(value))
        value = value.contents;
    if (isNode$1(value))
        return value;
    if (isPair(value)) {
        const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[MAP]
                : Symbol.iterator in Object(value)
                    ? schema[SEQ]
                    : schema[MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => isNode$1(it) || isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && isScalar(node) ? node.value : node;
        else
            return isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
            ch = text[++i];
        }
        else {
            do {
                ch = text[++i];
            } while (ch && ch !== '\n');
            end = i;
            start = i + 1;
            ch = text[start];
        }
    }
    return end;
}

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.BLOCK_FOLDED:
            case Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify?.(obj));
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
    if (anchor && anchorIsValid(anchor)) {
        anchors.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = isNode$1(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : isScalar(node)
            ? stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (isNode$1(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (isCollection(key)) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            isCollection(key) ||
            (isScalar(key)
                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (isNode$1(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        // https://github.com/typescript-eslint/typescript-eslint/issues/7478
        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = isAlias(value) ? value.resolve(ctx.doc) : value;
        if (isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (isNode$1(key) && ctx?.doc) {
        const strCtx = createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

function createPair(key, value, ctx) {
    const k = createNode(key, undefined, ctx);
    const v = createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (isNode$1(key))
            key = key.clone(schema);
        if (isNode$1(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode$1(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode$1(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (isNode$1(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (isPair(item)) {
            const ik = isNode$1(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = isNode$1(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
        return start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            return `${str}\n${indent}${end}`;
        }
        else {
            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

function findPair(items, key) {
    const k = isScalar(key) ? key.value : key;
    for (const it of items) {
        if (isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair(pair, pair?.value);
        }
        else
            _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (isScalar(prev.value) && isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.from(schema, obj, ctx)
};

class YAMLSeq extends Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar(prev) && isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.from(schema, obj, ctx)
};

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
    }
};

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

const floatNaN$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float$1 = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify$2 = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve$1 = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify$1(node, radix, prefix) {
    const { value } = node;
    if (intIdentify$2(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber(node);
}
const intOct$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
    stringify: node => intStringify$1(node, 8, '0o')
};
const int$1 = {
    identify: intIdentify$2,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex$1 = {
    identify: value => intIdentify$2(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
    stringify: node => intStringify$1(node, 16, '0x')
};

const schema$2 = [
    map,
    seq,
    string,
    nullTag,
    boolTag,
    intOct$1,
    int$1,
    intHex$1,
    floatNaN$1,
    floatExp$1,
    float$1
];

function intIdentify$1(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify$1,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema$1 = [map, seq].concat(jsonScalars, jsonError);

const binary = {
    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

function resolvePairs(seq, onError) {
    if (isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (isPair(item))
                continue;
            else if (isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair(new Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = isPair(item) ? item : new Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

class YAMLOMap extends YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (isPair(pair)) {
                key = toJS(pair.key, '', ctx);
                value = toJS(pair.value, key, ctx);
            }
            else {
                key = toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs = createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs = resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs.items) {
            if (isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar(false),
    stringify: boolStringify
};

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber
};

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

class YAMLSet extends YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair(key.key, null);
        else
            pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair)
            ? isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

const schema = [
    map,
    seq,
    string,
    nullTag,
    trueTag,
    falseTag,
    intBin,
    intOct,
    int,
    intHex,
    floatNaN,
    floatExp,
    float,
    binary,
    omap,
    pairs,
    set,
    intTime,
    floatTime,
    timestamp
];

const schemas = new Map([
    ['core', schema$2],
    ['failsafe', [map, seq, string]],
    ['json', schema$1],
    ['yaml11', schema],
    ['yaml-1.1', schema]
]);
const tagsByName = {
    binary,
    bool: boolTag,
    float: float$1,
    floatExp: floatExp$1,
    floatNaN: floatNaN$1,
    floatTime,
    int: int$1,
    intHex: intHex$1,
    intOct: intOct$1,
    intTime,
    map,
    null: nullTag,
    omap,
    pairs,
    seq,
    set,
    timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary,
    'tag:yaml.org,2002:omap': omap,
    'tag:yaml.org,2002:pairs': pairs,
    'tag:yaml.org,2002:set': set,
    'tag:yaml.org,2002:timestamp': timestamp
};
function getTags(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? getTags(compat, 'compat')
            : compat
                ? getTags(null, compat)
                : null;
        this.merge = !!merge;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map });
        Object.defineProperty(this, SCALAR$1, { value: string });
        Object.defineProperty(this, SEQ, { value: seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (isNode$1(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = isNode$1(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (isEmptyPath(path))
            return !keepScalar && isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (isEmptyPath(path))
            return this.contents !== undefined;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new Directives({ version: '1.1' });
                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new Directives({ version });
                opt = { merge: false, resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '…';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    atNewline &&
                    indicator !== 'doc-start' &&
                    token.source[0] === '\t')
                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== ''))
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
    };
}

function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (isScalar(a) &&
                isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bm.indent, key, onError);
        if (mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap : YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, tagToken, onError) {
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.tagName && expType === 'seq') ||
        !expType) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt?.collection) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = isNode$1(res)
        ? res
        : new Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0', // null character
    a: '\x07', // bell character
    b: '\b', // backspace
    e: '\x1b', // escape character
    f: '\f', // form feed
    n: '\n', // line feed
    r: '\r', // carriage return
    t: '\t', // horizontal tab
    v: '\v', // vertical tab
    N: '\u0085', // Unicode next line
    _: '\u00a0', // Unicode non-breaking space
    L: '\u2028', // Unicode line separator
    P: '\u2029', // Unicode paragraph separator
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar(token, ctx.options.strict, onError)
        : resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : token.type === 'scalar'
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[SCALAR$1];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = isScalar(res) ? res : new Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[SCALAR$1]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[SCALAR$1];
}
function findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[SCALAR$1];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[SCALAR$1];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode(ctx, value, props, onError)
        : composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new YAMLWarning(pos, code, message));
            else
                this.errors.push(new YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine &&
                this.indent === map.indent &&
                it.sep &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter = options.lineCounter || (prettyErrors && new LineCounter()) || null;
    return { lineCounter, prettyErrors };
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser = new Parser(lineCounter?.addNewLine);
    const composer = new Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(prettifyError(source, lineCounter));
        doc.warnings.forEach(prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}

function isStringMap(x, checkValue) {
    if (typeof x !== "object" || Array.isArray(x) || x === null) {
        return false;
    }
    if (checkValue !== undefined) {
        for (const k of Object.getOwnPropertyNames(x)) {
            const v = x[k];
            if (!checkValue(v)) {
                return false;
            }
        }
    }
    return true;
}
function checkString(x) {
    return typeof x === "string";
}
function checkStringMap(x, checkValue) {
    if (checkValue && isStringMap(x, checkValue)) {
        return x;
    }
    if (isStringMap(x)) {
        return x;
    }
    return panic(`Value must be an object, but is ${x}`);
}
function checkArray(x, checkItem) {
    if (!Array.isArray(x)) {
        return panic(`Value must be an array, but is ${x}`);
    }
    if (checkItem !== undefined) {
        for (const v of x) {
            if (!checkItem(v)) {
                return panic(`Array item does not satisfy constraint: ${v}`);
            }
        }
    }
    return x;
}
function defined(x) {
    if (x !== undefined)
        return x;
    return panic("Defined value expected, but got undefined");
}
function nonNull(x) {
    if (x !== null)
        return x;
    return panic("Non-null value expected, but got null");
}
function assertNever(x) {
    return messageError("InternalError", { message: `Unexpected object ${x}` });
}
function assert(condition, message = "Assertion failed") {
    if (!condition) {
        return messageError("InternalError", { message });
    }
}
function panic(message) {
    return messageError("InternalError", { message });
}
function mustNotHappen() {
    return panic("This must not happen");
}
function repeated(n, value) {
    const arr = [];
    for (let i = 0; i < n; i++) {
        arr.push(value);
    }
    return arr;
}
function repeatedCall(n, producer) {
    const arr = [];
    for (let i = 0; i < n; i++) {
        arr.push(producer());
    }
    return arr;
}
function errorMessage(e) {
    if (e instanceof Error) {
        return e.message;
    }
    return e.toString();
}
function inflateBase64(encoded) {
    const bytes = gBase64.atob(encoded);
    return pako__namespace.inflate(bytes, { to: "string" });
}
function parseJSON(text, description, address = "<unknown>") {
    try {
        // https://gist.github.com/pbakondy/f5045eff725193dad9c7
        if (text.charCodeAt(0) === 0xfeff) {
            text = text.slice(1);
        }
        return parse(text);
    }
    catch (e) {
        let message;
        if (e instanceof SyntaxError) {
            message = e.message;
        }
        else {
            message = `Unknown exception ${e}`;
        }
        return messageError("MiscJSONParseError", { description, address, message });
    }
}
function indentationString(level) {
    return "  ".repeat(level);
}
// FIXME: fix this enum iteration
function numberEnumValues(e) {
    const result = [];
    for (const k of Object.keys(e)) {
        const v = e[k];
        if (typeof v === "number") {
            result.push(v);
        }
    }
    return result;
}

// eslint-disable-next-line @typescript-eslint/no-redeclare
/**
 * The superclass for target language options.  You probably want to use one of its
 * subclasses, `BooleanOption`, `EnumOption`, or `StringOption`.
 */
class Option {
    constructor(definition) {
        definition.renderer = true;
        this.definition = definition;
        assert(definition.kind !== undefined, "Renderer option kind must be defined");
    }
    getValue(values) {
        const value = values[this.definition.name];
        if (value === undefined) {
            return this.definition.defaultValue;
        }
        return value;
    }
    get cliDefinitions() {
        return { actual: [this.definition], display: [this.definition] };
    }
}
function getOptionValues(options, untypedOptionValues) {
    const optionValues = {};
    for (const name of Object.getOwnPropertyNames(options)) {
        optionValues[name] = options[name].getValue(untypedOptionValues);
    }
    return optionValues;
}
/**
 * A target language option that allows setting a boolean flag.
 */
class BooleanOption extends Option {
    /**
     * @param name The shorthand name.
     * @param description Short-ish description of the option.
     * @param defaultValue The default value.
     * @param kind Whether it's a primary or secondary option.
     */
    constructor(name, description, defaultValue, kind = "primary") {
        super({
            name,
            kind,
            type: Boolean,
            description,
            defaultValue
        });
    }
    get cliDefinitions() {
        const negated = Object.assign({}, this.definition, {
            name: `no-${this.definition.name}`,
            defaultValue: !this.definition.defaultValue
        });
        const display = Object.assign({}, this.definition, {
            name: `[no-]${this.definition.name}`,
            description: `${this.definition.description} (${this.definition.defaultValue ? "on" : "off"} by default)`
        });
        return {
            display: [display],
            actual: [this.definition, negated]
        };
    }
    getValue(values) {
        let value = values[this.definition.name];
        if (value === undefined) {
            value = this.definition.defaultValue;
        }
        let negated = values[`no-${this.definition.name}`];
        if (negated === undefined) {
            negated = !this.definition.defaultValue;
        }
        if (value === "true") {
            value = true;
        }
        else if (value === "false") {
            value = false;
        }
        if (this.definition.defaultValue) {
            return value && !negated;
        }
        else {
            return value || !negated;
        }
    }
}
class StringOption extends Option {
    constructor(name, description, typeLabel, defaultValue, kind = "primary") {
        const definition = {
            name,
            kind,
            type: String,
            description,
            typeLabel,
            defaultValue
        };
        super(definition);
    }
}
class EnumOption extends Option {
    constructor(name, description, values, defaultValue = undefined, kind = "primary") {
        if (defaultValue === undefined) {
            defaultValue = values[0][0];
        }
        const definition = {
            name,
            kind,
            type: String,
            description,
            typeLabel: values.map(([n, _]) => n).join("|"),
            legalValues: values.map(([n, _]) => n),
            defaultValue
        };
        super(definition);
        this._values = {};
        for (const [n, v] of values) {
            this._values[n] = v;
        }
    }
    getValue(values) {
        let name = values[this.definition.name];
        if (name === undefined) {
            name = this.definition.defaultValue;
        }
        if (!collectionUtils.hasOwnProperty(this._values, name)) {
            return messageError("RendererUnknownOptionValue", { value: name, name: this.definition.name });
        }
        return this._values[name];
    }
}

const acronyms = [
    "aaa",
    "aabb",
    "aac",
    "aal",
    "aalc",
    "aarp",
    "abac",
    "abcl",
    "abi",
    "abm",
    "abr",
    "ac",
    "acd",
    "ack",
    "acl",
    "acm",
    "acme",
    "acp",
    "acpi",
    "acr",
    "adb",
    "adc",
    "adccp",
    "ado",
    "adsl",
    "adt",
    "ae",
    "aes",
    "af",
    "afp",
    "agp",
    "ai",
    "aix",
    "alac",
    "algol",
    "alsa",
    "alu",
    "amd",
    "amoled",
    "amqp",
    "amr",
    "ann",
    "ansi",
    "aop",
    "apci",
    "api",
    "apic",
    "apipa",
    "apl",
    "apr",
    "arin",
    "aros",
    "arp",
    "arpa",
    "arpanet",
    "ascii",
    "aset",
    "asg",
    "asic",
    "asimo",
    "aslr",
    "asm",
    "asmp",
    "asp",
    "asr",
    "assp",
    "ast",
    "ata",
    "atag",
    "atapi",
    "atm",
    "av",
    "avc",
    "avi",
    "awfl",
    "awk",
    "awt",
    "bal",
    "bam",
    "bbp",
    "bbs",
    "bcd",
    "bcnf",
    "beep",
    "ber",
    "bfd",
    "bfs",
    "bft",
    "bgp",
    "bi",
    "binac",
    "bios",
    "bjt",
    "bmp",
    "bnc",
    "boinc",
    "bom",
    "bootp",
    "bpdu",
    "bpel",
    "bpl",
    "bpm",
    "brm",
    "brms",
    "brr",
    "brs",
    "bsa",
    "bsb",
    "bsd",
    "bss",
    "bt",
    "bw",
    "byod",
    "ca",
    "cad",
    "cae",
    "cai",
    "caid",
    "captcha",
    "caq",
    "cd",
    "cde",
    "cdfs",
    "cdma",
    "cdn",
    "cdp",
    "cdsa",
    "cert",
    "ces",
    "cf",
    "cfd",
    "cfg",
    "cg",
    "cga",
    "cgi",
    "cgt",
    "chs",
    "cidr",
    "cifs",
    "cim",
    "cio",
    "cir",
    "cisc",
    "cjk",
    "cjkv",
    "cli",
    "clr",
    "cm",
    "cmdb",
    "cmmi",
    "cmo",
    "cmos",
    "cms",
    "cn",
    "cnc",
    "cng",
    "cnr",
    "cobol",
    "com",
    "corba",
    "cots",
    "cpa",
    "cpan",
    "cpri",
    "cps",
    "cpu",
    "cr",
    "cran",
    "crc",
    "crlf",
    "crm",
    "crs",
    "crt",
    "crud",
    "cs",
    "cse",
    "csi",
    "csm",
    "csp",
    "csrf",
    "css",
    "csv",
    "ct",
    "ctan",
    "ctcp",
    "ctfe",
    "cti",
    "ctl",
    "ctm",
    "cts",
    "ctss",
    "cua",
    "cvs",
    "dac",
    "dal",
    "dao",
    "dap",
    "darpa",
    "dat",
    "db",
    "dba",
    "dbcs",
    "dbms",
    "dcc",
    "dcca",
    "dccp",
    "dcl",
    "dcmi",
    "dcom",
    "dcs",
    "dd",
    "dde",
    "ddi",
    "ddl",
    "ddr",
    "dec",
    "des",
    "dfa",
    "dfd",
    "dfs",
    "dgd",
    "dhcp",
    "dhtml",
    "dif",
    "dimm",
    "din",
    "dip",
    "dism",
    "divx",
    "dkim",
    "dl",
    "dll",
    "dlna",
    "dlp",
    "dma",
    "dmca",
    "dmi",
    "dml",
    "dmr",
    "dmz",
    "dn",
    "dnd",
    "dns",
    "doa",
    "docsis",
    "dom",
    "dos",
    "dp",
    "dpc",
    "dpi",
    "dpmi",
    "dpms",
    "dr",
    "dram",
    "dri",
    "drm",
    "dsa",
    "dsdl",
    "dsdm",
    "dsl",
    "dslam",
    "dsn",
    "dsp",
    "dsssl",
    "dtd",
    "dte",
    "dtp",
    "dtr",
    "dvd",
    "dvi",
    "dvr",
    "dw",
    "eai",
    "eap",
    "eas",
    "ebcdic",
    "ebml",
    "ecc",
    "ecma",
    "ecn",
    "ecos",
    "ecrs",
    "eda",
    "edi",
    "edo",
    "edsac",
    "edvac",
    "eeprom",
    "eff",
    "efi",
    "efm",
    "efs",
    "ega",
    "egp",
    "eide",
    "eigrp",
    "eisa",
    "elf",
    "emacs",
    "ems",
    "eniac",
    "eod",
    "eof",
    "eol",
    "eom",
    "eos",
    "eprom",
    "erd",
    "erm",
    "erp",
    "esb",
    "escon",
    "esd",
    "esr",
    "etl",
    "etw",
    "euc",
    "eula",
    "ewmh",
    "ext",
    "fap",
    "faq",
    "fasm",
    "fbdimm",
    "fcb",
    "fcs",
    "fdc",
    "fdd",
    "fddi",
    "fdm",
    "fdma",
    "fds",
    "fec",
    "femb",
    "fet",
    "fhs",
    "ficon",
    "fifo",
    "fips",
    "fl",
    "flac",
    "flops",
    "fmc",
    "fmo",
    "foldoc",
    "fosdem",
    "fosi",
    "foss",
    "fp",
    "fpga",
    "fps",
    "fpu",
    "fqdn",
    "fru",
    "fs",
    "fsb",
    "fsf",
    "fsm",
    "ftp",
    "ftta",
    "fttc",
    "ftth",
    "fttp",
    "fud",
    "fvek",
    "fws",
    "fxp",
    "fyi",
    "gb",
    "gcc",
    "gcj",
    "gcr",
    "gdb",
    "gdi",
    "geran",
    "gfdl",
    "gif",
    "gigo",
    "gimps",
    "gis",
    "gml",
    "gnu",
    "goms",
    "gpasm",
    "gpfs",
    "gpg",
    "gpgpu",
    "gpib",
    "gpl",
    "gprs",
    "gpt",
    "gpu",
    "gsm",
    "gui",
    "guid",
    "gwt",
    "gyr",
    "hal",
    "hasp",
    "hba",
    "hci",
    "hcl",
    "hd",
    "hdd",
    "hdl",
    "hdmi",
    "hf",
    "hfs",
    "hhd",
    "hid",
    "hig",
    "hird",
    "hlasm",
    "hls",
    "hma",
    "hp",
    "hpc",
    "hpfs",
    "hsdpa",
    "hsm",
    "ht",
    "htc",
    "htm",
    "html",
    "http",
    "https",
    "htx",
    "hurd",
    "hvd",
    "iana",
    "ibm",
    "ic",
    "icann",
    "ich",
    "icmp",
    "icp",
    "ics",
    "ict",
    "id",
    "ide",
    "idf",
    "idl",
    "ids",
    "iec",
    "ieee",
    "ietf",
    "ifl",
    "igmp",
    "igrp",
    "ihv",
    "iiop",
    "iis",
    "ike",
    "il",
    "im",
    "imap",
    "ime",
    "infosec",
    "ip",
    "ipam",
    "ipc",
    "ipl",
    "ipmi",
    "ipo",
    "ipp",
    "ips",
    "iptv",
    "ipx",
    "ir",
    "irc",
    "iri",
    "irp",
    "irq",
    "isa",
    "isam",
    "isatap",
    "isc",
    "isdn",
    "iso",
    "isp",
    "ispf",
    "isr",
    "isv",
    "itil",
    "itl",
    "itu",
    "ivcr",
    "ivrs",
    "jaxb",
    "jaxp",
    "jbod",
    "jce",
    "jcl",
    "jcp",
    "jdbc",
    "jdk",
    "jds",
    "jee",
    "jes",
    "jfc",
    "jfet",
    "jfs",
    "jini",
    "jit",
    "jme",
    "jms",
    "jmx",
    "jndi",
    "jni",
    "jnz",
    "jpeg",
    "jre",
    "js",
    "jse",
    "json",
    "jsp",
    "jtag",
    "jvm",
    "kb",
    "kde",
    "km",
    "krl",
    "kvm",
    "lacp",
    "lan",
    "lb",
    "lba",
    "lcd",
    "lcos",
    "lcr",
    "ldap",
    "le",
    "led",
    "lf",
    "lfs",
    "lga",
    "lgpl",
    "lib",
    "lif",
    "lifo",
    "lilo",
    "lisp",
    "lkml",
    "lm",
    "loc",
    "lpc",
    "lpi",
    "lpt",
    "lru",
    "lsb",
    "lsi",
    "lte",
    "ltl",
    "ltr",
    "lun",
    "lv",
    "lvd",
    "lvm",
    "lzw",
    "mac",
    "manet",
    "mapi",
    "mb",
    "mbcs",
    "mbd",
    "mbr",
    "mca",
    "mcad",
    "mcas",
    "mcdba",
    "mcdst",
    "mcitp",
    "mcm",
    "mcp",
    "mcpc",
    "mcpd",
    "mcsa",
    "mcsd",
    "mcse",
    "mct",
    "mcts",
    "mda",
    "mdf",
    "mdi",
    "mf",
    "mfc",
    "mfm",
    "mgcp",
    "mib",
    "micr",
    "midi",
    "mimd",
    "mime",
    "mimo",
    "minix",
    "mips",
    "mis",
    "misd",
    "mit",
    "mmc",
    "mmds",
    "mmf",
    "mmi",
    "mmio",
    "mmorpg",
    "mmu",
    "mmx",
    "mng",
    "mom",
    "mos",
    "mosfet",
    "motd",
    "mous",
    "mov",
    "mpaa",
    "mpeg",
    "mpl",
    "mpls",
    "mpu",
    "ms",
    "msa",
    "msb",
    "msdn",
    "msi",
    "msn",
    "mt",
    "mta",
    "mtbf",
    "mtu",
    "mua",
    "mvc",
    "mvp",
    "mvs",
    "mwc",
    "mx",
    "mxf",
    "nack",
    "nak",
    "nas",
    "nasm",
    "ncp",
    "ncq",
    "ncsa",
    "ndis",
    "ndps",
    "nds",
    "nep",
    "nfa",
    "nfc",
    "nfs",
    "ngl",
    "ngscb",
    "ni",
    "nic",
    "nim",
    "nio",
    "nist",
    "nlp",
    "nls",
    "nmi",
    "nntp",
    "noc",
    "nop",
    "nos",
    "np",
    "npl",
    "nptl",
    "npu",
    "ns",
    "nsa",
    "nsi",
    "nspr",
    "nss",
    "nt",
    "ntfs",
    "ntlm",
    "ntp",
    "numa",
    "nurbs",
    "nvr",
    "nvram",
    "oat",
    "obsai",
    "odbc",
    "oem",
    "oes",
    "ofdm",
    "oftc",
    "oid",
    "olap",
    "ole",
    "oled",
    "olpc",
    "oltp",
    "omf",
    "omg",
    "omr",
    "oo",
    "ooe",
    "oom",
    "oop",
    "ootb",
    "opml",
    "orb",
    "orm",
    "os",
    "oscon",
    "osdn",
    "osi",
    "ospf",
    "oss",
    "ostg",
    "oui",
    "pap",
    "parc",
    "pata",
    "pbs",
    "pc",
    "pcb",
    "pci",
    "pcl",
    "pcm",
    "pcmcia",
    "pcre",
    "pd",
    "pda",
    "pdf",
    "pdh",
    "pdp",
    "pe",
    "perl",
    "pfa",
    "pg",
    "pga",
    "pgo",
    "pgp",
    "php",
    "pid",
    "pim",
    "pio",
    "pkcs",
    "pki",
    "plc",
    "pld",
    "plt",
    "pmm",
    "png",
    "pnrp",
    "poid",
    "pojo",
    "posix",
    "ppc",
    "ppi",
    "ppp",
    "pptp",
    "pr",
    "ps",
    "psa",
    "psm",
    "psu",
    "psvi",
    "pv",
    "pvg",
    "pvr",
    "pxe",
    "pxi",
    "qa",
    "qdr",
    "qfp",
    "qotd",
    "qsop",
    "qtam",
    "racf",
    "rad",
    "raid",
    "raii",
    "rait",
    "ram",
    "rarp",
    "ras",
    "rc",
    "rcs",
    "rd",
    "rdbms",
    "rdc",
    "rdf",
    "rdm",
    "rdos",
    "rdp",
    "rds",
    "refal",
    "rest",
    "rf",
    "rfc",
    "rfi",
    "rfid",
    "rgb",
    "rgba",
    "rhel",
    "rhl",
    "ria",
    "riaa",
    "rip",
    "rir",
    "risc",
    "rje",
    "rle",
    "rll",
    "rmi",
    "rms",
    "rom",
    "romb",
    "rpc",
    "rpg",
    "rpm",
    "rras",
    "rsa",
    "rsi",
    "rss",
    "rtai",
    "rtc",
    "rte",
    "rtems",
    "rtl",
    "rtos",
    "rtp",
    "rts",
    "rtsp",
    "rtti",
    "rwd",
    "san",
    "sas",
    "sata",
    "sax",
    "sbod",
    "sbu",
    "scada",
    "scid",
    "scm",
    "scp",
    "scpc",
    "scpi",
    "scsa",
    "scsi",
    "sctp",
    "sd",
    "sddl",
    "sdh",
    "sdi",
    "sdio",
    "sdk",
    "sdl",
    "sdn",
    "sdp",
    "sdr",
    "sdram",
    "sdsl",
    "se",
    "sec",
    "sei",
    "seo",
    "sftp",
    "sgi",
    "sgml",
    "sgr",
    "sha",
    "shdsl",
    "sigcat",
    "siggraph",
    "simd",
    "simm",
    "sip",
    "sisd",
    "siso",
    "sles",
    "sli",
    "slm",
    "sloc",
    "sma",
    "smb",
    "smbios",
    "sme",
    "smf",
    "smil",
    "smp",
    "smps",
    "sms",
    "smt",
    "smtp",
    "sna",
    "snmp",
    "sntp",
    "soa",
    "soe",
    "soho",
    "soi",
    "sopa",
    "sp",
    "spa",
    "sparc",
    "spf",
    "spi",
    "spm",
    "spmd",
    "sql",
    "sram",
    "ssa",
    "ssd",
    "ssdp",
    "sse",
    "ssh",
    "ssi",
    "ssid",
    "ssl",
    "ssp",
    "ssse",
    "sssp",
    "sstp",
    "sus",
    "suse",
    "svc",
    "svd",
    "svg",
    "svga",
    "swf",
    "swt",
    "tao",
    "tapi",
    "tasm",
    "tb",
    "tcp",
    "tcu",
    "tdma",
    "tft",
    "tftp",
    "ti",
    "tla",
    "tld",
    "tls",
    "tlv",
    "tnc",
    "tpf",
    "tpm",
    "troff",
    "tron",
    "trsdos",
    "tso",
    "tsp",
    "tsr",
    "tta",
    "ttf",
    "ttl",
    "tts",
    "tty",
    "tucows",
    "twain",
    "uaag",
    "uac",
    "uart",
    "uat",
    "ucs",
    "uddi",
    "udma",
    "udp",
    "uefi",
    "uhf",
    "ui",
    "ul",
    "ula",
    "uma",
    "umb",
    "uml",
    "umpc",
    "umts",
    "unc",
    "univac",
    "ups",
    "uri",
    "url",
    "usb",
    "usr",
    "utc",
    "utf",
    "utp",
    "utran",
    "uucp",
    "uuid",
    "uun",
    "uvc",
    "uwp",
    "ux",
    "vax",
    "vb",
    "vba",
    "vbs",
    "vcpi",
    "vdm",
    "vdsl",
    "vesa",
    "vfat",
    "vfs",
    "vg",
    "vga",
    "vhf",
    "vlan",
    "vlb",
    "vlf",
    "vliw",
    "vlsi",
    "vlsm",
    "vm",
    "vmm",
    "vnc",
    "vod",
    "vpn",
    "vpu",
    "vr",
    "vram",
    "vrml",
    "vsam",
    "vsat",
    "vt",
    "vtam",
    "vtl",
    "wafs",
    "wai",
    "wais",
    "wan",
    "wap",
    "wasm",
    "wbem",
    "wcag",
    "wcf",
    "wdm",
    "wep",
    "wfi",
    "wins",
    "wlan",
    "wma",
    "wmi",
    "wmv",
    "wns",
    "wol",
    "wor",
    "wora",
    "wpa",
    "wpad",
    "wpan",
    "wpf",
    "wsdl",
    "wsfl",
    "wusb",
    "wwan",
    "wwdc",
    "wwid",
    "wwn",
    "www",
    "wysiwyg",
    "wzc",
    "xag",
    "xaml",
    "xcbl",
    "xdm",
    "xdmcp",
    "xhtml",
    "xilp",
    "xml",
    "xmms",
    "xmpp",
    "xms",
    "xns",
    "xp",
    "xpcom",
    "xpi",
    "xpidl",
    "xps",
    "xsd",
    "xsl",
    "xslt",
    "xss",
    "xtf",
    "xul",
    "xvga",
    "yaaf",
    "yacc",
    "yaml",
    "zcav",
    "zcs",
    "zif",
    "zifs",
    "zisc",
    "zma",
    "zoi",
    "zope",
    "zpl"
];
var AcronymStyleOptions;
(function (AcronymStyleOptions) {
    AcronymStyleOptions["Camel"] = "camel";
    AcronymStyleOptions["Lower"] = "lowerCase";
    AcronymStyleOptions["Original"] = "original";
    AcronymStyleOptions["Pascal"] = "pascal";
})(AcronymStyleOptions || (AcronymStyleOptions = {}));
const acronymOption = function (defaultOption) {
    return new EnumOption("acronym-style", "Acronym naming style", [
        [AcronymStyleOptions.Original, AcronymStyleOptions.Original],
        [AcronymStyleOptions.Pascal, AcronymStyleOptions.Pascal],
        [AcronymStyleOptions.Camel, AcronymStyleOptions.Camel],
        [AcronymStyleOptions.Lower, AcronymStyleOptions.Lower]
    ], defaultOption, "secondary");
};
function acronymStyle(style) {
    const options = {
        [AcronymStyleOptions.Pascal]: allUpperWordStyle,
        [AcronymStyleOptions.Camel]: firstUpperWordStyle,
        [AcronymStyleOptions.Original]: originalWord,
        [AcronymStyleOptions.Lower]: allLowerWordStyle
    };
    return options[style];
}

function computeAsciiMap(mapper) {
    const charStringMap = [];
    const charNoEscapeMap = [];
    for (let i = 0; i < 128; i++) {
        let noEscape = 0;
        const result = mapper(i);
        if (result === String.fromCharCode(i)) {
            noEscape = 1;
        }
        charStringMap.push(result);
        charNoEscapeMap.push(noEscape);
    }
    return { charStringMap, charNoEscapeMap };
}
function precomputedCodePointPredicate(p) {
    const asciiResults = [];
    for (let cp = 0; cp < 128; cp++) {
        asciiResults.push(p(cp));
    }
    return function (cp) {
        return cp < 128 ? asciiResults[cp] : p(cp);
    };
}
// FIXME: This is a copy of code in src/Data/String/Util.js
function utf16ConcatMap(mapper) {
    const { charStringMap, charNoEscapeMap } = computeAsciiMap(mapper);
    // eslint-disable-next-line @typescript-eslint/naming-convention
    return function stringConcatMap_inner(s) {
        let cs = null;
        let start = 0;
        let i = 0;
        while (i < s.length) {
            const cc = s.charCodeAt(i);
            if (charNoEscapeMap[cc] !== 1) {
                if (cs === null)
                    cs = [];
                cs.push(s.substring(start, i));
                const str = charStringMap[cc];
                if (str === undefined) {
                    cs.push(mapper(s.charCodeAt(i)));
                }
                else {
                    cs.push(str);
                }
                start = i + 1;
            }
            i++;
        }
        if (cs === null)
            return s;
        cs.push(s.substring(start, i));
        return cs.join("");
    };
}
function isHighSurrogate(cc) {
    return cc >= 0xd800 && cc <= 0xdbff;
}
function isLowSurrogate(cc) {
    return cc >= 0xdc00 && cc <= 0xdfff;
}
function utf32ConcatMap(mapper) {
    const { charStringMap, charNoEscapeMap } = computeAsciiMap(mapper);
    // eslint-disable-next-line @typescript-eslint/naming-convention
    return function stringConcatMap_inner(s) {
        let cs = null;
        let start = 0;
        let i = 0;
        while (i < s.length) {
            let cc = s.charCodeAt(i);
            if (charNoEscapeMap[cc] !== 1) {
                if (cs === null)
                    cs = [];
                cs.push(s.substring(start, i));
                if (isHighSurrogate(cc)) {
                    const highSurrogate = cc;
                    i++;
                    const lowSurrogate = s.charCodeAt(i);
                    messageAssert(isLowSurrogate(lowSurrogate), "MiscUnicodeHighSurrogateWithoutLowSurrogate", {});
                    const highBits = highSurrogate - 0xd800;
                    const lowBits = lowSurrogate - 0xdc00;
                    cc = 0x10000 + lowBits + (highBits << 10);
                }
                const str = charStringMap[cc];
                if (str === undefined) {
                    cs.push(mapper(cc));
                }
                else {
                    cs.push(str);
                }
                start = i + 1;
            }
            i++;
        }
        if (cs === null)
            return s;
        cs.push(s.substring(start, i));
        return cs.join("");
    };
}
function utf16LegalizeCharacters(isLegal) {
    return utf16ConcatMap(u => (isLegal(u) ? String.fromCharCode(u) : ""));
}
function legalizeCharacters(isLegal) {
    return utf32ConcatMap(u => (u <= 0xffff && isLegal(u) ? String.fromCharCode(u) : ""));
}
function repeatString(s, n) {
    assert(n >= 0, "Cannot repeat a string a negative number of times");
    if (n === 0)
        return "";
    // From https://github.com/lodash/lodash
    // Leverage the exponentiation by squaring algorithm for a faster repeat.
    // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
    let result = "";
    do {
        if (n % 2 !== 0) {
            result += s;
        }
        n = Math.floor(n / 2);
        if (n > 0) {
            s += s;
        }
    } while (n > 0);
    return result;
}
function intToHex(i, width) {
    let str = i.toString(16);
    if (str.length >= width)
        return str;
    return repeatString("0", width - str.length) + str;
}
function standardUnicodeHexEscape(codePoint) {
    if (codePoint <= 0xffff) {
        return "\\u" + intToHex(codePoint, 4);
    }
    else {
        return "\\U" + intToHex(codePoint, 8);
    }
}
function escapeNonPrintableMapper(printablePredicate, escaper) {
    function mapper(u) {
        switch (u) {
            case 0x5c:
                return "\\\\";
            case 0x22:
                return '\\"';
            case 0x0a:
                return "\\n";
            case 0x09:
                return "\\t";
            default:
                if (printablePredicate(u)) {
                    return String.fromCharCode(u);
                }
                return escaper(u);
        }
    }
    return mapper;
}
const utf16StringEscape = utf16ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
const stringEscape$7 = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeHexEscape));
function isPrintable(codePoint) {
    if (codePoint > 0xffff)
        return false;
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(codePoint);
    return [
        "Mc",
        "No",
        "Sk",
        "Me",
        "Nd",
        "Po",
        "Lt",
        "Pc",
        "Sm",
        "Zs",
        "Lu",
        "Pd",
        "So",
        "Pe",
        "Pf",
        "Ps",
        "Sc",
        "Ll",
        "Lm",
        "Pi",
        "Nl",
        "Mn",
        "Lo"
    ].includes(category);
}
function isAscii(codePoint) {
    return codePoint < 128;
}
function isLetter(codePoint) {
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(codePoint);
    // FIXME: Include Letter, modifier (Lm)?
    return ["Lu", "Ll", "Lt", "Lo"].includes(category);
}
function isDigit(codePoint) {
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(codePoint);
    return ["Nd"].includes(category);
}
function isNumeric(codePoint) {
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(codePoint);
    return ["No", "Nd", "Nl"].includes(category);
}
function isLetterOrDigit(codePoint) {
    return isLetter(codePoint) || isDigit(codePoint);
}
function isLetterOrUnderscore(codePoint) {
    return isLetter(codePoint) || codePoint === 0x5f;
}
function isLetterOrUnderscoreOrDigit(codePoint) {
    return isLetterOrUnderscore(codePoint) || isDigit(codePoint);
}
function isWordCharacter(codePoint) {
    return isLetter(codePoint) || isDigit(codePoint);
}
function trimEnd(str) {
    const l = str.length;
    let firstWS = l;
    for (let i = l - 1; i >= 0; i--) {
        if (!$747425b437e121da$export$2e2bcd8739ae039.isWhiteSpace(str.charCodeAt(i)))
            break;
        firstWS = i;
    }
    if (firstWS === l)
        return str;
    return str.slice(0, firstWS);
}
function modifyFirstChar(f, s) {
    if (s === "")
        return s;
    return f(s[0]) + s.slice(1);
}
function capitalize(str) {
    return modifyFirstChar(c => c.toUpperCase(), str);
}
function decapitalize(str) {
    return modifyFirstChar(c => c.toLowerCase(), str);
}
const wordSeparatorRegex = /[-_. ]+/;
function pascalCase(str) {
    const words = str.split(wordSeparatorRegex).map(capitalize);
    return words.join("");
}
function camelCase(str) {
    return decapitalize(pascalCase(str));
}
function snakeCase(str) {
    const words = splitIntoWords(str).map(({ word }) => word.toLowerCase());
    return words.join("_");
}
const knownAcronyms = new Set(acronyms);
const fastIsWordCharacter = precomputedCodePointPredicate(isWordCharacter);
const fastIsNonWordCharacter = precomputedCodePointPredicate(cp => !isWordCharacter(cp));
const fastIsLowerCase = precomputedCodePointPredicate(cp => $747425b437e121da$export$2e2bcd8739ae039.isLowerCase(cp));
const fastIsUpperCase = precomputedCodePointPredicate(cp => $747425b437e121da$export$2e2bcd8739ae039.isUpperCase(cp));
const fastNonLetter = precomputedCodePointPredicate(cp => !$747425b437e121da$export$2e2bcd8739ae039.isLowerCase(cp) && !$747425b437e121da$export$2e2bcd8739ae039.isUpperCase(cp));
const fastIsDigit = precomputedCodePointPredicate(isDigit);
function splitIntoWords(s) {
    // [start, end, allUpper]
    const intervals = [];
    let intervalStart = undefined;
    const len = s.length;
    let i = 0;
    let lastLowerCaseIndex = undefined;
    function atEnd() {
        return i >= len;
    }
    function currentCodePoint() {
        return defined(s.codePointAt(i));
    }
    function skipWhile(p) {
        while (!atEnd()) {
            const cp = currentCodePoint();
            if (!p(cp))
                break;
            if (fastIsLowerCase(cp))
                lastLowerCaseIndex = i;
            i++;
        }
    }
    function skipNonWord() {
        skipWhile(fastIsNonWordCharacter);
    }
    function skipLowerCase() {
        skipWhile(fastIsLowerCase);
    }
    function skipUpperCase() {
        skipWhile(fastIsUpperCase);
    }
    function skipNonLetter() {
        skipWhile(fastNonLetter);
    }
    function skipDigits() {
        skipWhile(fastIsDigit);
    }
    function startInterval() {
        assert(intervalStart === undefined, "Interval started before last one was committed");
        intervalStart = i;
    }
    function commitInterval() {
        if (intervalStart === undefined) {
            return panic("Tried to commit interval without starting one");
        }
        assert(i > intervalStart, "Interval must be non-empty");
        // FIXME: This is a hack to avoid splitting up surrogates.  We shouldn't
        // look at surrogates individually in the first place.  When we
        // encounter a high surrogate we have to combine it with the low
        // surrogate and then do the logic on the code point.  Right now we're
        // only operating on UTF16 char codes, which is wrong.
        if (!atEnd() && isLowSurrogate(currentCodePoint())) {
            i += 1;
        }
        const allUpper = lastLowerCaseIndex === undefined || lastLowerCaseIndex < intervalStart;
        intervals.push([intervalStart, i, allUpper]);
        intervalStart = undefined;
    }
    function intervalLength() {
        if (intervalStart === undefined) {
            return panic("Tried to get interval length without starting one");
        }
        return i - intervalStart;
    }
    for (;;) {
        skipNonWord();
        if (atEnd())
            break;
        startInterval();
        if (fastIsLowerCase(currentCodePoint())) {
            skipLowerCase();
            skipDigits();
            commitInterval();
        }
        else if (fastIsUpperCase(currentCodePoint())) {
            skipUpperCase();
            if (atEnd()) {
                commitInterval();
            }
            else if (intervalLength() === 1) {
                skipLowerCase();
                skipDigits();
                commitInterval();
            }
            else if (isDigit(currentCodePoint())) {
                skipDigits();
                commitInterval();
            }
            else {
                if (fastIsWordCharacter(currentCodePoint())) {
                    i -= 1;
                }
                commitInterval();
            }
        }
        else {
            skipNonLetter();
            commitInterval();
        }
    }
    const words = [];
    for (const [start, end, allUpper] of intervals) {
        const word = s.slice(start, end);
        const isAcronym = (lastLowerCaseIndex !== undefined && allUpper) || knownAcronyms.has(word.toLowerCase());
        words.push({ word, isAcronym });
    }
    return words;
}
function firstUpperWordStyle(s) {
    assert(s.length > 0, "Cannot style an empty string");
    return s[0].toUpperCase() + s.slice(1).toLowerCase();
}
function allUpperWordStyle(s) {
    return s.toUpperCase();
}
function originalWord(s) {
    return s;
}
function allLowerWordStyle(s) {
    return s.toLowerCase();
}
function styleWord(style, word) {
    assert(word.length > 0, "Tried to style an empty word");
    const result = style(word);
    assert(result.length > 0, "Word style must not make word empty");
    return result;
}
function combineWords(words, removeInvalidCharacters, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isStartCharacter) {
    const legalizedWords = [];
    for (const w of words) {
        const word = removeInvalidCharacters(w.word);
        if (word.length === 0)
            continue;
        legalizedWords.push({ word, isAcronym: w.isAcronym });
    }
    if (legalizedWords.length === 0) {
        const validEmpty = removeInvalidCharacters("empty");
        assert(validEmpty.length > 0, 'Word "empty" is invalid in target language');
        legalizedWords.push({ word: validEmpty, isAcronym: false });
    }
    const styledWords = [];
    const first = legalizedWords[0];
    const firstStyle = first.isAcronym ? firstWordAcronymStyle : firstWordStyle;
    const styledFirstWord = styleWord(firstStyle, first.word);
    let restWords;
    if (!isStartCharacter(defined(styledFirstWord.codePointAt(0)))) {
        const validThe = removeInvalidCharacters("the");
        assert(validThe.length > 0, 'Word "the" is invalid in the target language');
        const styledThe = styleWord(firstWordStyle, validThe);
        assert(isStartCharacter(defined(styledThe.codePointAt(0))), 'The first character of styling "the" is not a start character');
        styledWords.push(styledThe);
        restWords = legalizedWords;
    }
    else {
        styledWords.push(styledFirstWord);
        restWords = legalizedWords.slice(1);
    }
    for (const w of restWords) {
        const style = w.isAcronym ? restAcronymStyle : restWordStyle;
        styledWords.push(styleWord(style, w.word));
    }
    return styledWords.join(separator);
}
function addPrefixIfNecessary(prefix, name) {
    // Take care not to doubly-prefix type names
    return name.startsWith(prefix) ? name : prefix + name;
}
function makeNameStyle(namingStyle, legalizeName, prefix) {
    let separator;
    let firstWordStyle;
    let restWordStyle;
    let firstWordAcronymStyle;
    let restAcronymStyle;
    if (namingStyle === "pascal" ||
        namingStyle === "camel" ||
        namingStyle === "pascal-upper-acronyms" ||
        namingStyle === "camel-upper-acronyms") {
        separator = "";
        if (namingStyle === "pascal-upper-acronyms" || namingStyle === "camel-upper-acronyms") {
            restWordStyle = firstUpperWordStyle;
            restAcronymStyle = allUpperWordStyle;
        }
        else {
            restWordStyle = restAcronymStyle = firstUpperWordStyle;
        }
    }
    else {
        separator = "_";
    }
    switch (namingStyle) {
        case "pascal":
        case "pascal-upper-acronyms":
            firstWordStyle = firstWordAcronymStyle = firstUpperWordStyle;
            break;
        case "camel":
        case "camel-upper-acronyms":
            firstWordStyle = firstWordAcronymStyle = allLowerWordStyle;
            break;
        case "underscore":
            firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = allLowerWordStyle;
            break;
        case "upper-underscore":
            firstWordStyle = restWordStyle = firstWordAcronymStyle = restAcronymStyle = allUpperWordStyle;
            break;
        default:
            return assertNever(namingStyle);
    }
    return (original) => {
        const words = splitIntoWords(original);
        const styledName = combineWords(words, legalizeName, firstWordStyle, restWordStyle, firstWordAcronymStyle, restAcronymStyle, separator, isLetterOrUnderscore);
        {
            return styledName;
        }
    };
}

class TypeAttributeKind {
    constructor(name) {
        this.name = name;
    }
    appliesToTypeKind(kind) {
        return kind !== "any";
    }
    combine(_attrs) {
        return panic(`Cannot combine type attribute ${this.name}`);
    }
    intersect(attrs) {
        return this.combine(attrs);
    }
    makeInferred(_) {
        return panic(`Cannot make type attribute ${this.name} inferred`);
    }
    increaseDistance(attrs) {
        return attrs;
    }
    addToSchema(_schema, _t, _attrs) {
        return;
    }
    children(_) {
        return new Set();
    }
    stringify(_) {
        return undefined;
    }
    get inIdentity() {
        return false;
    }
    requiresUniqueIdentity(_) {
        return false;
    }
    reconstitute(_builder, a) {
        return a;
    }
    makeAttributes(value) {
        const kvps = [[this, value]];
        return new Map(kvps);
    }
    tryGetInAttributes(a) {
        return a.get(this);
    }
    setInAttributes(a, value) {
        // FIXME: This is potentially super slow
        return new Map(a).set(this, value);
    }
    modifyInAttributes(a, modify) {
        const modified = modify(this.tryGetInAttributes(a));
        if (modified === undefined) {
            // FIXME: This is potentially super slow
            const result = new Map(a);
            result.delete(this);
            return result;
        }
        return this.setInAttributes(a, modified);
    }
    setDefaultInAttributes(a, makeDefault) {
        if (this.tryGetInAttributes(a) !== undefined)
            return a;
        return this.modifyInAttributes(a, makeDefault);
    }
    removeInAttributes(a) {
        return collectionUtils.mapFilter(a, (_, k) => k !== this);
    }
    equals(other) {
        if (!(other instanceof TypeAttributeKind)) {
            return false;
        }
        return this.name === other.name;
    }
    hashCode() {
        return collectionUtils.hashString(this.name);
    }
}
const emptyTypeAttributes = new Map();
function combineTypeAttributes(combinationKind, firstOrArray, second) {
    const union = combinationKind === "union";
    let attributeArray;
    if (Array.isArray(firstOrArray)) {
        attributeArray = firstOrArray;
    }
    else {
        if (second === undefined) {
            return panic("Must have on array or two attributes");
        }
        attributeArray = [firstOrArray, second];
    }
    const attributesByKind = collectionUtils.mapTranspose(attributeArray);
    // FIXME: strongly type this
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function combine(attrs, kind) {
        assert(attrs.length > 0, "Cannot combine zero type attributes");
        if (attrs.length === 1)
            return attrs[0];
        if (union) {
            return kind.combine(attrs);
        }
        else {
            return kind.intersect(attrs);
        }
    }
    return collectionUtils.mapFilterMap(attributesByKind, combine);
}
function makeTypeAttributesInferred(attr) {
    return collectionUtils.mapFilterMap(attr, (value, kind) => kind.makeInferred(value));
}
function increaseTypeAttributesDistance(attr) {
    return collectionUtils.mapFilterMap(attr, (value, kind) => kind.increaseDistance(value));
}

let chance;
let usedRandomNames;
function initTypeNames() {
    chance = new Chance(31415);
    usedRandomNames = new Set();
}
initTypeNames();
function makeRandomName() {
    for (;;) {
        const name = `${chance.city()} ${chance.animal()}`;
        if (usedRandomNames.has(name))
            continue;
        usedRandomNames.add(name);
        return name;
    }
}
// FIXME: In the case of overlapping prefixes and suffixes we will
// produce a name that includes the overlap twice.  For example, for
// the names "aaa" and "aaaa" we have the common prefix "aaa" and the
// common suffix "aaa", so we will produce the combined name "aaaaaa".
function combineNames(names) {
    let originalFirst = collectionUtils.iterableFirst(names);
    if (originalFirst === undefined) {
        return panic("Named type has no names");
    }
    if (names.size === 1) {
        return originalFirst;
    }
    const namesSet = collectionUtils.setMap(names, s => splitIntoWords(s)
        .map(w => w.word.toLowerCase())
        .join("_"));
    const first = defined(collectionUtils.iterableFirst(namesSet));
    if (namesSet.size === 1) {
        return first;
    }
    let prefixLength = first.length;
    let suffixLength = first.length;
    for (const n of collectionUtils.iterableSkip(namesSet, 1)) {
        prefixLength = Math.min(prefixLength, n.length);
        for (let i = 0; i < prefixLength; i++) {
            if (first[i] !== n[i]) {
                prefixLength = i;
                break;
            }
        }
        suffixLength = Math.min(suffixLength, n.length);
        for (let i = 0; i < suffixLength; i++) {
            if (first[first.length - i - 1] !== n[n.length - i - 1]) {
                suffixLength = i;
                break;
            }
        }
    }
    const prefix = prefixLength > 2 ? first.slice(0, prefixLength) : "";
    const suffix = suffixLength > 2 ? first.slice(first.length - suffixLength) : "";
    const combined = prefix + suffix;
    if (combined.length > 2) {
        return combined;
    }
    return first;
}
const tooManyNamesThreshold = 1000;
class TypeNames {
    static makeWithDistance(names, alternativeNames, distance) {
        if (names.size >= tooManyNamesThreshold) {
            return new TooManyTypeNames(distance);
        }
        if (alternativeNames === undefined || alternativeNames.size > tooManyNamesThreshold) {
            alternativeNames = undefined;
        }
        return new RegularTypeNames(names, alternativeNames, distance);
    }
    static make(names, alternativeNames, areInferred) {
        return TypeNames.makeWithDistance(names, alternativeNames, areInferred ? 1 : 0);
    }
    constructor(distance) {
        this.distance = distance;
    }
    get areInferred() {
        return this.distance > 0;
    }
}
class RegularTypeNames extends TypeNames {
    constructor(names, _alternativeNames, distance) {
        super(distance);
        this.names = names;
        this._alternativeNames = _alternativeNames;
    }
    add(namesArray, startIndex = 0) {
        let newNames = new Set(this.names);
        let newDistance = this.distance;
        let newAlternativeNames = collectionUtils.definedMap(this._alternativeNames, s => new Set(s));
        for (let i = startIndex; i < namesArray.length; i++) {
            const other = namesArray[i];
            if (other instanceof RegularTypeNames && other._alternativeNames !== undefined) {
                if (newAlternativeNames === undefined) {
                    newAlternativeNames = new Set();
                }
                collectionUtils.setUnionInto(newAlternativeNames, other._alternativeNames);
            }
            if (other.distance > newDistance)
                continue;
            if (!(other instanceof RegularTypeNames)) {
                assert(other instanceof TooManyTypeNames, "Unknown TypeNames instance");
                // The other one is at most our distance, so let it sort it out
                return other.add(namesArray, i + 1);
            }
            if (other.distance < newDistance) {
                // The other one is closer, so take its names
                newNames = new Set(other.names);
                newDistance = other.distance;
                newAlternativeNames = collectionUtils.definedMap(other._alternativeNames, s => new Set(s));
            }
            else {
                // Same distance, merge them
                assert(other.distance === newDistance, "This should be the only case left");
                collectionUtils.setUnionInto(newNames, other.names);
            }
        }
        return TypeNames.makeWithDistance(newNames, newAlternativeNames, newDistance);
    }
    clearInferred() {
        const newNames = this.areInferred ? new Set() : this.names;
        return TypeNames.makeWithDistance(newNames, new Set(), this.distance);
    }
    get combinedName() {
        return combineNames(this.names);
    }
    get proposedNames() {
        const set = new Set([this.combinedName]);
        if (this._alternativeNames === undefined) {
            return set;
        }
        collectionUtils.setUnionInto(set, this._alternativeNames);
        return set;
    }
    makeInferred() {
        return TypeNames.makeWithDistance(this.names, this._alternativeNames, this.distance + 1);
    }
    singularize() {
        return TypeNames.makeWithDistance(collectionUtils.setMap(this.names, pluralize__namespace.singular), collectionUtils.definedMap(this._alternativeNames, an => collectionUtils.setMap(an, pluralize__namespace.singular)), this.distance + 1);
    }
    toString() {
        const inferred = this.areInferred ? `distance ${this.distance}` : "given";
        const names = `${inferred} ${Array.from(this.names).join(",")}`;
        if (this._alternativeNames === undefined) {
            return names;
        }
        return `${names} (${Array.from(this._alternativeNames).join(",")})`;
    }
}
class TooManyTypeNames extends TypeNames {
    constructor(distance, name) {
        super(distance);
        if (name === undefined) {
            name = makeRandomName();
        }
        this.names = new Set([name]);
    }
    get combinedName() {
        return defined(collectionUtils.iterableFirst(this.names));
    }
    get proposedNames() {
        return this.names;
    }
    add(namesArray, startIndex = 0) {
        if (!this.areInferred)
            return this;
        for (let i = startIndex; i < namesArray.length; i++) {
            const other = namesArray[i];
            if (other.distance < this.distance) {
                return other.add(namesArray, i + 1);
            }
        }
        return this;
    }
    clearInferred() {
        if (!this.areInferred) {
            return this;
        }
        return TypeNames.makeWithDistance(new Set(), new Set(), this.distance);
    }
    makeInferred() {
        return new TooManyTypeNames(this.distance + 1, collectionUtils.iterableFirst(this.names));
    }
    singularize() {
        return this;
    }
    toString() {
        return `too many ${this.combinedName}`;
    }
}
class TypeNamesTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("names");
    }
    combine(namesArray) {
        assert(namesArray.length > 0, "Can't combine zero type names");
        return namesArray[0].add(namesArray, 1);
    }
    makeInferred(tn) {
        return tn.makeInferred();
    }
    increaseDistance(tn) {
        return tn.makeInferred();
    }
    stringify(tn) {
        return tn.toString();
    }
}
const namesTypeAttributeKind = new TypeNamesTypeAttributeKind();
function modifyTypeNames(attributes, modifier) {
    return namesTypeAttributeKind.modifyInAttributes(attributes, modifier);
}
function singularizeTypeNames(attributes) {
    return modifyTypeNames(attributes, maybeNames => {
        if (maybeNames === undefined)
            return undefined;
        return maybeNames.singularize();
    });
}
function makeNamesTypeAttributes(nameOrNames, areNamesInferred) {
    let typeNames;
    if (typeof nameOrNames === "string") {
        typeNames = TypeNames.make(new Set([nameOrNames]), new Set(), defined(areNamesInferred));
    }
    else {
        typeNames = nameOrNames;
    }
    return namesTypeAttributeKind.makeAttributes(typeNames);
}

const protocolsSchemaProperty = "qt-uri-protocols";
const extensionsSchemaProperty = "qt-uri-extensions";
class URITypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("uriAttributes");
    }
    get inIdentity() {
        return true;
    }
    combine(attrs) {
        const protocolSets = attrs.map(a => a[0]);
        const extensionSets = attrs.map(a => a[1]);
        return [collectionUtils.setUnionManyInto(new Set(), protocolSets), collectionUtils.setUnionManyInto(new Set(), extensionSets)];
    }
    makeInferred(_) {
        return undefined;
    }
    addToSchema(schema, t, attrs) {
        if (t.kind !== "string" && t.kind !== "uri")
            return;
        const [protocols, extensions] = attrs;
        if (protocols.size > 0) {
            schema[protocolsSchemaProperty] = Array.from(protocols).sort();
        }
        if (extensions.size > 0) {
            schema[extensionsSchemaProperty] = Array.from(extensions).sort();
        }
    }
}
const uriTypeAttributeKind = new URITypeAttributeKind();
const extensionRegex = /^.+(\.[^./\\]+)$/;
function pathExtension(path) {
    const matches = extensionRegex.exec(path);
    if (matches === null)
        return undefined;
    return matches[1];
}
function uriInferenceAttributesProducer(s) {
    try {
        const uri = URI$1(s);
        const extension = pathExtension(uri.path());
        const extensions = extension === undefined ? [] : [extension.toLowerCase()];
        return uriTypeAttributeKind.makeAttributes([new Set([uri.protocol().toLowerCase()]), new Set(extensions)]);
    }
    catch (_a) {
        return emptyTypeAttributes;
    }
}
function uriSchemaAttributesProducer(schema, _ref, types) {
    if (!(typeof schema === "object"))
        return undefined;
    if (!types.has("string"))
        return undefined;
    let protocols;
    const maybeProtocols = schema[protocolsSchemaProperty];
    if (maybeProtocols !== undefined) {
        protocols = new Set(checkArray(maybeProtocols, checkString));
    }
    else {
        protocols = new Set();
    }
    let extensions;
    const maybeExtensions = schema[extensionsSchemaProperty];
    if (maybeExtensions !== undefined) {
        extensions = new Set(checkArray(maybeExtensions, checkString));
    }
    else {
        extensions = new Set();
    }
    if (protocols.size === 0 && extensions.size === 0)
        return undefined;
    return { forString: uriTypeAttributeKind.makeAttributes([protocols, extensions]) };
}

function countComponentGraphNodes(components) {
    if (components.length === 0)
        return 0;
    let largest = -1;
    let count = 0;
    for (const c of components) {
        assert(c.length > 0, "Empty component not allowed");
        for (const v of c) {
            assert(v >= 0, "Negative vertex index is invalid");
            largest = Math.max(largest, v);
            count += 1;
        }
    }
    assert(largest + 1 === count, "Vertex indexes and count don't match up");
    return count;
}
// https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
function stronglyConnectedComponents(successors) {
    let index = 0;
    const stack = [];
    const numNodes = successors.length;
    const indexes = repeated(numNodes, -1);
    const lowLinks = repeated(numNodes, -1);
    const onStack = repeated(numNodes, false);
    const sccs = [];
    function strongconnect(v) {
        // Set the depth index for v to the smallest unused index
        indexes[v] = index;
        lowLinks[v] = index;
        index += 1;
        stack.push(v);
        onStack[v] = true;
        // Consider successors of v
        for (const w of successors[v]) {
            if (indexes[w] < 0) {
                // Successor w has not yet been visited; recurse on it
                strongconnect(w);
                lowLinks[v] = Math.min(lowLinks[v], lowLinks[w]);
            }
            else if (onStack[w]) {
                // Successor w is in stack and hence in the current SCC
                // If w is not on stack, then (v, w) is a cross-edge in the DFS tree and must be ignored
                // Note: The next line may look odd - but is correct.
                // It says w.index not w.lowlink; that is deliberate and from the original paper
                lowLinks[v] = Math.min(lowLinks[v], indexes[w]);
            }
        }
        // If v is a root node, pop the stack and generate an SCC
        if (lowLinks[v] === indexes[v]) {
            const scc = [];
            let w;
            do {
                w = defined(stack.pop());
                onStack[w] = false;
                scc.push(w);
            } while (w !== v);
            sccs.push(scc);
        }
    }
    for (let v = 0; v < numNodes; v++) {
        if (indexes[v] < 0) {
            strongconnect(v);
        }
    }
    assert(countComponentGraphNodes(sccs) === numNodes, "We didn't put all the nodes into SCCs");
    return sccs;
}
function buildComponentOfNodeMap(successors, components) {
    const numComponents = components.length;
    const numNodes = successors.length;
    assert(numNodes === countComponentGraphNodes(components), "Components don't match up with graph");
    const componentOfNode = repeated(numNodes, -1);
    for (let c = 0; c < numComponents; c++) {
        for (const n of components[c]) {
            assert(componentOfNode[n] < 0, "We have a node that's in two components");
            componentOfNode[n] = c;
        }
    }
    return componentOfNode;
}
function buildMetaSuccessors(successors, components) {
    const numComponents = components.length;
    const componentOfNode = buildComponentOfNodeMap(successors, components);
    const componentAdded = repeated(numComponents, false);
    const metaSuccessors = [];
    for (let c = 0; c < numComponents; c++) {
        const succ = [];
        for (const n of components[c]) {
            for (const s of successors[n]) {
                const ms = componentOfNode[s];
                if (ms === c || componentAdded[ms])
                    continue;
                succ.push(ms);
                componentAdded[ms] = true;
            }
        }
        // reset bookkeeping
        for (const ms of succ) {
            assert(componentAdded[ms]);
            componentAdded[ms] = false;
        }
        metaSuccessors.push(succ);
    }
    return metaSuccessors;
}
function invertEdges(successors) {
    const numNodes = successors.length;
    const predecessors = repeatedCall(numNodes, () => []);
    for (let s = 0; s < numNodes; s++) {
        for (const v of successors[s]) {
            predecessors[v].push(s);
        }
    }
    return predecessors;
}
function calculateInDegrees(successors) {
    const numNodes = successors.length;
    const inDegrees = repeated(numNodes, 0);
    for (const s of successors) {
        for (const v of s) {
            inDegrees[v] += 1;
        }
    }
    return inDegrees;
}
function findRoots(successors) {
    const numNodes = successors.length;
    const inDegrees = calculateInDegrees(successors);
    const roots = [];
    for (let v = 0; v < numNodes; v++) {
        if (inDegrees[v] === 0) {
            roots.push(v);
        }
    }
    return roots;
}
class Graph {
    constructor(nodes, invertDirection, edges) {
        this._nodes = Array.from(nodes);
        this._indexByNode = new Map(this._nodes.map((n, i) => [n, i]));
        let edgesArray;
        if (Array.isArray(edges)) {
            edgesArray = edges;
        }
        else {
            edgesArray = this._nodes.map(n => Array.from(edges(n)).map(s => defined(this._indexByNode.get(s))));
        }
        if (invertDirection) {
            edgesArray = invertEdges(edgesArray);
        }
        this._successors = edgesArray;
    }
    get size() {
        return this._nodes.length;
    }
    get nodes() {
        return this._nodes;
    }
    findRoots() {
        const roots = findRoots(this._successors);
        return new Set(roots.map(n => this._nodes[n]));
    }
    // The subgraph starting at `root` must be acyclic.
    dfsTraversal(root, preOrder, process) {
        const visited = repeated(this.size, false);
        const visit = (v) => {
            if (visited[v])
                return;
            visited[v] = true;
            if (preOrder) {
                process(this._nodes[v]);
            }
            for (const w of this._successors[v]) {
                visit(w);
            }
            if (!preOrder) {
                process(this._nodes[v]);
            }
        };
        visit(defined(this._indexByNode.get(root)));
    }
    stronglyConnectedComponents() {
        const components = stronglyConnectedComponents(this._successors);
        const componentSuccessors = buildMetaSuccessors(this._successors, components);
        return new Graph(components.map(ns => collectionUtils.setMap(ns, n => this._nodes[n])), false, componentSuccessors);
    }
    makeDot(includeNode, nodeLabel) {
        const lines = [];
        lines.push("digraph G {");
        lines.push("    ordering = out;");
        lines.push("");
        for (let i = 0; i < this.size; i++) {
            const n = this._nodes[i];
            if (!includeNode(n))
                continue;
            lines.push(`    node${i} [label="${nodeLabel(n)}"];`);
        }
        for (let i = 0; i < this.size; i++) {
            if (!includeNode(this._nodes[i]))
                continue;
            for (const j of this._successors[i]) {
                if (!includeNode(this._nodes[j]))
                    continue;
                lines.push(`    node${i} -> node${j};`);
            }
        }
        lines.push("}");
        lines.push("");
        return lines.join("\n");
    }
}

class StringTypes {
    static fromCase(s, count) {
        return new StringTypes(new Map([[s, count]]), new Set());
    }
    static fromCases(cases) {
        for (const s of cases) {
        }
        return new StringTypes(new Map(cases.map(s => [s, 1])), new Set());
    }
    // undefined means no restrictions
    constructor(cases, transformations) {
        this.cases = cases;
        this.transformations = transformations;
        if (cases === undefined) {
            assert(transformations.size === 0, "We can't have an unrestricted string that also allows transformations");
        }
    }
    get isRestricted() {
        return this.cases !== undefined;
    }
    union(othersArray, startIndex) {
        if (this.cases === undefined)
            return this;
        const cases = new Map(this.cases);
        const transformations = new Set(this.transformations);
        for (let i = startIndex; i < othersArray.length; i++) {
            const other = othersArray[i];
            if (other.cases === undefined)
                return other;
            collectionUtils.mapMergeWithInto(cases, (x, y) => x + y, other.cases);
            collectionUtils.setUnionInto(transformations, other.transformations);
        }
        return new StringTypes(cases, transformations);
    }
    intersect(othersArray, startIndex) {
        let cases = this.cases;
        let transformations = this.transformations;
        for (let i = startIndex; i < othersArray.length; i++) {
            const other = othersArray[i];
            if (cases === undefined) {
                cases = collectionUtils.definedMap(other.cases, m => new Map(m));
            }
            else if (other.cases !== undefined) {
                const thisCases = cases;
                const otherCases = other.cases;
                const intersects = collectionUtils.setIntersect(thisCases.keys(), new Set(otherCases.keys()));
                const entries = intersects.size > 0 ? intersects.entries() : new Set(thisCases.keys()).entries();
                cases = collectionUtils.mapMap(entries, k => {
                    var _a;
                    const thisValue = defined(thisCases.get(k));
                    const otherValue = (_a = otherCases.get(k)) !== null && _a !== void 0 ? _a : Math.min();
                    return Math.min(thisValue, otherValue);
                });
            }
            transformations = collectionUtils.setIntersect(transformations, other.transformations);
        }
        return new StringTypes(cases, transformations);
    }
    applyStringTypeMapping(mapping) {
        if (!this.isRestricted)
            return this;
        const kinds = new Set();
        for (const kind of this.transformations) {
            const mapped = stringTypeMappingGet(mapping, kind);
            if (mapped === "string")
                return StringTypes.unrestricted;
            kinds.add(mapped);
        }
        return new StringTypes(this.cases, new Set(kinds));
    }
    equals(other) {
        if (!(other instanceof StringTypes))
            return false;
        return collectionUtils.areEqual(this.cases, other.cases) && collectionUtils.areEqual(this.transformations, other.transformations);
    }
    hashCode() {
        let h = collectionUtils.hashCodeOf(this.cases);
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.transformations));
        return h;
    }
    toString() {
        const parts = [];
        const enumCases = this.cases;
        if (enumCases === undefined) {
            parts.push("unrestricted");
        }
        else {
            const firstKey = collectionUtils.iterableFirst(enumCases.keys());
            if (firstKey === undefined) {
                parts.push("enum with no cases");
            }
            else {
                parts.push(`${enumCases.size.toString()} enums: ${firstKey} (${enumCases.get(firstKey)}), ...`);
            }
        }
        return parts.concat(Array.from(this.transformations)).join(",");
    }
}
StringTypes.unrestricted = new StringTypes(undefined, new Set());
class StringTypesTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("stringTypes");
    }
    get inIdentity() {
        return true;
    }
    requiresUniqueIdentity(st) {
        return st.cases !== undefined && st.cases.size > 0;
    }
    combine(arr) {
        assert(arr.length > 0);
        return arr[0].union(arr, 1);
    }
    intersect(arr) {
        assert(arr.length > 0);
        return arr[0].intersect(arr, 1);
    }
    makeInferred(_) {
        return undefined;
    }
    stringify(st) {
        return st.toString();
    }
}
const stringTypesTypeAttributeKind = new StringTypesTypeAttributeKind();
const INTEGER_STRING = /^(0|-?[1-9]\d*)$/;
// We're restricting numbers to what's representable as 32 bit
// signed integers, to be on the safe side of most languages.
const MIN_INTEGER_STRING = 1 << 31;
const MAX_INTEGER_STRING = -(MIN_INTEGER_STRING + 1);
function isIntegerString(s) {
    if (INTEGER_STRING.exec(s) === null) {
        return false;
    }
    const i = parseInt(s, 10);
    return i >= MIN_INTEGER_STRING && i <= MAX_INTEGER_STRING;
}
const UUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function isUUID(s) {
    return UUID.exec(s) !== null;
}
// FIXME: This is obviously not a complete URI regex.  The exclusion of
// `{}` is a hack to make `github-events.json` work, which contains URLs
// with those characters which ajv refuses to accept as `uri`.
const URI = /^(https?|ftp):\/\/[^{}]+$/;
function isURI(s) {
    return URI.exec(s) !== null;
}
/**
 * JSON inference calls this function to figure out whether a given string is to be
 * transformed into a higher level type.  Must return undefined if not, otherwise the
 * type kind of the transformed string type.
 *
 * @param s The string for which to determine the transformed string type kind.
 */
function inferTransformedStringTypeKindForString(s, recognizer) {
    if (s.length === 0 || !"0123456789-abcdefth".includes(s[0]))
        return undefined;
    if (recognizer.isDate(s)) {
        return "date";
    }
    else if (recognizer.isTime(s)) {
        return "time";
    }
    else if (recognizer.isDateTime(s)) {
        return "date-time";
    }
    else if (isIntegerString(s)) {
        return "integer-string";
    }
    else if (s === "false" || s === "true") {
        return "bool-string";
    }
    else if (isUUID(s)) {
        return "uuid";
    }
    else if (isURI(s)) {
        return "uri";
    }
    return undefined;
}

// FIXME: Don't infer provenance.  All original types should be present in
// non-inferred form in the final graph.
class ProvenanceTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("provenance");
    }
    appliesToTypeKind(_kind) {
        return true;
    }
    combine(arr) {
        return collectionUtils.setUnionManyInto(new Set(), arr);
    }
    makeInferred(p) {
        return p;
    }
    stringify(p) {
        return Array.from(p)
            .sort()
            .map(i => i.toString())
            .join(",");
    }
}
const provenanceTypeAttributeKind = new ProvenanceTypeAttributeKind();
function stringTypeMappingGet(stm, kind) {
    const mapped = stm.get(kind);
    if (mapped === undefined)
        return "string";
    return mapped;
}
let noStringTypeMapping;
function getNoStringTypeMapping() {
    if (noStringTypeMapping === undefined) {
        noStringTypeMapping = new Map(Array.from(transformedStringTypeKinds).map(k => [k, k]));
    }
    return noStringTypeMapping;
}
class TypeBuilder {
    constructor(typeGraphSerial, _stringTypeMapping, canonicalOrder, _allPropertiesOptional, _addProvenanceAttributes, inheritsProvenanceAttributes) {
        this._stringTypeMapping = _stringTypeMapping;
        this.canonicalOrder = canonicalOrder;
        this._allPropertiesOptional = _allPropertiesOptional;
        this._addProvenanceAttributes = _addProvenanceAttributes;
        this.topLevels = new Map();
        this.types = [];
        this.typeAttributes = [];
        this._addedForwardingIntersection = false;
        this._typeForIdentity = new collectionUtils.EqualityMap();
        assert(!_addProvenanceAttributes || !inheritsProvenanceAttributes, "We can't both inherit as well as add provenance");
        this.typeGraph = new TypeGraph(this, typeGraphSerial, _addProvenanceAttributes || inheritsProvenanceAttributes);
    }
    addTopLevel(name, tref) {
        // assert(t.typeGraph === this.typeGraph, "Adding top-level to wrong type graph");
        assert(!this.topLevels.has(name), "Trying to add top-level with existing name");
        assert(this.types[typeRefIndex(tref)] !== undefined, "Trying to add a top-level type that doesn't exist (yet?)");
        this.topLevels.set(name, tref);
    }
    reserveTypeRef() {
        const index = this.types.length;
        // console.log(`reserving ${index}`);
        this.types.push(undefined);
        const tref = makeTypeRef(this.typeGraph, index);
        const attributes = this._addProvenanceAttributes
            ? provenanceTypeAttributeKind.makeAttributes(new Set([index]))
            : emptyTypeAttributes;
        this.typeAttributes.push(attributes);
        return tref;
    }
    assertTypeRefGraph(tref) {
        if (tref === undefined)
            return;
        assertTypeRefGraph(tref, this.typeGraph);
    }
    assertTypeRefSetGraph(trefs) {
        if (trefs === undefined)
            return;
        trefs.forEach(tref => this.assertTypeRefGraph(tref));
    }
    filterTypeAttributes(t, attributes) {
        const filtered = collectionUtils.mapFilter(attributes, (_, k) => k.appliesToTypeKind(t.kind));
        if (attributes.size !== filtered.size) {
            this.setLostTypeAttributes();
        }
        return filtered;
    }
    commitType(tref, t) {
        this.assertTypeRefGraph(tref);
        const index = typeRefIndex(tref);
        // const name = names !== undefined ? ` ${names.combinedName}` : "";
        // console.log(`committing ${t.kind}${name} to ${index}`);
        assert(this.types[index] === undefined, "A type index was committed twice");
        this.types[index] = t;
        this.typeAttributes[index] = this.filterTypeAttributes(t, this.typeAttributes[index]);
    }
    addType(forwardingRef, creator, attributes) {
        if (forwardingRef !== undefined) {
            this.assertTypeRefGraph(forwardingRef);
            assert(this.types[typeRefIndex(forwardingRef)] === undefined);
        }
        const tref = forwardingRef !== null && forwardingRef !== void 0 ? forwardingRef : this.reserveTypeRef();
        if (attributes !== undefined) {
            const index = typeRefIndex(tref);
            this.typeAttributes[index] = combineTypeAttributes("union", this.typeAttributes[index], attributes);
        }
        const t = creator(tref);
        this.commitType(tref, t);
        return tref;
    }
    typeAtIndex(index) {
        const maybeType = this.types[index];
        if (maybeType === undefined) {
            return panic("Trying to deref an undefined type in a type builder");
        }
        return maybeType;
    }
    atIndex(index) {
        const t = this.typeAtIndex(index);
        const attribtues = this.typeAttributes[index];
        return [t, attribtues];
    }
    addAttributes(tref, attributes) {
        this.assertTypeRefGraph(tref);
        const index = typeRefIndex(tref);
        const existingAttributes = this.typeAttributes[index];
        assert(collectionUtils.iterableEvery(attributes, ([k, v]) => {
            if (!k.inIdentity)
                return true;
            const existing = existingAttributes.get(k);
            if (existing === undefined)
                return false;
            return collectionUtils.areEqual(existing, v);
        }), "Can't add different identity type attributes to an existing type");
        const maybeType = this.types[index];
        if (maybeType !== undefined) {
            attributes = this.filterTypeAttributes(maybeType, attributes);
        }
        const nonIdentityAttributes = collectionUtils.mapFilter(attributes, (_, k) => !k.inIdentity);
        this.typeAttributes[index] = combineTypeAttributes("union", existingAttributes, nonIdentityAttributes);
    }
    finish() {
        this.typeGraph.freeze(this.topLevels, this.types.map(defined), this.typeAttributes);
        return this.typeGraph;
    }
    addForwardingIntersection(forwardingRef, tref) {
        this.assertTypeRefGraph(tref);
        this._addedForwardingIntersection = true;
        return this.addType(forwardingRef, tr => new IntersectionType(tr, this.typeGraph, new Set([tref])), undefined);
    }
    forwardIfNecessary(forwardingRef, tref) {
        if (tref === undefined)
            return undefined;
        if (forwardingRef === undefined)
            return tref;
        return this.addForwardingIntersection(forwardingRef, tref);
    }
    get didAddForwardingIntersection() {
        return this._addedForwardingIntersection;
    }
    registerTypeForIdentity(identity, tref) {
        if (identity === undefined)
            return;
        this._typeForIdentity.set(identity, tref);
    }
    makeIdentity(maker) {
        return maker();
    }
    getOrAddType(identityMaker, creator, attributes, forwardingRef) {
        const identity = this.makeIdentity(identityMaker);
        let maybeTypeRef;
        if (identity === undefined) {
            maybeTypeRef = undefined;
        }
        else {
            maybeTypeRef = this._typeForIdentity.get(identity);
        }
        if (maybeTypeRef !== undefined) {
            const result = this.forwardIfNecessary(forwardingRef, maybeTypeRef);
            if (attributes !== undefined) {
                // We only add the attributes that are not in the identity, since
                // we found the type based on its identity, i.e. all the identity
                // attributes must be in there already, and we have a check that
                // asserts that no identity attributes are added later.
                this.addAttributes(result, collectionUtils.mapFilter(attributes, (_, k) => !k.inIdentity));
            }
            return result;
        }
        const tref = this.addType(forwardingRef, creator, attributes);
        this.registerTypeForIdentity(identity, tref);
        return tref;
    }
    registerType(t) {
        this.registerTypeForIdentity(t.identity, t.typeRef);
    }
    getPrimitiveType(kind, maybeAttributes, forwardingRef) {
        const attributes = collectionUtils.withDefault(maybeAttributes, emptyTypeAttributes);
        // FIXME: Why do date/time types need a StringTypes attribute?
        // FIXME: Remove this from here and put it into flattenStrings
        let stringTypes = kind === "string" ? undefined : StringTypes.unrestricted;
        if (isPrimitiveStringTypeKind(kind) && kind !== "string") {
            kind = stringTypeMappingGet(this._stringTypeMapping, kind);
        }
        if (kind === "string") {
            return this.getStringType(attributes, stringTypes, forwardingRef);
        }
        return this.getOrAddType(() => primitiveTypeIdentity(kind, attributes), tr => new PrimitiveType(tr, this.typeGraph, kind), attributes, forwardingRef);
    }
    getStringType(attributes, stringTypes, forwardingRef) {
        const existingStringTypes = collectionUtils.mapFind(attributes, (_, k) => k === stringTypesTypeAttributeKind);
        assert((stringTypes === undefined) !== (existingStringTypes === undefined), "Must instantiate string type with one enum case attribute");
        if (existingStringTypes === undefined) {
            attributes = combineTypeAttributes("union", attributes, stringTypesTypeAttributeKind.makeAttributes(defined(stringTypes)));
        }
        return this.getOrAddType(() => primitiveTypeIdentity("string", attributes), tr => new PrimitiveType(tr, this.typeGraph, "string"), attributes, forwardingRef);
    }
    getEnumType(attributes, cases, forwardingRef) {
        return this.getOrAddType(() => enumTypeIdentity(attributes, cases), tr => new EnumType(tr, this.typeGraph, cases), attributes, forwardingRef);
    }
    makeClassProperty(tref, isOptional) {
        return new ClassProperty(tref, this.typeGraph, isOptional);
    }
    getUniqueObjectType(attributes, properties, additionalProperties, forwardingRef) {
        this.assertTypeRefGraph(additionalProperties);
        properties = collectionUtils.definedMap(properties, p => this.modifyPropertiesIfNecessary(p));
        return this.addType(forwardingRef, tref => new ObjectType(tref, this.typeGraph, "object", true, properties, additionalProperties), attributes);
    }
    getUniqueMapType(forwardingRef) {
        return this.addType(forwardingRef, tr => new MapType(tr, this.typeGraph, undefined), undefined);
    }
    getMapType(attributes, values, forwardingRef) {
        this.assertTypeRefGraph(values);
        return this.getOrAddType(() => mapTypeIdentify(attributes, values), tr => new MapType(tr, this.typeGraph, values), attributes, forwardingRef);
    }
    setObjectProperties(ref, properties, additionalProperties) {
        this.assertTypeRefGraph(additionalProperties);
        const type = derefTypeRef(ref, this.typeGraph);
        if (!(type instanceof ObjectType)) {
            return panic("Tried to set properties of non-object type");
        }
        type.setProperties(this.modifyPropertiesIfNecessary(properties), additionalProperties);
        this.registerType(type);
    }
    getUniqueArrayType(forwardingRef) {
        return this.addType(forwardingRef, tr => new ArrayType(tr, this.typeGraph, undefined), undefined);
    }
    getArrayType(attributes, items, forwardingRef) {
        this.assertTypeRefGraph(items);
        return this.getOrAddType(() => arrayTypeIdentity(attributes, items), tr => new ArrayType(tr, this.typeGraph, items), attributes, forwardingRef);
    }
    setArrayItems(ref, items) {
        this.assertTypeRefGraph(items);
        const type = derefTypeRef(ref, this.typeGraph);
        if (!(type instanceof ArrayType)) {
            return panic("Tried to set items of non-array type");
        }
        type.setItems(items);
        this.registerType(type);
    }
    modifyPropertiesIfNecessary(properties) {
        properties.forEach(p => this.assertTypeRefGraph(p.typeRef));
        if (this.canonicalOrder) {
            properties = collectionUtils.mapSortByKey(properties);
        }
        if (this._allPropertiesOptional) {
            properties = collectionUtils.mapMap(properties, cp => this.makeClassProperty(cp.typeRef, true));
        }
        return properties;
    }
    getClassType(attributes, properties, forwardingRef) {
        properties = this.modifyPropertiesIfNecessary(properties);
        return this.getOrAddType(() => classTypeIdentity(attributes, properties), tr => new ClassType(tr, this.typeGraph, false, properties), attributes, forwardingRef);
    }
    // FIXME: Maybe just distinguish between this and `getClassType`
    // via a flag?  That would make `ClassType.map` simpler.
    getUniqueClassType(attributes, isFixed, properties, forwardingRef) {
        properties = collectionUtils.definedMap(properties, p => this.modifyPropertiesIfNecessary(p));
        return this.addType(forwardingRef, tref => new ClassType(tref, this.typeGraph, isFixed, properties), attributes);
    }
    getUnionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.getOrAddType(() => unionTypeIdentity(attributes, members), tr => new UnionType(tr, this.typeGraph, members), attributes, forwardingRef);
    }
    // FIXME: why do we sometimes call this with defined members???
    getUniqueUnionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.addType(forwardingRef, tref => new UnionType(tref, this.typeGraph, members), attributes);
    }
    getIntersectionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.getOrAddType(() => intersectionTypeIdentity(attributes, members), tr => new IntersectionType(tr, this.typeGraph, members), attributes, forwardingRef);
    }
    // FIXME: why do we sometimes call this with defined members???
    getUniqueIntersectionType(attributes, members, forwardingRef) {
        this.assertTypeRefSetGraph(members);
        return this.addType(forwardingRef, tref => new IntersectionType(tref, this.typeGraph, members), attributes);
    }
    setSetOperationMembers(ref, members) {
        this.assertTypeRefSetGraph(members);
        const type = derefTypeRef(ref, this.typeGraph);
        if (!(type instanceof UnionType || type instanceof IntersectionType)) {
            return panic("Tried to set members of non-set-operation type");
        }
        type.setMembers(members);
        this.registerType(type);
    }
    setLostTypeAttributes() {
        return;
    }
}

function assertIsObject(t) {
    if (t instanceof ObjectType) {
        return t;
    }
    return panic("Supposed object type is not an object type");
}
function setOperationMembersRecursively(oneOrMany, combinationKind) {
    const setOperations = Array.isArray(oneOrMany) ? oneOrMany : [oneOrMany];
    const kind = setOperations[0].kind;
    const includeAny = kind !== "intersection";
    const processedSetOperations = new Set();
    const members = new Set();
    let attributes = emptyTypeAttributes;
    function process(t) {
        if (t.kind === kind) {
            const so = t;
            if (processedSetOperations.has(so))
                return;
            processedSetOperations.add(so);
            if (combinationKind !== undefined) {
                attributes = combineTypeAttributes(combinationKind, attributes, t.getAttributes());
            }
            for (const m of so.members) {
                process(m);
            }
        }
        else if (includeAny || t.kind !== "any") {
            members.add(t);
        }
        else {
            if (combinationKind !== undefined) {
                attributes = combineTypeAttributes(combinationKind, attributes, t.getAttributes());
            }
        }
    }
    for (const so of setOperations) {
        process(so);
    }
    return [members, attributes];
}
function makeGroupsToFlatten(setOperations, include) {
    const typeGroups = new collectionUtils.EqualityMap();
    for (const u of setOperations) {
        // FIXME: We shouldn't have to make a new set here once we got rid
        // of immutable.
        const members = new Set(setOperationMembersRecursively(u, undefined)[0]);
        if (include !== undefined) {
            if (!include(members))
                continue;
        }
        let maybeSet = typeGroups.get(members);
        if (maybeSet === undefined) {
            maybeSet = new Set();
            if (members.size === 1) {
                maybeSet.add(defined(collectionUtils.iterableFirst(members)));
            }
        }
        maybeSet.add(u);
        typeGroups.set(members, maybeSet);
    }
    return Array.from(typeGroups.values()).map(ts => Array.from(ts));
}
function combineTypeAttributesOfTypes(combinationKind, types) {
    return combineTypeAttributes(combinationKind, Array.from(types).map(t => t.getAttributes()));
}
function isAnyOrNull(t) {
    return t.kind === "any" || t.kind === "null";
}
// FIXME: We shouldn't have to sort here.  This is just because we're not getting
// back the right order from JSON Schema, due to the changes the intersection types
// introduced.
function removeNullFromUnion(t, sortBy = false) {
    function sort(s) {
        if (sortBy === false)
            return s;
        if (sortBy === true)
            return collectionUtils.setSortBy(s, m => m.kind);
        return collectionUtils.setSortBy(s, sortBy);
    }
    const nullType = t.findMember("null");
    if (nullType === undefined) {
        return [null, sort(t.members)];
    }
    return [nullType, sort(collectionUtils.setFilter(t.members, m => m.kind !== "null"))];
}
function removeNullFromType(t) {
    if (t.kind === "null") {
        return [t, new Set()];
    }
    if (!(t instanceof UnionType)) {
        return [null, new Set([t])];
    }
    return removeNullFromUnion(t);
}
function nullableFromUnion(t) {
    const [hasNull, nonNulls] = removeNullFromUnion(t);
    if (hasNull === null)
        return null;
    if (nonNulls.size !== 1)
        return null;
    return defined(collectionUtils.iterableFirst(nonNulls));
}
function nonNullTypeCases(t) {
    return removeNullFromType(t)[1];
}
// FIXME: Give this an appropriate name, considering that we don't distinguish
// between named and non-named types anymore.
function isNamedType(t) {
    return ["class", "union", "enum", "object"].includes(t.kind);
}
function separateNamedTypes(types) {
    const objects = collectionUtils.setFilter(types, t => t.kind === "object" || t.kind === "class");
    const enums = collectionUtils.setFilter(types, t => t instanceof EnumType);
    const unions = collectionUtils.setFilter(types, t => t instanceof UnionType);
    return { objects, enums, unions };
}
function directlyReachableTypes(t, setForType) {
    const set = setForType(t);
    if (set !== null)
        return set;
    return collectionUtils.setUnion(...Array.from(t.getNonAttributeChildren()).map(c => directlyReachableTypes(c, setForType)));
}
function directlyReachableSingleNamedType(type) {
    const definedTypes = directlyReachableTypes(type, t => {
        if ((!(t instanceof UnionType) && isNamedType(t)) ||
            (t instanceof UnionType && nullableFromUnion(t) === null)) {
            return new Set([t]);
        }
        return null;
    });
    assert(definedTypes.size <= 1, "Cannot have more than one defined type per top-level");
    return collectionUtils.iterableFirst(definedTypes);
}
function stringTypesForType(t) {
    assert(t.kind === "string", "Only strings can have string types");
    const stringTypes = stringTypesTypeAttributeKind.tryGetInAttributes(t.getAttributes());
    if (stringTypes === undefined) {
        return panic("All strings must have a string type attribute");
    }
    return stringTypes;
}
function matchTypeExhaustive(t, noneType, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, objectType, enumType, unionType, transformedStringType) {
    if (t.isPrimitive()) {
        if (isPrimitiveStringTypeKind(t.kind)) {
            if (t.kind === "string") {
                return stringType(t);
            }
            return transformedStringType(t);
        }
        const kind = t.kind;
        const f = {
            none: noneType,
            any: anyType,
            null: nullType,
            bool: boolType,
            integer: integerType,
            double: doubleType
        }[kind];
        if (f !== undefined)
            return f(t);
        return assertNever(f);
    }
    else if (t instanceof ArrayType)
        return arrayType(t);
    else if (t instanceof ClassType)
        return classType(t);
    else if (t instanceof MapType)
        return mapType(t);
    else if (t instanceof ObjectType)
        return objectType(t);
    else if (t instanceof EnumType)
        return enumType(t);
    else if (t instanceof UnionType)
        return unionType(t);
    return panic(`Unknown type ${t.kind}`);
}
function matchType(type, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, enumType, unionType, transformedStringType) {
    function typeNotSupported(t) {
        return panic(`Unsupported type ${t.kind} in non-exhaustive match`);
    }
    return matchTypeExhaustive(type, typeNotSupported, anyType, nullType, boolType, integerType, doubleType, stringType, arrayType, classType, mapType, typeNotSupported, enumType, unionType, transformedStringType !== null && transformedStringType !== void 0 ? transformedStringType : typeNotSupported);
}
function matchCompoundType(t, arrayType, classType, mapType, objectType, unionType) {
    function ignore(_) {
        return;
    }
    matchTypeExhaustive(t, ignore, ignore, ignore, ignore, ignore, ignore, ignore, arrayType, classType, mapType, objectType, ignore, unionType, ignore);
}

class TypeReconstituter {
    constructor(_typeBuilder, _makeClassUnique, _typeAttributes, _forwardingRef, _register) {
        this._typeBuilder = _typeBuilder;
        this._makeClassUnique = _makeClassUnique;
        this._typeAttributes = _typeAttributes;
        this._forwardingRef = _forwardingRef;
        this._register = _register;
        this._wasUsed = false;
        this._typeRef = undefined;
    }
    builderForNewType() {
        assert(!this._wasUsed, "TypeReconstituter used more than once");
        this._wasUsed = true;
        return this._typeBuilder;
    }
    builderForSetting() {
        assert(this._wasUsed && this._typeRef !== undefined, "Can't set type members before constructing a type");
        return this._typeBuilder;
    }
    getResult() {
        if (this._typeRef === undefined) {
            return panic("Type was not reconstituted");
        }
        return this._typeRef;
    }
    // FIXME: Do registration automatically.
    register(tref) {
        assert(this._typeRef === undefined, "Cannot register a type twice");
        this._typeRef = tref;
        this._register(tref);
    }
    registerAndAddAttributes(tref) {
        this._typeBuilder.addAttributes(tref, this._typeAttributes);
        this.register(tref);
    }
    lookup(trefs) {
        assert(!this._wasUsed, "Cannot lookup constituents after building type");
        if (isTypeRef(trefs)) {
            return this._typeBuilder.lookupTypeRefs([trefs], undefined, false);
        }
        else {
            const maybeRefs = Array.from(trefs).map(tref => this._typeBuilder.lookupTypeRefs([tref], undefined, false));
            if (maybeRefs.some(tref => tref === undefined))
                return undefined;
            return maybeRefs;
        }
    }
    lookupMap(trefs) {
        const resultValues = this.lookup(trefs.values());
        if (resultValues === undefined)
            return undefined;
        assert(resultValues.length === trefs.size, "Didn't get back the correct number of types");
        const result = new Map();
        let i = 0;
        for (const k of trefs.keys()) {
            result.set(k, resultValues[i]);
            i += 1;
        }
        return result;
    }
    reconstitute(trefs) {
        assert(this._wasUsed, "Cannot reconstitute constituents before building type");
        if (isTypeRef(trefs)) {
            return this._typeBuilder.reconstituteTypeRef(trefs);
        }
        else {
            return Array.from(trefs).map(tref => this._typeBuilder.reconstituteTypeRef(tref));
        }
    }
    reconstituteMap(trefs) {
        return collectionUtils.mapMap(trefs, tref => this._typeBuilder.reconstituteTypeRef(tref));
    }
    getPrimitiveType(kind) {
        this.register(this.builderForNewType().getPrimitiveType(kind, this._typeAttributes, this._forwardingRef));
    }
    getEnumType(cases) {
        this.register(this.builderForNewType().getEnumType(this._typeAttributes, cases, this._forwardingRef));
    }
    getUniqueMapType() {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueMapType(this._forwardingRef));
    }
    getMapType(values) {
        this.register(this.builderForNewType().getMapType(this._typeAttributes, values, this._forwardingRef));
    }
    getUniqueArrayType() {
        this.registerAndAddAttributes(this.builderForNewType().getUniqueArrayType(this._forwardingRef));
    }
    getArrayType(items) {
        this.register(this.builderForNewType().getArrayType(this._typeAttributes, items, this._forwardingRef));
    }
    setArrayItems(items) {
        this.builderForSetting().setArrayItems(this.getResult(), items);
    }
    makeClassProperty(tref, isOptional) {
        return this._typeBuilder.makeClassProperty(tref, isOptional);
    }
    getObjectType(properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
    }
    getUniqueObjectType(properties, additionalProperties) {
        this.register(this.builderForNewType().getUniqueObjectType(this._typeAttributes, properties, additionalProperties, this._forwardingRef));
    }
    getClassType(properties) {
        if (this._makeClassUnique) {
            this.getUniqueClassType(false, properties);
            return;
        }
        this.register(this.builderForNewType().getClassType(this._typeAttributes, properties, this._forwardingRef));
    }
    getUniqueClassType(isFixed, properties) {
        this.register(this.builderForNewType().getUniqueClassType(this._typeAttributes, isFixed, properties, this._forwardingRef));
    }
    setObjectProperties(properties, additionalProperties) {
        this.builderForSetting().setObjectProperties(this.getResult(), properties, additionalProperties);
    }
    getUnionType(members) {
        this.register(this.builderForNewType().getUnionType(this._typeAttributes, members, this._forwardingRef));
    }
    getUniqueUnionType() {
        this.register(this.builderForNewType().getUniqueUnionType(this._typeAttributes, undefined, this._forwardingRef));
    }
    getIntersectionType(members) {
        this.register(this.builderForNewType().getIntersectionType(this._typeAttributes, members, this._forwardingRef));
    }
    getUniqueIntersectionType(members) {
        this.register(this.builderForNewType().getUniqueIntersectionType(this._typeAttributes, members, this._forwardingRef));
    }
    setSetOperationMembers(members) {
        this.builderForSetting().setSetOperationMembers(this.getResult(), members);
    }
}
class BaseGraphRewriteBuilder extends TypeBuilder {
    constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrint) {
        super(originalGraph.serial + 1, stringTypeMapping, alphabetizeProperties, false, false, graphHasProvenanceAttributes);
        this.originalGraph = originalGraph;
        this.debugPrint = debugPrint;
        this.reconstitutedTypes = new Map();
        this._lostTypeAttributes = false;
        this._printIndent = 0;
    }
    withForwardingRef(maybeForwardingRef, typeCreator) {
        if (maybeForwardingRef !== undefined) {
            return typeCreator(maybeForwardingRef);
        }
        const forwardingRef = this.reserveTypeRef();
        const actualRef = typeCreator(forwardingRef);
        assert(actualRef === forwardingRef, "Type creator didn't return its forwarding ref");
        return actualRef;
    }
    reconstituteType(t, attributes, forwardingRef) {
        return this.reconstituteTypeRef(t.typeRef, attributes, forwardingRef);
    }
    reconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        const maybeRef = this.lookupTypeRefs([originalRef], maybeForwardingRef);
        if (maybeRef !== undefined) {
            if (attributes !== undefined) {
                this.addAttributes(maybeRef, attributes);
            }
            return maybeRef;
        }
        return this.forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef);
    }
    reconstituteTypeAttributes(attributes) {
        return collectionUtils.mapMap(attributes, (v, a) => a.reconstitute(this, v));
    }
    assertTypeRefsToReconstitute(typeRefs, forwardingRef) {
        assert(typeRefs.length > 0, "Must have at least one type to reconstitute");
        for (const originalRef of typeRefs) {
            assertTypeRefGraph(originalRef, this.originalGraph);
        }
        if (forwardingRef !== undefined) {
            assertTypeRefGraph(forwardingRef, this.typeGraph);
        }
    }
    changeDebugPrintIndent(delta) {
        this._printIndent += delta;
    }
    get debugPrintIndentation() {
        return indentationString(this._printIndent);
    }
    finish() {
        for (const [name, t] of this.originalGraph.topLevels) {
            this.addTopLevel(name, this.reconstituteType(t));
        }
        return super.finish();
    }
    setLostTypeAttributes() {
        this._lostTypeAttributes = true;
    }
    get lostTypeAttributes() {
        return this._lostTypeAttributes;
    }
}
class GraphRemapBuilder extends BaseGraphRewriteBuilder {
    constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, _map, debugPrintRemapping) {
        super(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintRemapping);
        this._map = _map;
        this._attributeSources = new Map();
        for (const [source, target] of _map) {
            let maybeSources = this._attributeSources.get(target);
            if (maybeSources === undefined) {
                maybeSources = [target];
                this._attributeSources.set(target, maybeSources);
            }
            maybeSources.push(source);
        }
    }
    makeIdentity(_maker) {
        return undefined;
    }
    getMapTarget(tref) {
        const maybeType = this._map.get(derefTypeRef(tref, this.originalGraph));
        if (maybeType === undefined)
            return tref;
        assert(this._map.get(maybeType) === undefined, "We have a type that's remapped to a remapped type");
        return maybeType.typeRef;
    }
    addForwardingIntersection(_forwardingRef, _tref) {
        return panic("We can't add forwarding intersections when we're removing forwarding intersections");
    }
    lookupTypeRefs(typeRefs, forwardingRef) {
        assert(forwardingRef === undefined, "We can't have a forwarding ref when we remap");
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        const first = this.reconstitutedTypes.get(typeRefIndex(this.getMapTarget(typeRefs[0])));
        if (first === undefined)
            return undefined;
        for (let i = 1; i < typeRefs.length; i++) {
            const other = this.reconstitutedTypes.get(typeRefIndex(this.getMapTarget(typeRefs[i])));
            if (first !== other)
                return undefined;
        }
        return first;
    }
    forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        originalRef = this.getMapTarget(originalRef);
        const index = typeRefIndex(originalRef);
        assert(this.reconstitutedTypes.get(index) === undefined, "Type has already been reconstituted");
        assert(maybeForwardingRef === undefined, "We can't have a forwarding ref when we remap");
        return this.withForwardingRef(undefined, forwardingRef => {
            this.reconstitutedTypes.set(index, forwardingRef);
            if (this.debugPrint) {
                console.log(`${this.debugPrintIndentation}reconstituting ${index} as ${typeRefIndex(forwardingRef)}`);
                this.changeDebugPrintIndent(1);
            }
            const [originalType, originalAttributes] = typeAndAttributesForTypeRef(originalRef, this.originalGraph);
            const attributeSources = this._attributeSources.get(originalType);
            if (attributes === undefined) {
                attributes = emptyTypeAttributes;
            }
            if (attributeSources === undefined) {
                attributes = combineTypeAttributes("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
            }
            else {
                attributes = combineTypeAttributes("union", attributes, this.reconstituteTypeAttributes(combineTypeAttributesOfTypes("union", attributeSources)));
            }
            const newAttributes = attributes;
            const reconstituter = new TypeReconstituter(this, this.canonicalOrder, newAttributes, forwardingRef, tref => {
                assert(tref === forwardingRef, "Reconstituted type as a different ref");
                if (this.debugPrint) {
                    this.changeDebugPrintIndent(-1);
                    console.log(`${this.debugPrintIndentation}reconstituted ${index} as ${typeRefIndex(tref)}`);
                }
            });
            originalType.reconstitute(reconstituter, this.canonicalOrder);
            return reconstituter.getResult();
        });
    }
}
class GraphRewriteBuilder extends BaseGraphRewriteBuilder {
    constructor(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, setsToReplace, debugPrintReconstitution, _replacer) {
        super(originalGraph, stringTypeMapping, alphabetizeProperties, graphHasProvenanceAttributes, debugPrintReconstitution);
        this._replacer = _replacer;
        this._reconstitutedUnions = new collectionUtils.EqualityMap();
        this._setsToReplaceByMember = new Map();
        for (const types of setsToReplace) {
            const set = new Set(types);
            for (const t of set) {
                const index = t.index;
                assert(!this._setsToReplaceByMember.has(index), "A type is member of more than one set to be replaced");
                this._setsToReplaceByMember.set(index, set);
            }
        }
    }
    registerUnion(typeRefs, reconstituted) {
        const set = new Set(typeRefs);
        assert(!this._reconstitutedUnions.has(set), "Cannot register reconstituted set twice");
        this._reconstitutedUnions.set(set, reconstituted);
    }
    replaceSet(typesToReplace, maybeForwardingRef) {
        return this.withForwardingRef(maybeForwardingRef, forwardingRef => {
            if (this.debugPrint) {
                console.log(`${this.debugPrintIndentation}replacing set ${Array.from(typesToReplace)
                    .map(t => t.index.toString())
                    .join(",")} as ${typeRefIndex(forwardingRef)}`);
                this.changeDebugPrintIndent(1);
            }
            for (const t of typesToReplace) {
                const originalRef = t.typeRef;
                const index = typeRefIndex(originalRef);
                this.reconstitutedTypes.set(index, forwardingRef);
                this._setsToReplaceByMember.delete(index);
            }
            const result = this._replacer(typesToReplace, this, forwardingRef);
            assert(result === forwardingRef, "The forwarding ref got lost when replacing");
            if (this.debugPrint) {
                this.changeDebugPrintIndent(-1);
                console.log(`${this.debugPrintIndentation}replaced set ${Array.from(typesToReplace)
                    .map(t => t.index.toString())
                    .join(",")} as ${typeRefIndex(forwardingRef)}`);
            }
            return result;
        });
    }
    forceReconstituteTypeRef(originalRef, attributes, maybeForwardingRef) {
        const [originalType, originalAttributes] = typeAndAttributesForTypeRef(originalRef, this.originalGraph);
        const index = typeRefIndex(originalRef);
        if (this.debugPrint) {
            console.log(`${this.debugPrintIndentation}reconstituting ${index}`);
            this.changeDebugPrintIndent(1);
        }
        if (attributes === undefined) {
            attributes = this.reconstituteTypeAttributes(originalAttributes);
        }
        else {
            attributes = combineTypeAttributes("union", attributes, this.reconstituteTypeAttributes(originalAttributes));
        }
        const reconstituter = new TypeReconstituter(this, this.canonicalOrder, attributes, maybeForwardingRef, tref => {
            if (this.debugPrint) {
                this.changeDebugPrintIndent(-1);
                console.log(`${this.debugPrintIndentation}reconstituted ${index} as ${typeRefIndex(tref)}`);
            }
            if (maybeForwardingRef !== undefined) {
                assert(tref === maybeForwardingRef, "We didn't pass the forwarding ref");
            }
            const alreadyReconstitutedType = this.reconstitutedTypes.get(index);
            if (alreadyReconstitutedType === undefined) {
                this.reconstitutedTypes.set(index, tref);
            }
            else {
                assert(tref === alreadyReconstitutedType, "We reconstituted a type twice differently");
            }
        });
        originalType.reconstitute(reconstituter, this.canonicalOrder);
        return reconstituter.getResult();
    }
    /*
     public reconstituteTypeUnmodified(originalType: Type): TypeRef {
        const reconstituter = new TypeReconstituter(
            this,
            this.alphabetizeProperties,
            emptyTypeAttributes,
            undefined,
            () => {}
        );
        originalType.reconstitute(reconstituter);
        return reconstituter.getResult();
    }
    */
    // If the union of these type refs have been, or are supposed to be, reconstituted to
    // one target type, return it.  Otherwise return undefined.
    lookupTypeRefs(typeRefs, forwardingRef, replaceSet = true) {
        this.assertTypeRefsToReconstitute(typeRefs, forwardingRef);
        // Check whether we have already reconstituted them.  That means ensuring
        // that they all have the same target type.
        let maybeRef = this.reconstitutedTypes.get(typeRefIndex(typeRefs[0]));
        if (maybeRef !== undefined && maybeRef !== forwardingRef) {
            let allEqual = true;
            for (let i = 1; i < typeRefs.length; i++) {
                if (this.reconstitutedTypes.get(typeRefIndex(typeRefs[i])) !== maybeRef) {
                    allEqual = false;
                    break;
                }
            }
            if (allEqual) {
                return this.forwardIfNecessary(forwardingRef, maybeRef);
            }
        }
        // Has this been reconstituted as a set?
        maybeRef = this._reconstitutedUnions.get(new Set(typeRefs));
        if (maybeRef !== undefined && maybeRef !== forwardingRef) {
            return this.forwardIfNecessary(forwardingRef, maybeRef);
        }
        // Is this set requested to be replaced?  If not, we're out of options.
        const maybeSet = this._setsToReplaceByMember.get(typeRefIndex(typeRefs[0]));
        if (maybeSet === undefined) {
            return undefined;
        }
        for (let i = 1; i < typeRefs.length; i++) {
            if (this._setsToReplaceByMember.get(typeRefIndex(typeRefs[i])) !== maybeSet) {
                return undefined;
            }
        }
        // Yes, this set is requested to be replaced, so do it.
        if (!replaceSet)
            return undefined;
        return this.replaceSet(maybeSet, forwardingRef);
    }
}

const indexBits = 26;
const indexMask = (1 << indexBits) - 1;
const serialBits = 31 - indexBits;
const serialMask = (1 << serialBits) - 1;
function isTypeRef(x) {
    return typeof x === "number";
}
function makeTypeRef(graph, index) {
    assert(index <= indexMask, "Too many types in graph");
    return ((graph.serial & serialMask) << indexBits) | index;
}
function typeRefIndex(tref) {
    return tref & indexMask;
}
function assertTypeRefGraph(tref, graph) {
    assert(((tref >> indexBits) & serialMask) === (graph.serial & serialMask), "Mixing the wrong type reference and graph");
}
function getGraph(graphOrBuilder) {
    if (graphOrBuilder instanceof TypeGraph)
        return graphOrBuilder;
    return graphOrBuilder.originalGraph;
}
function derefTypeRef(tref, graphOrBuilder) {
    const graph = getGraph(graphOrBuilder);
    assertTypeRefGraph(tref, graph);
    return graph.typeAtIndex(typeRefIndex(tref));
}
function attributesForTypeRef(tref, graphOrBuilder) {
    const graph = getGraph(graphOrBuilder);
    assertTypeRefGraph(tref, graph);
    return graph.atIndex(typeRefIndex(tref))[1];
}
function typeAndAttributesForTypeRef(tref, graphOrBuilder) {
    const graph = getGraph(graphOrBuilder);
    assertTypeRefGraph(tref, graph);
    return graph.atIndex(typeRefIndex(tref));
}
class TypeAttributeStore {
    constructor(_typeGraph, _values) {
        this._typeGraph = _typeGraph;
        this._values = _values;
        this._topLevelValues = new Map();
    }
    getTypeIndex(t) {
        const tref = t.typeRef;
        assertTypeRefGraph(tref, this._typeGraph);
        return typeRefIndex(tref);
    }
    attributesForType(t) {
        const index = this.getTypeIndex(t);
        const maybeAttributes = this._values[index];
        if (maybeAttributes !== undefined) {
            return maybeAttributes;
        }
        return emptyTypeAttributes;
    }
    attributesForTopLevel(name) {
        const maybeAttributes = this._topLevelValues.get(name);
        if (maybeAttributes !== undefined) {
            return maybeAttributes;
        }
        return emptyTypeAttributes;
    }
    setInMap(attributes, kind, value) {
        // FIXME: This is potentially super slow
        return new Map(attributes).set(kind, value);
    }
    set(kind, t, value) {
        const index = this.getTypeIndex(t);
        while (index >= this._values.length) {
            this._values.push(undefined);
        }
        this._values[index] = this.setInMap(this.attributesForType(t), kind, value);
    }
    setForTopLevel(kind, topLevelName, value) {
        this._topLevelValues.set(topLevelName, this.setInMap(this.attributesForTopLevel(topLevelName), kind, value));
    }
    tryGetInMap(attributes, kind) {
        return attributes.get(kind);
    }
    tryGet(kind, t) {
        return this.tryGetInMap(this.attributesForType(t), kind);
    }
    tryGetForTopLevel(kind, topLevelName) {
        return this.tryGetInMap(this.attributesForTopLevel(topLevelName), kind);
    }
}
class TypeAttributeStoreView {
    constructor(_attributeStore, _definition) {
        this._attributeStore = _attributeStore;
        this._definition = _definition;
    }
    set(t, value) {
        this._attributeStore.set(this._definition, t, value);
    }
    setForTopLevel(name, value) {
        this._attributeStore.setForTopLevel(this._definition, name, value);
    }
    tryGet(t) {
        return this._attributeStore.tryGet(this._definition, t);
    }
    get(t) {
        return defined(this.tryGet(t));
    }
    tryGetForTopLevel(name) {
        return this._attributeStore.tryGetForTopLevel(this._definition, name);
    }
    getForTopLevel(name) {
        return defined(this.tryGetForTopLevel(name));
    }
}
class TypeGraph {
    constructor(typeBuilder, serial, _haveProvenanceAttributes) {
        this.serial = serial;
        this._haveProvenanceAttributes = _haveProvenanceAttributes;
        this._attributeStore = undefined;
        // FIXME: OrderedMap?  We lose the order in PureScript right now, though,
        // and maybe even earlier in the TypeScript driver.
        this._topLevels = new Map();
        this._parents = undefined;
        this._printOnRewrite = false;
        this._typeBuilder = typeBuilder;
    }
    get isFrozen() {
        return this._typeBuilder === undefined;
    }
    get attributeStore() {
        return defined(this._attributeStore);
    }
    freeze(topLevels, types, typeAttributes) {
        assert(!this.isFrozen, "Tried to freeze TypeGraph a second time");
        for (const t of types) {
            assertTypeRefGraph(t.typeRef, this);
        }
        this._attributeStore = new TypeAttributeStore(this, typeAttributes);
        // The order of these three statements matters.  If we set _typeBuilder
        // to undefined before we deref the TypeRefs, then we need to set _types
        // before, also, because the deref will call into typeAtIndex, which requires
        // either a _typeBuilder or a _types.
        this._types = types;
        this._typeBuilder = undefined;
        this._topLevels = collectionUtils.mapMap(topLevels, tref => derefTypeRef(tref, this));
    }
    get topLevels() {
        assert(this.isFrozen, "Cannot get top-levels from a non-frozen graph");
        return this._topLevels;
    }
    typeAtIndex(index) {
        if (this._typeBuilder !== undefined) {
            return this._typeBuilder.typeAtIndex(index);
        }
        return defined(this._types)[index];
    }
    atIndex(index) {
        if (this._typeBuilder !== undefined) {
            return this._typeBuilder.atIndex(index);
        }
        const t = this.typeAtIndex(index);
        return [t, defined(this._attributeStore).attributesForType(t)];
    }
    filterTypes(predicate) {
        const seen = new Set();
        let types = [];
        function addFromType(t) {
            if (seen.has(t))
                return;
            seen.add(t);
            const required = predicate === undefined || predicate(t);
            if (required) {
                types.push(t);
            }
            for (const c of t.getChildren()) {
                addFromType(c);
            }
        }
        for (const [, t] of this.topLevels) {
            addFromType(t);
        }
        return new Set(types);
    }
    allNamedTypes() {
        return this.filterTypes(isNamedType);
    }
    allNamedTypesSeparated() {
        const types = this.allNamedTypes();
        return separateNamedTypes(types);
    }
    allProvenance() {
        assert(this._haveProvenanceAttributes);
        const view = new TypeAttributeStoreView(this.attributeStore, provenanceTypeAttributeKind);
        const sets = Array.from(this.allTypesUnordered()).map(t => {
            const maybeSet = view.tryGet(t);
            if (maybeSet !== undefined)
                return maybeSet;
            return new Set();
        });
        const result = new Set();
        collectionUtils.setUnionManyInto(result, sets);
        return result;
    }
    setPrintOnRewrite() {
        this._printOnRewrite = true;
    }
    checkLostTypeAttributes(builder, newGraph) {
        if (!this._haveProvenanceAttributes || builder.lostTypeAttributes)
            return;
        const oldProvenance = this.allProvenance();
        const newProvenance = newGraph.allProvenance();
        if (oldProvenance.size !== newProvenance.size) {
            const difference = collectionUtils.setSubtract(oldProvenance, newProvenance);
            const indexes = Array.from(difference);
            return messageError("IRTypeAttributesNotPropagated", { count: difference.size, indexes });
        }
    }
    printRewrite(title) {
        if (!this._printOnRewrite)
            return;
        console.log(`\n# ${title}`);
    }
    // Each array in `replacementGroups` is a bunch of types to be replaced by a
    // single new type.  `replacer` is a function that takes a group and a
    // TypeBuilder, and builds a new type with that builder that replaces the group.
    // That particular TypeBuilder will have to take as inputs types in the old
    // graph, but return types in the new graph.  Recursive types must be handled
    // carefully.
    rewrite(title, stringTypeMapping, alphabetizeProperties, replacementGroups, debugPrintReconstitution, replacer, force = false) {
        this.printRewrite(title);
        if (!force && replacementGroups.length === 0)
            return this;
        const builder = new GraphRewriteBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, replacementGroups, debugPrintReconstitution, replacer);
        const newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
            newGraph.setPrintOnRewrite();
            newGraph.printGraph();
        }
        if (!builder.didAddForwardingIntersection)
            return newGraph;
        return removeIndirectionIntersections(newGraph, stringTypeMapping, debugPrintReconstitution);
    }
    remap(title, stringTypeMapping, alphabetizeProperties, map, debugPrintRemapping, force = false) {
        this.printRewrite(title);
        if (!force && map.size === 0)
            return this;
        const builder = new GraphRemapBuilder(this, stringTypeMapping, alphabetizeProperties, this._haveProvenanceAttributes, map, debugPrintRemapping);
        const newGraph = builder.finish();
        this.checkLostTypeAttributes(builder, newGraph);
        if (this._printOnRewrite) {
            newGraph.setPrintOnRewrite();
            newGraph.printGraph();
        }
        assert(!builder.didAddForwardingIntersection);
        return newGraph;
    }
    garbageCollect(alphabetizeProperties, debugPrintReconstitution) {
        const newGraph = this.remap("GC", getNoStringTypeMapping(), alphabetizeProperties, new Map(), debugPrintReconstitution, true);
        return newGraph;
    }
    rewriteFixedPoint(alphabetizeProperties, debugPrintReconstitution) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let graph = this;
        for (;;) {
            const newGraph = this.rewrite("fixed-point", getNoStringTypeMapping(), alphabetizeProperties, [], debugPrintReconstitution, mustNotHappen, true);
            if (graph.allTypesUnordered().size === newGraph.allTypesUnordered().size) {
                return graph;
            }
            graph = newGraph;
        }
    }
    allTypesUnordered() {
        assert(this.isFrozen, "Tried to get all graph types before it was frozen");
        return new Set(defined(this._types));
    }
    makeGraph(invertDirection, childrenOfType) {
        return new Graph(defined(this._types), invertDirection, childrenOfType);
    }
    getParentsOfType(t) {
        assertTypeRefGraph(t.typeRef, this);
        if (this._parents === undefined) {
            const parents = defined(this._types).map(_ => new Set());
            for (const p of this.allTypesUnordered()) {
                for (const c of p.getChildren()) {
                    const index = c.index;
                    parents[index] = parents[index].add(p);
                }
            }
            this._parents = parents;
        }
        return this._parents[t.index];
    }
    printGraph() {
        const types = defined(this._types);
        for (let i = 0; i < types.length; i++) {
            const t = types[i];
            const parts = [];
            parts.push(`${t.debugPrintKind}${t.hasNames ? ` ${t.getCombinedName()}` : ""}`);
            const children = t.getChildren();
            if (children.size > 0) {
                parts.push(`children ${Array.from(children)
                    .map(c => c.index)
                    .join(",")}`);
            }
            for (const [kind, value] of t.getAttributes()) {
                const maybeString = kind.stringify(value);
                if (maybeString !== undefined) {
                    parts.push(maybeString);
                }
            }
            console.log(`${i}: ${parts.join(" | ")}`);
        }
    }
}
function noneToAny(graph, stringTypeMapping, debugPrintReconstitution) {
    const noneTypes = collectionUtils.setFilter(graph.allTypesUnordered(), t => t.kind === "none");
    if (noneTypes.size === 0) {
        return graph;
    }
    assert(noneTypes.size === 1, "Cannot have more than one none type");
    return graph.rewrite("none to any", stringTypeMapping, false, [Array.from(noneTypes)], debugPrintReconstitution, (types, builder, forwardingRef) => {
        const attributes = combineTypeAttributesOfTypes("union", types);
        const tref = builder.getPrimitiveType("any", attributes, forwardingRef);
        return tref;
    });
}
function optionalToNullable(graph, stringTypeMapping, debugPrintReconstitution) {
    function rewriteClass(c, builder, forwardingRef) {
        const properties = collectionUtils.mapMap(c.getProperties(), (p, name) => {
            const t = p.type;
            let ref;
            if (!p.isOptional || t.isNullable) {
                ref = builder.reconstituteType(t);
            }
            else {
                const nullType = builder.getPrimitiveType("null");
                let members;
                if (t instanceof UnionType) {
                    members = collectionUtils.setMap(t.members, m => builder.reconstituteType(m)).add(nullType);
                }
                else {
                    members = new Set([builder.reconstituteType(t), nullType]);
                }
                const attributes = namesTypeAttributeKind.setDefaultInAttributes(t.getAttributes(), () => TypeNames.make(new Set([name]), new Set(), true));
                ref = builder.getUnionType(attributes, members);
            }
            return builder.makeClassProperty(ref, p.isOptional);
        });
        if (c.isFixed) {
            return builder.getUniqueClassType(c.getAttributes(), true, properties, forwardingRef);
        }
        else {
            return builder.getClassType(c.getAttributes(), properties, forwardingRef);
        }
    }
    const classesWithOptional = collectionUtils.setFilter(graph.allTypesUnordered(), t => t instanceof ClassType && collectionUtils.mapSome(t.getProperties(), p => p.isOptional));
    const replacementGroups = Array.from(classesWithOptional).map(c => [c]);
    if (classesWithOptional.size === 0) {
        return graph;
    }
    return graph.rewrite("optional to nullable", stringTypeMapping, false, replacementGroups, debugPrintReconstitution, (setOfClass, builder, forwardingRef) => {
        assert(setOfClass.size === 1);
        const c = defined(collectionUtils.iterableFirst(setOfClass));
        return rewriteClass(c, builder, forwardingRef);
    });
}
function removeIndirectionIntersections(graph, stringTypeMapping, debugPrintRemapping) {
    const map = [];
    for (const t of graph.allTypesUnordered()) {
        if (!(t instanceof IntersectionType))
            continue;
        const seen = new Set([t]);
        let current = t;
        while (current.members.size === 1) {
            const member = defined(collectionUtils.iterableFirst(current.members));
            if (!(member instanceof IntersectionType)) {
                map.push([t, member]);
                break;
            }
            if (seen.has(member)) {
                // FIXME: Technically, this is an any type.
                return panic("There's a cycle of intersection types");
            }
            seen.add(member);
            current = member;
        }
    }
    return graph.remap("remove indirection intersections", stringTypeMapping, false, new Map(map), debugPrintRemapping);
}

/**
 * All the transformed string type kinds and the JSON Schema formats and
 * primitive type kinds they map to.  Not all transformed string types map to
 * primitive types.  Date-time types, for example, stand on their own, but
 * stringified integers map to integers.
 */
const transformedStringTypeTargetTypeKinds = {
    date: { jsonSchema: "date", primitive: undefined },
    time: { jsonSchema: "time", primitive: undefined },
    "date-time": { jsonSchema: "date-time", primitive: undefined },
    uuid: { jsonSchema: "uuid", primitive: undefined },
    uri: { jsonSchema: "uri", primitive: undefined, attributesProducer: uriInferenceAttributesProducer },
    "integer-string": { jsonSchema: "integer", primitive: "integer" },
    "bool-string": { jsonSchema: "boolean", primitive: "bool" }
};
const transformedStringTypeTargetTypeKindsMap = collectionUtils.mapFromObject(transformedStringTypeTargetTypeKinds);
const transformedStringTypeKinds = new Set(Object.getOwnPropertyNames(transformedStringTypeTargetTypeKinds));
function isPrimitiveStringTypeKind(kind) {
    return kind === "string" || collectionUtils.hasOwnProperty(transformedStringTypeTargetTypeKinds, kind);
}
function targetTypeKindForTransformedStringTypeKind(kind) {
    const target = transformedStringTypeTargetTypeKindsMap.get(kind);
    if (target === undefined)
        return undefined;
    return target.primitive;
}
function isNumberTypeKind(kind) {
    return kind === "integer" || kind === "double";
}
function isPrimitiveTypeKind(kind) {
    if (isPrimitiveStringTypeKind(kind))
        return true;
    if (isNumberTypeKind(kind))
        return true;
    return kind === "none" || kind === "any" || kind === "null" || kind === "bool";
}
function triviallyStructurallyCompatible(x, y) {
    if (x.index === y.index)
        return true;
    if (x.kind === "none" || y.kind === "none")
        return true;
    return false;
}
class TypeIdentity {
    constructor(_kind, 
    // FIXME: strongly type this
    _components) {
        this._kind = _kind;
        this._components = _components;
        let h = collectionUtils.hashCodeInit;
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this._kind));
        for (const c of _components) {
            h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(c));
        }
        this._hashCode = h;
    }
    equals(other) {
        if (!(other instanceof TypeIdentity))
            return false;
        if (this._kind !== other._kind)
            return false;
        const n = this._components.length;
        assert(n === other._components.length, "Components of a type kind's identity must have the same length");
        for (let i = 0; i < n; i++) {
            if (!collectionUtils.areEqual(this._components[i], other._components[i]))
                return false;
        }
        return true;
    }
    hashCode() {
        return this._hashCode;
    }
}
class Type {
    constructor(typeRef, graph) {
        this.typeRef = typeRef;
        this.graph = graph;
    }
    get index() {
        return typeRefIndex(this.typeRef);
    }
    getChildren() {
        let result = this.getNonAttributeChildren();
        for (const [k, v] of this.getAttributes()) {
            if (k.children === undefined)
                continue;
            collectionUtils.setUnionInto(result, k.children(v));
        }
        return result;
    }
    getAttributes() {
        return attributesForTypeRef(this.typeRef, this.graph);
    }
    get hasNames() {
        return namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()) !== undefined;
    }
    getNames() {
        return defined(namesTypeAttributeKind.tryGetInAttributes(this.getAttributes()));
    }
    getCombinedName() {
        return this.getNames().combinedName;
    }
    get debugPrintKind() {
        return this.kind;
    }
    equals(other) {
        if (!(other instanceof Type))
            return false;
        return this.typeRef === other.typeRef;
    }
    hashCode() {
        return collectionUtils.hashCodeOf(this.typeRef);
    }
    structurallyCompatible(other, conflateNumbers = false) {
        function kindsCompatible(kind1, kind2) {
            if (kind1 === kind2)
                return true;
            if (!conflateNumbers)
                return false;
            if (kind1 === "integer")
                return kind2 === "double";
            if (kind1 === "double")
                return kind2 === "integer";
            return false;
        }
        if (triviallyStructurallyCompatible(this, other))
            return true;
        if (!kindsCompatible(this.kind, other.kind))
            return false;
        const workList = [[this, other]];
        // This contains a set of pairs which are the type pairs
        // we have already determined to be equal.  We can't just
        // do comparison recursively because types can have cycles.
        const done = [];
        let failed;
        const queue = (x, y) => {
            if (triviallyStructurallyCompatible(x, y))
                return true;
            if (!kindsCompatible(x.kind, y.kind)) {
                failed = true;
                return false;
            }
            workList.push([x, y]);
            return true;
        };
        while (workList.length > 0) {
            let [a, b] = defined(workList.pop());
            if (a.index > b.index) {
                [a, b] = [b, a];
            }
            if (!a.isPrimitive()) {
                let ai = a.index;
                let bi = b.index;
                let found = false;
                for (const [dai, dbi] of done) {
                    if (dai === ai && dbi === bi) {
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;
                done.push([ai, bi]);
            }
            failed = false;
            if (!a.structuralEqualityStep(b, conflateNumbers, queue))
                return false;
            if (failed)
                return false;
        }
        return true;
    }
    getParentTypes() {
        return this.graph.getParentsOfType(this);
    }
    getAncestorsNotInSet(set) {
        const workList = [this];
        const processed = new Set();
        const ancestors = new Set();
        for (;;) {
            const t = workList.pop();
            if (t === undefined)
                break;
            const parents = t.getParentTypes();
            console.log(`${parents.size} parents`);
            for (const p of parents) {
                if (processed.has(p))
                    continue;
                processed.add(p);
                if (set.has(p.typeRef)) {
                    console.log(`adding ${p.kind}`);
                    workList.push(p);
                }
                else {
                    console.log(`found ${p.kind}`);
                    ancestors.add(p);
                }
            }
        }
        return ancestors;
    }
}
function hasUniqueIdentityAttributes(attributes) {
    return collectionUtils.mapSome(attributes, (v, ta) => ta.requiresUniqueIdentity(v));
}
function identityAttributes(attributes) {
    return collectionUtils.mapFilter(attributes, (_, kind) => kind.inIdentity);
}
function primitiveTypeIdentity(kind, attributes) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return new TypeIdentity(kind, [identityAttributes(attributes)]);
}
class PrimitiveType extends Type {
    constructor(typeRef, graph, kind) {
        super(typeRef, graph);
        this.kind = kind;
    }
    get isNullable() {
        return this.kind === "null" || this.kind === "any" || this.kind === "none";
    }
    isPrimitive() {
        return true;
    }
    getNonAttributeChildren() {
        return new Set();
    }
    get identity() {
        return primitiveTypeIdentity(this.kind, this.getAttributes());
    }
    reconstitute(builder) {
        builder.getPrimitiveType(this.kind);
    }
    structuralEqualityStep(_other, _conflateNumbers, _queue) {
        return true;
    }
}
function arrayTypeIdentity(attributes, itemsRef) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return new TypeIdentity("array", [identityAttributes(attributes), itemsRef]);
}
class ArrayType extends Type {
    constructor(typeRef, graph, _itemsRef) {
        super(typeRef, graph);
        this._itemsRef = _itemsRef;
        this.kind = "array";
    }
    setItems(itemsRef) {
        if (this._itemsRef !== undefined) {
            return panic("Can only set array items once");
        }
        this._itemsRef = itemsRef;
    }
    getItemsRef() {
        if (this._itemsRef === undefined) {
            return panic("Array items accessed before they were set");
        }
        return this._itemsRef;
    }
    get items() {
        return derefTypeRef(this.getItemsRef(), this.graph);
    }
    getNonAttributeChildren() {
        return new Set([this.items]);
    }
    get isNullable() {
        return false;
    }
    isPrimitive() {
        return false;
    }
    get identity() {
        return arrayTypeIdentity(this.getAttributes(), this.getItemsRef());
    }
    reconstitute(builder) {
        const itemsRef = this.getItemsRef();
        const maybeItems = builder.lookup(itemsRef);
        if (maybeItems === undefined) {
            builder.getUniqueArrayType();
            builder.setArrayItems(builder.reconstitute(this.getItemsRef()));
        }
        else {
            builder.getArrayType(maybeItems);
        }
    }
    structuralEqualityStep(other, _conflateNumbers, queue) {
        return queue(this.items, other.items);
    }
}
class GenericClassProperty {
    constructor(typeData, isOptional) {
        this.typeData = typeData;
        this.isOptional = isOptional;
    }
    equals(other) {
        if (!(other instanceof GenericClassProperty)) {
            return false;
        }
        return collectionUtils.areEqual(this.typeData, other.typeData) && this.isOptional === other.isOptional;
    }
    hashCode() {
        return collectionUtils.hashCodeOf(this.typeData) + (this.isOptional ? 17 : 23);
    }
}
class ClassProperty extends GenericClassProperty {
    constructor(typeRef, graph, isOptional) {
        super(typeRef, isOptional);
        this.graph = graph;
    }
    get typeRef() {
        return this.typeData;
    }
    get type() {
        return derefTypeRef(this.typeRef, this.graph);
    }
}
function objectTypeIdentify(kind, attributes, properties, additionalPropertiesRef) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return new TypeIdentity(kind, [identityAttributes(attributes), properties, additionalPropertiesRef]);
}
function classTypeIdentity(attributes, properties) {
    return objectTypeIdentify("class", attributes, properties, undefined);
}
function mapTypeIdentify(attributes, additionalPropertiesRef) {
    return objectTypeIdentify("map", attributes, new Map(), additionalPropertiesRef);
}
class ObjectType extends Type {
    constructor(typeRef, graph, kind, isFixed, _properties, _additionalPropertiesRef) {
        super(typeRef, graph);
        this.kind = kind;
        this.isFixed = isFixed;
        this._properties = _properties;
        this._additionalPropertiesRef = _additionalPropertiesRef;
        if (kind === "map") {
            if (_properties !== undefined) {
                assert(_properties.size === 0);
            }
            assert(!isFixed);
        }
        else if (kind === "class") {
            assert(_additionalPropertiesRef === undefined);
        }
        else {
            assert(isFixed);
        }
    }
    setProperties(properties, additionalPropertiesRef) {
        assert(this._properties === undefined, "Tried to set object properties twice");
        if (this instanceof MapType) {
            assert(properties.size === 0, "Cannot set properties on map type");
        }
        if (this instanceof ClassType) {
            assert(additionalPropertiesRef === undefined, "Cannot set additional properties of class type");
        }
        this._properties = properties;
        this._additionalPropertiesRef = additionalPropertiesRef;
    }
    getProperties() {
        return defined(this._properties);
    }
    getSortedProperties() {
        return collectionUtils.mapSortByKey(this.getProperties());
    }
    getAdditionalPropertiesRef() {
        assert(this._properties !== undefined, "Properties are not set yet");
        return this._additionalPropertiesRef;
    }
    getAdditionalProperties() {
        const tref = this.getAdditionalPropertiesRef();
        if (tref === undefined)
            return undefined;
        return derefTypeRef(tref, this.graph);
    }
    getNonAttributeChildren() {
        const types = collectionUtils.mapSortToArray(this.getProperties(), (_, k) => k).map(([_, p]) => p.type);
        const additionalProperties = this.getAdditionalProperties();
        if (additionalProperties !== undefined) {
            types.push(additionalProperties);
        }
        return new Set(types);
    }
    get isNullable() {
        return false;
    }
    isPrimitive() {
        return false;
    }
    get identity() {
        if (this.isFixed)
            return undefined;
        return objectTypeIdentify(this.kind, this.getAttributes(), this.getProperties(), this.getAdditionalPropertiesRef());
    }
    reconstitute(builder, canonicalOrder) {
        const sortedProperties = this.getSortedProperties();
        const propertiesInNewOrder = canonicalOrder ? sortedProperties : this.getProperties();
        const maybePropertyTypes = builder.lookupMap(collectionUtils.mapMap(sortedProperties, cp => cp.typeRef));
        const maybeAdditionalProperties = collectionUtils.definedMap(this._additionalPropertiesRef, r => builder.lookup(r));
        if (maybePropertyTypes !== undefined &&
            (maybeAdditionalProperties !== undefined || this._additionalPropertiesRef === undefined)) {
            const properties = collectionUtils.mapMap(propertiesInNewOrder, (cp, n) => builder.makeClassProperty(defined(maybePropertyTypes.get(n)), cp.isOptional));
            switch (this.kind) {
                case "object":
                    assert(this.isFixed);
                    builder.getObjectType(properties, maybeAdditionalProperties);
                    break;
                case "map":
                    builder.getMapType(defined(maybeAdditionalProperties));
                    break;
                case "class":
                    if (this.isFixed) {
                        builder.getUniqueClassType(true, properties);
                    }
                    else {
                        builder.getClassType(properties);
                    }
                    break;
                default:
                    return panic(`Invalid object type kind ${this.kind}`);
            }
        }
        else {
            switch (this.kind) {
                case "object":
                    assert(this.isFixed);
                    builder.getUniqueObjectType(undefined, undefined);
                    break;
                case "map":
                    builder.getUniqueMapType();
                    break;
                case "class":
                    builder.getUniqueClassType(this.isFixed, undefined);
                    break;
                default:
                    return panic(`Invalid object type kind ${this.kind}`);
            }
            const reconstitutedTypes = collectionUtils.mapMap(sortedProperties, cp => builder.reconstitute(cp.typeRef));
            const properties = collectionUtils.mapMap(propertiesInNewOrder, (cp, n) => builder.makeClassProperty(defined(reconstitutedTypes.get(n)), cp.isOptional));
            const additionalProperties = collectionUtils.definedMap(this._additionalPropertiesRef, r => builder.reconstitute(r));
            builder.setObjectProperties(properties, additionalProperties);
        }
    }
    structuralEqualityStep(other, _conflateNumbers, queue) {
        const pa = this.getProperties();
        const pb = other.getProperties();
        if (pa.size !== pb.size)
            return false;
        let failed = false;
        for (const [name, cpa] of pa) {
            const cpb = pb.get(name);
            if (cpb === undefined || cpa.isOptional !== cpb.isOptional || !queue(cpa.type, cpb.type)) {
                failed = true;
                return false;
            }
        }
        if (failed)
            return false;
        const thisAdditionalProperties = this.getAdditionalProperties();
        const otherAdditionalProperties = other.getAdditionalProperties();
        if ((thisAdditionalProperties === undefined) !== (otherAdditionalProperties === undefined))
            return false;
        if (thisAdditionalProperties === undefined || otherAdditionalProperties === undefined)
            return true;
        return queue(thisAdditionalProperties, otherAdditionalProperties);
    }
}
class ClassType extends ObjectType {
    constructor(typeRef, graph, isFixed, properties) {
        super(typeRef, graph, "class", isFixed, properties, undefined);
    }
}
class MapType extends ObjectType {
    constructor(typeRef, graph, valuesRef) {
        super(typeRef, graph, "map", false, collectionUtils.definedMap(valuesRef, () => new Map()), valuesRef);
    }
    // FIXME: Remove and use `getAdditionalProperties()` instead.
    get values() {
        return defined(this.getAdditionalProperties());
    }
}
function enumTypeIdentity(attributes, cases) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return new TypeIdentity("enum", [identityAttributes(attributes), cases]);
}
class EnumType extends Type {
    constructor(typeRef, graph, cases) {
        super(typeRef, graph);
        this.cases = cases;
        this.kind = "enum";
    }
    get isNullable() {
        return false;
    }
    isPrimitive() {
        return false;
    }
    get identity() {
        return enumTypeIdentity(this.getAttributes(), this.cases);
    }
    getNonAttributeChildren() {
        return new Set();
    }
    reconstitute(builder) {
        builder.getEnumType(this.cases);
    }
    structuralEqualityStep(other, _conflateNumbers, _queue) {
        return collectionUtils.areEqual(this.cases, other.cases);
    }
}
function setOperationCasesEqual(typesA, typesB, conflateNumbers, membersEqual) {
    const ma = collectionUtils.toReadonlySet(typesA);
    const mb = collectionUtils.toReadonlySet(typesB);
    if (ma.size !== mb.size)
        return false;
    return collectionUtils.iterableEvery(ma, ta => {
        const tb = collectionUtils.iterableFind(mb, t => t.kind === ta.kind);
        if (tb !== undefined) {
            if (membersEqual(ta, tb))
                return true;
        }
        if (conflateNumbers) {
            if (ta.kind === "integer" && collectionUtils.iterableSome(mb, t => t.kind === "double"))
                return true;
            if (ta.kind === "double" && collectionUtils.iterableSome(mb, t => t.kind === "integer"))
                return true;
        }
        return false;
    });
}
function setOperationTypeIdentity(kind, attributes, memberRefs) {
    if (hasUniqueIdentityAttributes(attributes))
        return undefined;
    return new TypeIdentity(kind, [identityAttributes(attributes), memberRefs]);
}
function unionTypeIdentity(attributes, memberRefs) {
    return setOperationTypeIdentity("union", attributes, memberRefs);
}
function intersectionTypeIdentity(attributes, memberRefs) {
    return setOperationTypeIdentity("intersection", attributes, memberRefs);
}
class SetOperationType extends Type {
    constructor(typeRef, graph, kind, _memberRefs) {
        super(typeRef, graph);
        this.kind = kind;
        this._memberRefs = _memberRefs;
    }
    setMembers(memberRefs) {
        if (this._memberRefs !== undefined) {
            return panic("Can only set map members once");
        }
        this._memberRefs = memberRefs;
    }
    getMemberRefs() {
        if (this._memberRefs === undefined) {
            return panic("Map members accessed before they were set");
        }
        return this._memberRefs;
    }
    get members() {
        return collectionUtils.setMap(this.getMemberRefs(), tref => derefTypeRef(tref, this.graph));
    }
    get sortedMembers() {
        return this.getNonAttributeChildren();
    }
    getNonAttributeChildren() {
        // FIXME: We're assuming no two members of the same kind.
        return collectionUtils.setSortBy(this.members, t => t.kind);
    }
    isPrimitive() {
        return false;
    }
    get identity() {
        return setOperationTypeIdentity(this.kind, this.getAttributes(), this.getMemberRefs());
    }
    reconstituteSetOperation(builder, canonicalOrder, getType) {
        const sortedMemberRefs = collectionUtils.mapMap(this.sortedMembers.entries(), t => t.typeRef);
        const membersInOrder = canonicalOrder ? this.sortedMembers : this.members;
        const maybeMembers = builder.lookupMap(sortedMemberRefs);
        if (maybeMembers === undefined) {
            getType(undefined);
            const reconstituted = builder.reconstituteMap(sortedMemberRefs);
            builder.setSetOperationMembers(collectionUtils.setMap(membersInOrder, t => defined(reconstituted.get(t))));
        }
        else {
            getType(collectionUtils.setMap(membersInOrder, t => defined(maybeMembers.get(t))));
        }
    }
    structuralEqualityStep(other, conflateNumbers, queue) {
        return setOperationCasesEqual(this.members, other.members, conflateNumbers, queue);
    }
}
class IntersectionType extends SetOperationType {
    constructor(typeRef, graph, memberRefs) {
        super(typeRef, graph, "intersection", memberRefs);
    }
    get isNullable() {
        return panic("isNullable not implemented for IntersectionType");
    }
    reconstitute(builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, members => {
            if (members === undefined) {
                builder.getUniqueIntersectionType();
            }
            else {
                builder.getIntersectionType(members);
            }
        });
    }
}
class UnionType extends SetOperationType {
    constructor(typeRef, graph, memberRefs) {
        super(typeRef, graph, "union", memberRefs);
        if (memberRefs !== undefined) {
            messageAssert(memberRefs.size > 0, "IRNoEmptyUnions", {});
        }
    }
    setMembers(memberRefs) {
        messageAssert(memberRefs.size > 0, "IRNoEmptyUnions", {});
        super.setMembers(memberRefs);
    }
    get stringTypeMembers() {
        return collectionUtils.setFilter(this.members, t => isPrimitiveStringTypeKind(t.kind) || t.kind === "enum");
    }
    findMember(kind) {
        return collectionUtils.iterableFind(this.members, t => t.kind === kind);
    }
    get isNullable() {
        return this.findMember("null") !== undefined;
    }
    get isCanonical() {
        const members = this.members;
        if (members.size <= 1)
            return false;
        const kinds = collectionUtils.setMap(members, t => t.kind);
        if (kinds.size < members.size)
            return false;
        if (kinds.has("union") || kinds.has("intersection"))
            return false;
        if (kinds.has("none") || kinds.has("any"))
            return false;
        if (kinds.has("string") && kinds.has("enum"))
            return false;
        let numObjectTypes = 0;
        if (kinds.has("class"))
            numObjectTypes += 1;
        if (kinds.has("map"))
            numObjectTypes += 1;
        if (kinds.has("object"))
            numObjectTypes += 1;
        if (numObjectTypes > 1)
            return false;
        return true;
    }
    reconstitute(builder, canonicalOrder) {
        this.reconstituteSetOperation(builder, canonicalOrder, members => {
            if (members === undefined) {
                builder.getUniqueUnionType();
            }
            else {
                builder.getUnionType(members);
            }
        });
    }
}

function debugStringForType(t) {
    const target = followTargetType(t);
    if (t === target) {
        return t.kind;
    }
    return `${t.kind} (${target.kind})`;
}
function getNumberOfNodes(xfer) {
    return collectionUtils.definedMapWithDefault(xfer, 0, x => x.getNumberOfNodes());
}
class Transformer {
    constructor(kind, graph, sourceTypeRef) {
        this.kind = kind;
        this.graph = graph;
        this.sourceTypeRef = sourceTypeRef;
    }
    get sourceType() {
        return derefTypeRef(this.sourceTypeRef, this.graph);
    }
    /** This must return a newly constructed set. */
    getChildren() {
        return new Set([this.sourceType]);
    }
    getNumberOfNodes() {
        return 1;
    }
    equals(other) {
        return this.sourceTypeRef === other.sourceTypeRef;
    }
    hashCode() {
        return collectionUtils.hashCodeOf(this.sourceTypeRef);
    }
    debugDescription() {
        return `${debugStringForType(this.sourceType)} -> ${this.kind}`;
    }
    debugPrintContinuations(_indent) {
        return;
    }
    debugPrint(indent) {
        console.log(indentationString(indent) + this.debugDescription());
        this.debugPrintContinuations(indent + 1);
    }
}
class ProducerTransformer extends Transformer {
    constructor(kind, graph, sourceTypeRef, consumer) {
        super(kind, graph, sourceTypeRef);
        this.consumer = consumer;
    }
    getChildren() {
        const children = super.getChildren();
        if (this.consumer === undefined)
            return children;
        return collectionUtils.setUnionInto(children, this.consumer.getChildren());
    }
    getNumberOfNodes() {
        return super.getNumberOfNodes() + getNumberOfNodes(this.consumer);
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof ProducerTransformer))
            return false;
        return collectionUtils.areEqual(this.consumer, other.consumer);
    }
    hashCode() {
        const h = super.hashCode();
        return collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.consumer));
    }
    debugPrintContinuations(indent) {
        if (this.consumer === undefined)
            return;
        this.consumer.debugPrint(indent);
    }
}
class MatchTransformer extends Transformer {
    constructor(kind, graph, sourceTypeRef, transformer) {
        super(kind, graph, sourceTypeRef);
        this.transformer = transformer;
    }
    getChildren() {
        return collectionUtils.setUnionInto(super.getChildren(), this.transformer.getChildren());
    }
    getNumberOfNodes() {
        return super.getNumberOfNodes() + this.transformer.getNumberOfNodes();
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof MatchTransformer))
            return false;
        return this.transformer.equals(other.transformer);
    }
    hashCode() {
        const h = super.hashCode();
        return collectionUtils.addHashCode(h, this.transformer.hashCode());
    }
    debugPrintContinuations(indent) {
        this.transformer.debugPrint(indent);
    }
}
class DecodingTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer) {
        super("decode", graph, sourceTypeRef, consumer);
    }
    get canFail() {
        return false;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer !== undefined) {
            return panic("Reversing a decoding transformer cannot have a continuation");
        }
        if (this.consumer === undefined) {
            return new EncodingTransformer(this.graph, targetTypeRef);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new EncodingTransformer(this.graph, this.consumer.sourceTypeRef));
        }
    }
    reconstitute(builder) {
        return new DecodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        return other instanceof DecodingTransformer;
    }
}
class EncodingTransformer extends Transformer {
    constructor(graph, sourceTypeRef) {
        super("encode", graph, sourceTypeRef);
    }
    get canFail() {
        return false;
    }
    reverse(_targetTypeRef, _continuationTransformer) {
        return panic("Can't reverse encoding transformer");
    }
    reconstitute(builder) {
        return new EncodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof EncodingTransformer))
            return false;
        return true;
    }
}
class ArrayDecodingTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer, _itemTargetTypeRef, itemTransformer) {
        super("decode-array", graph, sourceTypeRef, consumer);
        this._itemTargetTypeRef = _itemTargetTypeRef;
        this.itemTransformer = itemTransformer;
    }
    getChildren() {
        const children = super.getChildren();
        children.add(this.itemTargetType);
        return collectionUtils.setUnionInto(children, this.itemTransformer.getChildren());
    }
    getNumberOfNodes() {
        return super.getNumberOfNodes() + this.itemTransformer.getNumberOfNodes();
    }
    get canFail() {
        return false;
    }
    get itemTargetType() {
        return derefTypeRef(this._itemTargetTypeRef, this.graph);
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer !== undefined) {
            return panic("Reversing a decoding transformer cannot have a continuation");
        }
        const itemTransformer = this.itemTransformer.reverse(this._itemTargetTypeRef, undefined);
        if (this.consumer === undefined) {
            return new ArrayEncodingTransformer(this.graph, targetTypeRef, this.itemTransformer.sourceTypeRef, itemTransformer);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new ArrayEncodingTransformer(this.graph, this.consumer.sourceTypeRef, this.itemTransformer.sourceTypeRef, itemTransformer));
        }
    }
    reconstitute(builder) {
        return new ArrayDecodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)), builder.reconstituteTypeRef(this._itemTargetTypeRef), this.itemTransformer.reconstitute(builder));
    }
    hashCode() {
        let h = super.hashCode();
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this._itemTargetTypeRef));
        h = collectionUtils.addHashCode(h, this.itemTransformer.hashCode());
        return h;
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof ArrayDecodingTransformer))
            return false;
        if (!collectionUtils.areEqual(this._itemTargetTypeRef, other._itemTargetTypeRef))
            return false;
        return this.itemTransformer.equals(other.itemTransformer);
    }
    debugPrintContinuations(indent) {
        this.itemTransformer.debugPrint(indent);
        super.debugPrintContinuations(indent);
    }
}
class ArrayEncodingTransformer extends Transformer {
    constructor(graph, sourceTypeRef, _itemTargetTypeRef, itemTransformer) {
        super("encode-array", graph, sourceTypeRef);
        this._itemTargetTypeRef = _itemTargetTypeRef;
        this.itemTransformer = itemTransformer;
    }
    getChildren() {
        const children = super.getChildren();
        children.add(this.itemTargetType);
        return collectionUtils.setUnionInto(children, this.itemTransformer.getChildren());
    }
    getNumberOfNodes() {
        return super.getNumberOfNodes() + this.itemTransformer.getNumberOfNodes();
    }
    get canFail() {
        return false;
    }
    get itemTargetType() {
        return derefTypeRef(this._itemTargetTypeRef, this.graph);
    }
    reverse(_targetTypeRef, _continuationTransformer) {
        return panic("Can't reverse array encoding transformer");
    }
    reconstitute(builder) {
        return new ArrayEncodingTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), builder.reconstituteTypeRef(this._itemTargetTypeRef), this.itemTransformer.reconstitute(builder));
    }
    hashCode() {
        let h = super.hashCode();
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this._itemTargetTypeRef));
        return collectionUtils.addHashCode(h, this.itemTransformer.hashCode());
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof ArrayEncodingTransformer))
            return false;
        if (!collectionUtils.areEqual(this._itemTargetTypeRef, other._itemTargetTypeRef))
            return false;
        return this.itemTransformer.equals(other.itemTransformer);
    }
    debugPrintContinuations(indent) {
        this.itemTransformer.debugPrint(indent);
        super.debugPrintContinuations(indent);
    }
}
class ChoiceTransformer extends Transformer {
    constructor(graph, sourceTypeRef, transformers) {
        super("choice", graph, sourceTypeRef);
        this.transformers = transformers;
        assert(transformers.length > 0, "Choice must have at least one transformer");
    }
    getChildren() {
        let children = super.getChildren();
        for (const xfer of this.transformers) {
            collectionUtils.setUnionInto(children, xfer.getChildren());
        }
        return children;
    }
    getNumberOfNodes() {
        let n = 0;
        for (const xfer of this.transformers) {
            n += xfer.getNumberOfNodes();
        }
        return super.getNumberOfNodes() + n;
    }
    get canFail() {
        return this.transformers.some(xfer => xfer.canFail);
    }
    reverse(targetTypeRef, continuationTransformer) {
        const transformers = this.transformers.map(xfer => xfer.reverse(targetTypeRef, continuationTransformer));
        if (transformers.every(xfer => xfer instanceof UnionMemberMatchTransformer)) {
            const memberMatchers = transformers;
            const first = memberMatchers[0];
            if (memberMatchers.every(xfer => first.memberType.equals(xfer.memberType))) {
                const subTransformers = memberMatchers.map(xfer => xfer.transformer);
                return new UnionMemberMatchTransformer(this.graph, targetTypeRef, new ChoiceTransformer(this.graph, subTransformers[0].sourceTypeRef, subTransformers), first.memberTypeRef);
            }
        }
        return new ChoiceTransformer(this.graph, targetTypeRef, transformers);
    }
    reconstitute(builder) {
        return new ChoiceTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformers.map(xfer => xfer.reconstitute(builder)));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof ChoiceTransformer))
            return false;
        return collectionUtils.areEqual(this.transformers, other.transformers);
    }
    hashCode() {
        const h = super.hashCode();
        return collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.transformers));
    }
    debugPrintContinuations(indent) {
        for (const xfer of this.transformers) {
            xfer.debugPrint(indent);
        }
    }
}
class DecodingChoiceTransformer extends Transformer {
    constructor(graph, sourceTypeRef, nullTransformer, integerTransformer, doubleTransformer, boolTransformer, stringTransformer, arrayTransformer, objectTransformer) {
        super("decoding-choice", graph, sourceTypeRef);
        this.nullTransformer = nullTransformer;
        this.integerTransformer = integerTransformer;
        this.doubleTransformer = doubleTransformer;
        this.boolTransformer = boolTransformer;
        this.stringTransformer = stringTransformer;
        this.arrayTransformer = arrayTransformer;
        this.objectTransformer = objectTransformer;
    }
    get transformers() {
        const transformers = [];
        function add(xfer) {
            if (xfer === undefined)
                return;
            transformers.push(xfer);
        }
        add(this.nullTransformer);
        add(this.integerTransformer);
        add(this.doubleTransformer);
        add(this.boolTransformer);
        add(this.stringTransformer);
        add(this.arrayTransformer);
        add(this.objectTransformer);
        return transformers;
    }
    getChildren() {
        let children = super.getChildren();
        for (const xfer of this.transformers) {
            collectionUtils.setUnionInto(children, xfer.getChildren());
        }
        return children;
    }
    getNumberOfNodes() {
        let n = super.getNumberOfNodes();
        for (const xfer of this.transformers) {
            n += getNumberOfNodes(xfer);
        }
        return n;
    }
    get canFail() {
        return false;
    }
    reverse(targetTypeRef, continuationTransformer) {
        assert(continuationTransformer === undefined, "Reversing a decoding transformer can't have a target transformer");
        let transformers = new Map();
        let memberMatchTransformers = new Map();
        function addCase(reversed) {
            if (reversed instanceof UnionMemberMatchTransformer) {
                const memberType = reversed.memberType;
                let arr = memberMatchTransformers.get(memberType);
                if (arr === undefined) {
                    arr = [];
                    memberMatchTransformers.set(memberType, arr);
                }
                arr.push(reversed);
            }
            else {
                const kind = reversed.sourceType.kind;
                let arr = transformers.get(kind);
                if (arr === undefined) {
                    arr = [];
                    transformers.set(kind, arr);
                }
                arr.push(reversed);
            }
        }
        function reverseAndAdd(transformer) {
            const reversed = transformer.reverse(targetTypeRef, undefined);
            let cases = [];
            // Flatten nested ChoiceTransformers
            if (reversed instanceof ChoiceTransformer) {
                cases = reversed.transformers;
            }
            else {
                cases = [reversed];
            }
            for (const xfer of cases) {
                addCase(xfer);
            }
        }
        // FIXME: Actually, keep all the failing transformers and put them first, then
        // finally do the simplest non-failing one.  Actually actually, maybe not, since
        // we're reversing to encode?  What's a case where this would be useful?
        // If there are non-failing transformers, we ignore the ones that can fail and
        // just pick the "simplest" non-failing one, being the one with the least number
        // of nodes.
        function filter(xfers) {
            assert(xfers.length > 0, "Must have at least one transformer");
            const nonfailing = xfers.filter(xfer => {
                // For member match transformers we're deciding between
                // multiple that match against the same member, so the fact
                // that the match can fail is not important, since if it fails
                // it will fail for all candidates.  The question is whether
                // its continuation can fail.
                if (xfer instanceof UnionMemberMatchTransformer) {
                    return !xfer.transformer.canFail;
                }
                else {
                    return !xfer.canFail;
                }
            });
            if (nonfailing.length === 0)
                return xfers;
            const smallest = collectionUtils.arraySortByInto(nonfailing.map(x => [x.getNumberOfNodes(), x]), ([c, _]) => c)[0][1];
            return [smallest];
        }
        this.transformers.forEach(reverseAndAdd);
        const allTransformers = Array.from(transformers.values()).concat(Array.from(memberMatchTransformers.values()));
        const resultingTransformers = [].concat(...allTransformers.map(filter));
        // No choice needed if there's only one
        if (resultingTransformers.length === 1) {
            return resultingTransformers[0];
        }
        return new ChoiceTransformer(this.graph, targetTypeRef, resultingTransformers);
    }
    reconstitute(builder) {
        function reconstitute(xf) {
            if (xf === undefined)
                return undefined;
            return xf.reconstitute(builder);
        }
        return new DecodingChoiceTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), reconstitute(this.nullTransformer), reconstitute(this.integerTransformer), reconstitute(this.doubleTransformer), reconstitute(this.boolTransformer), reconstitute(this.stringTransformer), reconstitute(this.arrayTransformer), reconstitute(this.objectTransformer));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof DecodingChoiceTransformer))
            return false;
        if (!collectionUtils.areEqual(this.nullTransformer, other.nullTransformer))
            return false;
        if (!collectionUtils.areEqual(this.integerTransformer, other.integerTransformer))
            return false;
        if (!collectionUtils.areEqual(this.doubleTransformer, other.doubleTransformer))
            return false;
        if (!collectionUtils.areEqual(this.boolTransformer, other.boolTransformer))
            return false;
        if (!collectionUtils.areEqual(this.stringTransformer, other.stringTransformer))
            return false;
        if (!collectionUtils.areEqual(this.arrayTransformer, other.arrayTransformer))
            return false;
        if (!collectionUtils.areEqual(this.objectTransformer, other.objectTransformer))
            return false;
        return true;
    }
    hashCode() {
        let h = super.hashCode();
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.nullTransformer));
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.integerTransformer));
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.doubleTransformer));
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.boolTransformer));
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.stringTransformer));
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.arrayTransformer));
        h = collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.objectTransformer));
        return h;
    }
    debugPrintContinuations(indent) {
        for (const xfer of this.transformers) {
            xfer.debugPrint(indent);
        }
    }
}
class UnionMemberMatchTransformer extends MatchTransformer {
    constructor(graph, sourceTypeRef, transformer, memberTypeRef) {
        super("union-member-match", graph, sourceTypeRef, transformer);
        this.memberTypeRef = memberTypeRef;
    }
    get sourceType() {
        const t = derefTypeRef(this.sourceTypeRef, this.graph);
        if (!(t instanceof UnionType)) {
            return panic("The source of a union member match transformer must be a union type");
        }
        return t;
    }
    get canFail() {
        return true;
    }
    get memberType() {
        return derefTypeRef(this.memberTypeRef, this.graph);
    }
    getChildren() {
        return super.getChildren().add(this.memberType);
    }
    reverse(_targetTypeRef, _continuationTransformer) {
        return panic("Can't reverse union member match transformer");
    }
    reconstitute(builder) {
        return new UnionMemberMatchTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformer.reconstitute(builder), builder.reconstituteTypeRef(this.memberTypeRef));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof UnionMemberMatchTransformer))
            return false;
        return this.memberTypeRef === other.memberTypeRef;
    }
    hashCode() {
        const h = super.hashCode();
        return collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.memberTypeRef));
    }
    debugDescription() {
        return `${super.debugDescription()} - member: ${debugStringForType(this.memberType)}`;
    }
}
/**
 * This matches strings and enum cases.
 */
class StringMatchTransformer extends MatchTransformer {
    constructor(graph, sourceTypeRef, transformer, stringCase) {
        super("string-match", graph, sourceTypeRef, transformer);
        this.stringCase = stringCase;
    }
    get sourceType() {
        const t = derefTypeRef(this.sourceTypeRef, this.graph);
        if (!(t instanceof EnumType) && !(t instanceof PrimitiveType && t.kind === "string")) {
            return panic("The source of a string match transformer must be an enum or string type");
        }
        return t;
    }
    get canFail() {
        return true;
    }
    reverse(targetTypeRef, continuationTransformer) {
        return this.transformer.reverse(targetTypeRef, new StringProducerTransformer(this.graph, this.transformer.sourceTypeRef, continuationTransformer, this.stringCase));
    }
    reconstitute(builder) {
        return new StringMatchTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), this.transformer.reconstitute(builder), this.stringCase);
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof StringMatchTransformer))
            return false;
        return this.stringCase !== other.stringCase;
    }
    hashCode() {
        const h = super.hashCode();
        return collectionUtils.addHashCode(h, collectionUtils.hashString(this.stringCase));
    }
    debugDescription() {
        return `${super.debugDescription()} - case: ${this.stringCase}`;
    }
}
class UnionInstantiationTransformer extends Transformer {
    constructor(graph, sourceTypeRef) {
        super("union-instantiation", graph, sourceTypeRef);
    }
    get canFail() {
        return false;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer === undefined) {
            return panic("Union instantiation transformer reverse must have a continuation");
        }
        return new UnionMemberMatchTransformer(this.graph, targetTypeRef, continuationTransformer, this.sourceTypeRef);
    }
    reconstitute(builder) {
        return new UnionInstantiationTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        return other instanceof UnionInstantiationTransformer;
    }
}
/**
 * Produces a string or an enum case.
 */
class StringProducerTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer, result) {
        super("string-producer", graph, sourceTypeRef, consumer);
        this.result = result;
    }
    get canFail() {
        return false;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (continuationTransformer === undefined) {
            return panic("Reversing a string producer transformer must have a continuation");
        }
        if (this.consumer === undefined) {
            return new StringMatchTransformer(this.graph, targetTypeRef, continuationTransformer, this.result);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new StringMatchTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.result));
        }
    }
    reconstitute(builder) {
        return new StringProducerTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)), this.result);
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        if (!(other instanceof StringProducerTransformer))
            return false;
        return this.result === other.result;
    }
    hashCode() {
        const h = super.hashCode();
        return collectionUtils.addHashCode(h, collectionUtils.hashCodeOf(this.consumer));
    }
    debugDescription() {
        return `${super.debugDescription()} - result: ${this.result}`;
    }
}
class ParseStringTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer) {
        super("parse-string", graph, sourceTypeRef, consumer);
    }
    get canFail() {
        return true;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === undefined) {
            return new StringifyTransformer(this.graph, targetTypeRef, continuationTransformer);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new StringifyTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer));
        }
    }
    reconstitute(builder) {
        return new ParseStringTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        return other instanceof ParseStringTransformer;
    }
}
class StringifyTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer) {
        super("stringify", graph, sourceTypeRef, consumer);
    }
    get canFail() {
        return false;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === undefined) {
            return new ParseStringTransformer(this.graph, targetTypeRef, continuationTransformer);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new ParseStringTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer));
        }
    }
    reconstitute(builder) {
        return new StringifyTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)));
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        return other instanceof StringifyTransformer;
    }
}
class MinMaxLengthCheckTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer, minLength, maxLength) {
        super("min-max-length-check", graph, sourceTypeRef, consumer);
        this.minLength = minLength;
        this.maxLength = maxLength;
    }
    get canFail() {
        return true;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === undefined) {
            return new MinMaxLengthCheckTransformer(this.graph, targetTypeRef, continuationTransformer, this.minLength, this.maxLength);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new MinMaxLengthCheckTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.minLength, this.maxLength));
        }
    }
    reconstitute(builder) {
        return new MinMaxLengthCheckTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)), this.minLength, this.maxLength);
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        return (other instanceof MinMaxLengthCheckTransformer &&
            this.minLength === other.minLength &&
            this.maxLength === other.maxLength);
    }
}
class MinMaxValueTransformer extends ProducerTransformer {
    constructor(graph, sourceTypeRef, consumer, minimum, maximum) {
        super("min-max-value-check", graph, sourceTypeRef, consumer);
        this.minimum = minimum;
        this.maximum = maximum;
    }
    get canFail() {
        return true;
    }
    reverse(targetTypeRef, continuationTransformer) {
        if (this.consumer === undefined) {
            return new MinMaxValueTransformer(this.graph, targetTypeRef, continuationTransformer, this.minimum, this.maximum);
        }
        else {
            return this.consumer.reverse(targetTypeRef, new MinMaxValueTransformer(this.graph, this.consumer.sourceTypeRef, continuationTransformer, this.minimum, this.maximum));
        }
    }
    reconstitute(builder) {
        return new MinMaxValueTransformer(builder.typeGraph, builder.reconstituteTypeRef(this.sourceTypeRef), collectionUtils.definedMap(this.consumer, xfer => xfer.reconstitute(builder)), this.minimum, this.maximum);
    }
    equals(other) {
        if (!super.equals(other))
            return false;
        return (other instanceof MinMaxValueTransformer && this.minimum === other.minimum && this.maximum === other.maximum);
    }
}
class Transformation {
    constructor(_graph, _targetTypeRef, transformer) {
        this._graph = _graph;
        this._targetTypeRef = _targetTypeRef;
        this.transformer = transformer;
    }
    get sourceType() {
        return this.transformer.sourceType;
    }
    get targetType() {
        return derefTypeRef(this._targetTypeRef, this._graph);
    }
    get reverse() {
        return new Transformation(this._graph, this.transformer.sourceTypeRef, this.transformer.reverse(this._targetTypeRef, undefined));
    }
    getChildren() {
        return this.transformer.getChildren().add(this.targetType);
    }
    reconstitute(builder) {
        return new Transformation(builder.typeGraph, builder.reconstituteTypeRef(this._targetTypeRef), this.transformer.reconstitute(builder));
    }
    equals(other) {
        if (!(other instanceof Transformation))
            return false;
        return this._targetTypeRef === other._targetTypeRef && this.transformer.equals(other.transformer);
    }
    hashCode() {
        let h = collectionUtils.hashCodeOf(this._targetTypeRef);
        h = collectionUtils.addHashCode(h, this.transformer.hashCode());
        return h;
    }
    debugPrint() {
        this.transformer.debugPrint(0);
        console.log(`-> ${debugStringForType(this.targetType)}`);
    }
}
class TransformationTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("transformation");
    }
    appliesToTypeKind(_kind) {
        return true;
    }
    get inIdentity() {
        return true;
    }
    children(xf) {
        return xf.getChildren();
    }
    reconstitute(builder, xf) {
        return xf.reconstitute(builder);
    }
    stringify(_) {
        return "transformation";
    }
}
const transformationTypeAttributeKind = new TransformationTypeAttributeKind();
function transformationForType(t) {
    return transformationTypeAttributeKind.tryGetInAttributes(t.getAttributes());
}
function followTargetType(t) {
    for (;;) {
        const xf = transformationForType(t);
        if (xf === undefined)
            return t;
        t = xf.targetType;
    }
}

class UniqueQueue {
    constructor() {
        this._present = new Set();
        this._queue = [];
        this._front = 0;
    }
    get size() {
        return this._queue.length - this._front;
    }
    get isEmpty() {
        return this.size <= 0;
    }
    push(v) {
        if (this._present.has(v))
            return;
        this._queue.push(v);
        this._present.add(v);
    }
    unshift() {
        assert(!this.isEmpty, "Trying to unshift from an empty queue");
        const v = this._queue[this._front];
        if (v === undefined) {
            return panic("Value should have been present in queue");
        }
        this._queue[this._front] = undefined;
        this._front += 1;
        this._present.delete(v);
        if (this._front > this.size) {
            this._queue = this._queue.slice(this._front);
            this._front = 0;
        }
        return v;
    }
}
// `gatherNames` infers names from given names and property names.
//
// 1. Propagate type and property names down to children.  Let's say
//    we start with JSON like this, and we name the top-level `TopLevel`:
//
//    {
//      "foos": [ [ { "bar": 123 } ] ]
//    }
//
//    We use a work-list algorithm to first add the name `TopLevel` to
//    the outermost class type.  Then we propagate the property name
//    `foos` to the outer array, which in turn propagates its singular
//    `foo` to the inner array type.  That tries to singularize `foo`,
//    but it's already singular, so `foo` is added as a name for the
//    inner class.  We also then add `bar` to the name of the integer
//    type.
//
// 2. Add "ancestor" alternatives and some "direct" alternatives.
//    Direct alternatives are those that don't contain any ancestor
//    names, whereas ancestor alternatives do. What we do here is add
//    names of the form `TopLevel_foo` and `TopLevel_foo_class` as
//    ancestor alternatives to the inner class, and `foo_element` as
//    a direct alternative, the latter because it's an element in an
//    array.
//
// 3. Add more direct alternatives to the type names.  The reason we're
//    doing this separately from step 2 is because step 2 only requires
//    iterating over the types, wheras this step iterates over
//    ancestor/descendant relationships.  In this case we would add
//    `TopLevel_class`, and `foo_class` to the outer and inner classes,
//    respectively.  We do similar stuff for all the other types.
//
// 4. For each type, set its inferred names to what we gathered in
//    step 1, and its alternatives to a union of its direct and ancestor
//    alternatives, gathered in steps 2 and 3.
function gatherNames(graph, destructive, debugPrint) {
    function setNames(t, tn) {
        graph.attributeStore.set(namesTypeAttributeKind, t, tn);
    }
    if (destructive) {
        for (const t of graph.allTypesUnordered()) {
            if (t.hasNames) {
                setNames(t, t.getNames().clearInferred());
            }
        }
    }
    const queue = new UniqueQueue();
    // null means there are too many
    const namesForType = new Map();
    function addNames(t, names) {
        // Always use the type's given names if it has some
        if (t.hasNames) {
            const originalNames = t.getNames();
            if (!originalNames.areInferred) {
                names = originalNames.names;
            }
        }
        const oldNames = namesForType.get(t);
        if (oldNames === null)
            return;
        let newNames;
        if (oldNames === undefined) {
            newNames = names;
        }
        else if (names === null) {
            newNames = null;
        }
        else {
            newNames = collectionUtils.setUnion(oldNames, names);
        }
        if (newNames !== null && newNames.size >= tooManyNamesThreshold) {
            newNames = null;
        }
        namesForType.set(t, newNames);
        const transformation = transformationForType(t);
        if (transformation !== undefined) {
            addNames(transformation.targetType, names);
        }
        if (oldNames !== undefined && newNames !== null) {
            if (oldNames.size === newNames.size) {
                return;
            }
        }
        else if (oldNames === newNames) {
            return;
        }
        queue.push(t);
    }
    for (const [name, t] of graph.topLevels) {
        addNames(t, new Set([name]));
    }
    while (!queue.isEmpty) {
        const t = queue.unshift();
        const names = defined(namesForType.get(t));
        if (t instanceof ObjectType) {
            const properties = t.getSortedProperties();
            for (const [propertyName, property] of properties) {
                addNames(property.type, new Set([propertyName]));
            }
            const values = t.getAdditionalProperties();
            if (values !== undefined) {
                addNames(values, names === null ? null : collectionUtils.setMap(names, pluralize__namespace.singular));
            }
        }
        else {
            matchCompoundType(t, arrayType => {
                addNames(arrayType.items, names === null ? null : collectionUtils.setMap(names, pluralize__namespace.singular));
            }, _classType => panic("We handled this above"), _mapType => panic("We handled this above"), _objectType => panic("We handled this above"), unionType => {
                const members = collectionUtils.setSortBy(unionType.members, member => member.kind);
                for (const memberType of members) {
                    addNames(memberType, names);
                }
            });
        }
    }
    if (debugPrint) {
        for (const t of graph.allTypesUnordered()) {
            const names = namesForType.get(t);
            if (names === undefined)
                return;
            const index = t.index;
            console.log(`${index}: ${names === null ? "*** too many ***" : Array.from(names).join(" ")}`);
        }
    }
    // null means there are too many
    const directAlternativesForType = new Map();
    const ancestorAlternativesForType = new Map();
    const pairsProcessed = new Map();
    function addAlternatives(existing, alternatives) {
        if (alternatives.length === 0) {
            return existing;
        }
        if (existing === undefined) {
            existing = new Set();
        }
        existing = collectionUtils.setUnion(existing, alternatives);
        if (existing.size < tooManyNamesThreshold) {
            return existing;
        }
        return null;
    }
    function processType(ancestor, t, alternativeSuffix) {
        const names = defined(namesForType.get(t));
        let processedEntry = pairsProcessed.get(ancestor);
        if (processedEntry === undefined)
            processedEntry = new Set();
        if (processedEntry.has(t))
            return;
        processedEntry.add(t);
        pairsProcessed.set(ancestor, processedEntry);
        const transformation = transformationForType(t);
        if (transformation !== undefined) {
            processType(ancestor, transformation.targetType, alternativeSuffix);
        }
        let ancestorAlternatives = ancestorAlternativesForType.get(t);
        let directAlternatives = directAlternativesForType.get(t);
        if (names === null) {
            ancestorAlternatives = null;
            directAlternatives = null;
        }
        else {
            if (ancestor !== undefined && ancestorAlternatives !== null) {
                const ancestorNames = namesForType.get(ancestor);
                if (ancestorNames === null) {
                    ancestorAlternatives = null;
                }
                else if (ancestorNames !== undefined) {
                    const alternatives = [];
                    for (const name of names) {
                        alternatives.push(...Array.from(ancestorNames).map(an => `${an}_${name}`));
                        // FIXME: add alternatives with the suffix here, too?
                        alternatives.push(...Array.from(ancestorNames).map(an => `${an}_${name}_${t.kind}`));
                        // FIXME: add alternatives with the suffix here, too?
                    }
                    ancestorAlternatives = addAlternatives(ancestorAlternatives, alternatives);
                }
            }
            if (alternativeSuffix !== undefined && directAlternatives !== null) {
                const alternatives = [];
                for (const name of names) {
                    // FIXME: we should only add these for names we couldn't singularize
                    alternatives.push(`${name}_${alternativeSuffix}`);
                }
                directAlternatives = addAlternatives(directAlternatives, alternatives);
            }
        }
        if (ancestorAlternatives !== undefined) {
            ancestorAlternativesForType.set(t, ancestorAlternatives);
        }
        if (directAlternatives !== undefined) {
            directAlternativesForType.set(t, directAlternatives);
        }
        if (t instanceof ObjectType) {
            const properties = t.getSortedProperties();
            for (const [, property] of properties) {
                processType(t, property.type, undefined);
            }
            const values = t.getAdditionalProperties();
            if (values !== undefined) {
                processType(properties.size === 0 ? ancestor : t, values, "value");
            }
        }
        else {
            matchCompoundType(t, arrayType => {
                processType(ancestor, arrayType.items, "element");
            }, _classType => panic("We handled this above"), _mapType => panic("We handled this above"), _objectType => panic("We handled this above"), unionType => {
                const members = collectionUtils.setSortBy(unionType.members, member => member.kind);
                const unionHasGivenName = unionType.hasNames && !unionType.getNames().areInferred;
                const unionIsAncestor = unionHasGivenName || nullableFromUnion(unionType) === null;
                const ancestorForMembers = unionIsAncestor ? unionType : ancestor;
                for (const memberType of members) {
                    processType(ancestorForMembers, memberType, undefined);
                }
            });
        }
    }
    for (const [, t] of graph.topLevels) {
        processType(undefined, t, undefined);
    }
    for (const t of graph.allTypesUnordered()) {
        const names = namesForType.get(t);
        if (names === undefined)
            continue;
        if (names === null) {
            directAlternativesForType.set(t, null);
            continue;
        }
        let alternatives = directAlternativesForType.get(t);
        if (alternatives === null)
            continue;
        if (alternatives === undefined) {
            alternatives = new Set();
        }
        alternatives = collectionUtils.setUnion(alternatives, collectionUtils.setMap(names, name => `${name}_${t.kind}`));
        directAlternativesForType.set(t, alternatives);
    }
    for (const t of graph.allTypesUnordered()) {
        const names = namesForType.get(t);
        if (names === undefined)
            continue;
        let typeNames;
        if (names === null) {
            typeNames = new TooManyTypeNames(1);
        }
        else {
            const ancestorAlternatives = ancestorAlternativesForType.get(t);
            const directAlternatives = directAlternativesForType.get(t);
            let alternatives;
            if (ancestorAlternatives === null && directAlternatives === null) {
                alternatives = undefined;
            }
            else {
                if (directAlternatives !== null && directAlternatives !== undefined) {
                    alternatives = directAlternatives;
                }
                else {
                    alternatives = new Set();
                }
                if (ancestorAlternatives !== null && ancestorAlternatives !== undefined) {
                    alternatives = collectionUtils.setUnion(alternatives, ancestorAlternatives);
                }
            }
            typeNames = TypeNames.makeWithDistance(names, alternatives, destructive ? 1 : 10);
        }
        setNames(t, t.hasNames ? t.getNames().add([typeNames]) : typeNames);
    }
}

class AccessorNamesTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("accessorNames");
    }
    makeInferred(_) {
        return undefined;
    }
}
const accessorNamesTypeAttributeKind = new AccessorNamesTypeAttributeKind();
// Returns [name, isFixed].
function getFromEntry(entry, language) {
    if (typeof entry === "string")
        return [entry, false];
    const maybeForLanguage = entry.get(language);
    if (maybeForLanguage !== undefined)
        return [maybeForLanguage, true];
    const maybeWildcard = entry.get("*");
    if (maybeWildcard !== undefined)
        return [maybeWildcard, false];
    return undefined;
}
function lookupKey(accessors, key, language) {
    const entry = accessors.get(key);
    if (entry === undefined)
        return undefined;
    return getFromEntry(entry, language);
}
function objectPropertyNames(o, language) {
    const accessors = accessorNamesTypeAttributeKind.tryGetInAttributes(o.getAttributes());
    const map = o.getProperties();
    if (accessors === undefined)
        return collectionUtils.mapMap(map, _ => undefined);
    return collectionUtils.mapMap(map, (_cp, n) => lookupKey(accessors, n, language));
}
function enumCaseNames(e, language) {
    const accessors = accessorNamesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
    if (accessors === undefined)
        return collectionUtils.mapMap(e.cases.entries(), _ => undefined);
    return collectionUtils.mapMap(e.cases.entries(), c => lookupKey(accessors, c, language));
}
function getAccessorName(names, original) {
    const maybeName = names.get(original);
    if (maybeName === undefined)
        return [undefined, false];
    return maybeName;
}
// Union members can be recombined and reordered, and unions are combined as well, so
// we can't just store an array of accessor entries in a union, one array entry for each
// union member.  Instead, we give each union in the origin type graph a union identifier,
// and each union member type gets a map from union identifiers to accessor entries.
// That way, no matter how the types are recombined, if we find a union member, we can look
// up its union's identifier(s), and then look up the member's accessor entries for that
// identifier.  Of course we might find more than one, potentially conflicting.
class UnionIdentifierTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("unionIdentifier");
    }
    combine(arr) {
        return collectionUtils.setUnionManyInto(new Set(), arr);
    }
    makeInferred(_) {
        return new Set();
    }
}
const unionIdentifierTypeAttributeKind = new UnionIdentifierTypeAttributeKind();
let nextUnionIdentifier = 0;
function makeUnionIdentifierAttribute() {
    const attributes = unionIdentifierTypeAttributeKind.makeAttributes(new Set([nextUnionIdentifier]));
    nextUnionIdentifier += 1;
    return attributes;
}
class UnionMemberNamesTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("unionMemberNames");
    }
    combine(arr) {
        const result = new Map();
        for (const m of arr) {
            collectionUtils.mapMergeInto(result, m);
        }
        return result;
    }
}
const unionMemberNamesTypeAttributeKind = new UnionMemberNamesTypeAttributeKind();
function makeUnionMemberNamesAttribute(unionAttributes, entry) {
    const identifiers = defined(unionIdentifierTypeAttributeKind.tryGetInAttributes(unionAttributes));
    const map = collectionUtils.mapFromIterable(identifiers, _ => entry);
    return unionMemberNamesTypeAttributeKind.makeAttributes(map);
}
function unionMemberName(u, member, language) {
    const identifiers = unionIdentifierTypeAttributeKind.tryGetInAttributes(u.getAttributes());
    if (identifiers === undefined)
        return [undefined, false];
    const memberNames = unionMemberNamesTypeAttributeKind.tryGetInAttributes(member.getAttributes());
    if (memberNames === undefined)
        return [undefined, false];
    const names = new Set();
    const fixedNames = new Set();
    for (const i of identifiers) {
        const maybeEntry = memberNames.get(i);
        if (maybeEntry === undefined)
            continue;
        const maybeName = getFromEntry(maybeEntry, language);
        if (maybeName === undefined)
            continue;
        const [name, isNameFixed] = maybeName;
        if (isNameFixed) {
            fixedNames.add(name);
        }
        else {
            names.add(name);
        }
    }
    let size;
    let isFixed;
    let first = collectionUtils.iterableFirst(fixedNames);
    if (first !== undefined) {
        size = fixedNames.size;
        isFixed = true;
    }
    else {
        first = collectionUtils.iterableFirst(names);
        if (first === undefined)
            return [undefined, false];
        size = names.size;
        isFixed = false;
    }
    messageAssert(size === 1, "SchemaMoreThanOneUnionMemberName", { names: Array.from(names) });
    return [first, isFixed];
}
function isAccessorEntry(x) {
    if (typeof x === "string") {
        return true;
    }
    return isStringMap(x, (v) => typeof v === "string");
}
function makeAccessorEntry(ae) {
    if (typeof ae === "string")
        return ae;
    return collectionUtils.mapFromObject(ae);
}
function makeAccessorNames(x) {
    // FIXME: Do proper error reporting
    const stringMap = checkStringMap(x, isAccessorEntry);
    return collectionUtils.mapMap(collectionUtils.mapFromObject(stringMap), makeAccessorEntry);
}
function accessorNamesAttributeProducer(schema, canonicalRef, _types, cases) {
    if (typeof schema !== "object")
        return undefined;
    const maybeAccessors = schema["qt-accessors"];
    if (maybeAccessors === undefined)
        return undefined;
    if (cases === undefined) {
        return { forType: accessorNamesTypeAttributeKind.makeAttributes(makeAccessorNames(maybeAccessors)) };
    }
    else {
        const identifierAttribute = makeUnionIdentifierAttribute();
        const accessors = checkArray(maybeAccessors, isAccessorEntry);
        messageAssert(cases.length === accessors.length, "SchemaWrongAccessorEntryArrayLength", {
            operation: "oneOf",
            ref: canonicalRef.push("oneOf")
        });
        const caseAttributes = accessors.map(accessor => makeUnionMemberNamesAttribute(identifierAttribute, makeAccessorEntry(accessor)));
        return { forUnion: identifierAttribute, forCases: caseAttributes };
    }
}

function checkMinMaxConstraint(minmax) {
    const [min, max] = minmax;
    if (typeof min === "number" && typeof max === "number" && min > max) {
        return messageError("MiscInvalidMinMaxConstraint", { min, max });
    }
    if (min === undefined && max === undefined) {
        return undefined;
    }
    return minmax;
}
class MinMaxConstraintTypeAttributeKind extends TypeAttributeKind {
    constructor(name, _typeKinds, _minSchemaProperty, _maxSchemaProperty) {
        super(name);
        this._typeKinds = _typeKinds;
        this._minSchemaProperty = _minSchemaProperty;
        this._maxSchemaProperty = _maxSchemaProperty;
    }
    get inIdentity() {
        return true;
    }
    combine(arr) {
        assert(arr.length > 0);
        let [min, max] = arr[0];
        for (let i = 1; i < arr.length; i++) {
            const [otherMin, otherMax] = arr[i];
            if (typeof min === "number" && typeof otherMin === "number") {
                min = Math.min(min, otherMin);
            }
            else {
                min = undefined;
            }
            if (typeof max === "number" && typeof otherMax === "number") {
                max = Math.max(max, otherMax);
            }
            else {
                max = undefined;
            }
        }
        return checkMinMaxConstraint([min, max]);
    }
    intersect(arr) {
        assert(arr.length > 0);
        let [min, max] = arr[0];
        for (let i = 1; i < arr.length; i++) {
            const [otherMin, otherMax] = arr[i];
            if (typeof min === "number" && typeof otherMin === "number") {
                min = Math.max(min, otherMin);
            }
            else if (min === undefined) {
                min = otherMin;
            }
            if (typeof max === "number" && typeof otherMax === "number") {
                max = Math.min(max, otherMax);
            }
            else if (max === undefined) {
                max = otherMax;
            }
        }
        return checkMinMaxConstraint([min, max]);
    }
    makeInferred(_) {
        return undefined;
    }
    addToSchema(schema, t, attr) {
        if (this._typeKinds.has(t.kind))
            return;
        const [min, max] = attr;
        if (min !== undefined) {
            schema[this._minSchemaProperty] = min;
        }
        if (max !== undefined) {
            schema[this._maxSchemaProperty] = max;
        }
    }
    stringify([min, max]) {
        return `${min}-${max}`;
    }
}
const minMaxTypeAttributeKind = new MinMaxConstraintTypeAttributeKind("minMax", new Set(["integer", "double"]), "minimum", "maximum");
const minMaxLengthTypeAttributeKind = new MinMaxConstraintTypeAttributeKind("minMaxLength", new Set(["string"]), "minLength", "maxLength");
function producer(schema, minProperty, maxProperty) {
    if (!(typeof schema === "object"))
        return undefined;
    let min = undefined;
    let max = undefined;
    if (typeof schema[minProperty] === "number") {
        min = schema[minProperty];
    }
    if (typeof schema[maxProperty] === "number") {
        max = schema[maxProperty];
    }
    if (min === undefined && max === undefined)
        return undefined;
    return [min, max];
}
function minMaxAttributeProducer(schema, _ref, types) {
    if (!types.has("number") && !types.has("integer"))
        return undefined;
    const maybeMinMax = producer(schema, "minimum", "maximum");
    if (maybeMinMax === undefined)
        return undefined;
    return { forNumber: minMaxTypeAttributeKind.makeAttributes(maybeMinMax) };
}
function minMaxLengthAttributeProducer(schema, _ref, types) {
    if (!types.has("string"))
        return undefined;
    const maybeMinMaxLength = producer(schema, "minLength", "maxLength");
    if (maybeMinMaxLength === undefined)
        return undefined;
    return { forString: minMaxLengthTypeAttributeKind.makeAttributes(maybeMinMaxLength) };
}
function minMaxValueForType(t) {
    return minMaxTypeAttributeKind.tryGetInAttributes(t.getAttributes());
}
function minMaxLengthForType(t) {
    return minMaxLengthTypeAttributeKind.tryGetInAttributes(t.getAttributes());
}
class PatternTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("pattern");
    }
    get inIdentity() {
        return true;
    }
    combine(arr) {
        assert(arr.length > 0);
        return arr.map(p => `(${p})`).join("|");
    }
    intersect(_arr) {
        /** FIXME!!! what is the intersection of regexps? */
        return undefined;
    }
    makeInferred(_) {
        return undefined;
    }
    addToSchema(schema, t, attr) {
        if (t.kind !== "string")
            return;
        schema.pattern = attr;
    }
}
const patternTypeAttributeKind = new PatternTypeAttributeKind();
function patternAttributeProducer(schema, _ref, types) {
    if (!(typeof schema === "object"))
        return undefined;
    if (!types.has("string"))
        return undefined;
    const patt = schema.pattern;
    if (typeof patt !== "string")
        return undefined;
    return { forString: patternTypeAttributeKind.makeAttributes(patt) };
}
function patternForType(t) {
    return patternTypeAttributeKind.tryGetInAttributes(t.getAttributes());
}

class EnumValuesTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("enumValues");
    }
    makeInferred(_) {
        return undefined;
    }
}
const enumValuesTypeAttributeKind = new EnumValuesTypeAttributeKind();
function enumCaseValues(e, language) {
    const enumValues = enumValuesTypeAttributeKind.tryGetInAttributes(e.getAttributes());
    if (enumValues === undefined)
        return collectionUtils.mapMap(e.cases.entries(), _ => undefined);
    return collectionUtils.mapMap(e.cases.entries(), c => lookupKey(enumValues, c, language));
}
function enumValuesAttributeProducer(schema, _canonicalRef, _types) {
    if (typeof schema !== "object")
        return undefined;
    const maybeEnumValues = schema["qt-enum-values"];
    if (maybeEnumValues === undefined)
        return undefined;
    return { forType: enumValuesTypeAttributeKind.makeAttributes(makeAccessorNames(maybeEnumValues)) };
}

class JSONSchemaStore {
    constructor() {
        this._schemas = new Map();
    }
    add(address, schema) {
        assert(!this._schemas.has(address), "Cannot set a schema for an address twice");
        this._schemas.set(address, schema);
    }
    get(address, debugPrint) {
        return __awaiter(this, void 0, void 0, function* () {
            let schema = this._schemas.get(address);
            if (schema !== undefined) {
                return schema;
            }
            if (debugPrint) {
                console.log(`trying to fetch ${address}`);
            }
            try {
                schema = yield this.fetch(address);
            }
            catch (e) {
                // FIXME: handle or log this error
            }
            if (schema === undefined) {
                if (debugPrint) {
                    console.log(`couldn't fetch ${address}`);
                }
                return undefined;
            }
            if (debugPrint) {
                console.log(`successully fetched ${address}`);
            }
            this.add(address, schema);
            return schema;
        });
    }
}

// There's a cyclic import here. Ignoring now because it requires a large refactor.
// skipcq: JS-E1008
var PathElementKind;
(function (PathElementKind) {
    PathElementKind[PathElementKind["Root"] = 1] = "Root";
    PathElementKind[PathElementKind["KeyOrIndex"] = 2] = "KeyOrIndex";
    PathElementKind[PathElementKind["Type"] = 3] = "Type";
    PathElementKind[PathElementKind["Object"] = 4] = "Object";
})(PathElementKind || (PathElementKind = {}));
function keyOrIndex(pe) {
    if (pe.kind !== PathElementKind.KeyOrIndex)
        return undefined;
    return pe.key;
}
function pathElementEquals(a, b) {
    if (a.kind !== b.kind)
        return false;
    if (a.kind === PathElementKind.Type && b.kind === PathElementKind.Type) {
        return a.index === b.index;
    }
    if (a.kind === PathElementKind.KeyOrIndex && b.kind === PathElementKind.KeyOrIndex) {
        return a.key === b.key;
    }
    return true;
}
function withRef(refOrLoc, props) {
    const ref = typeof refOrLoc === "function" ? refOrLoc() : refOrLoc instanceof Ref ? refOrLoc : refOrLoc.canonicalRef;
    return Object.assign({ ref }, props !== null && props !== void 0 ? props : {});
}
function checkJSONSchemaObject(x, refOrLoc) {
    if (Array.isArray(x)) {
        return messageError("SchemaArrayIsInvalidSchema", withRef(refOrLoc));
    }
    if (x === null) {
        return messageError("SchemaNullIsInvalidSchema", withRef(refOrLoc));
    }
    if (typeof x !== "object") {
        return messageError("SchemaInvalidJSONSchemaType", withRef(refOrLoc, { type: typeof x }));
    }
    return x;
}
function checkJSONSchema(x, refOrLoc) {
    if (typeof x === "boolean")
        return x;
    return checkJSONSchemaObject(x, refOrLoc);
}
const numberRegexp = new RegExp("^[0-9]+$");
function normalizeURI(uri) {
    // FIXME: This is overly complicated and a bit shady.  The problem is
    // that `normalize` will URL-escape, with the result that if we want to
    // open the URL as a file, escaped character will thwart us.  I think the
    // JSONSchemaStore should take a URI, not a string, and if it reads from
    // a file it can decode by itself.
    if (typeof uri === "string") {
        uri = new URI$1(uri);
    }
    return new URI$1(URI$1.decode(uri.clone().normalize().toString()));
}
class Ref {
    static root(address) {
        const uri = collectionUtils.definedMap(address, a => new URI$1(a));
        return new Ref(uri, []);
    }
    static parsePath(path) {
        const elements = [];
        if (path.startsWith("/")) {
            elements.push({ kind: PathElementKind.Root });
            path = path.slice(1);
        }
        if (path !== "") {
            const parts = path.split("/");
            parts.forEach(part => elements.push({ kind: PathElementKind.KeyOrIndex, key: part }));
        }
        return elements;
    }
    static parseURI(uri, destroyURI = false) {
        if (!destroyURI) {
            uri = uri.clone();
        }
        let path = uri.fragment();
        uri.fragment("");
        if ((uri.host() !== "" || uri.filename() !== "") && path === "") {
            path = "/";
        }
        const elements = Ref.parsePath(path);
        return new Ref(uri, elements);
    }
    static parse(ref) {
        return Ref.parseURI(new URI$1(ref), true);
    }
    constructor(addressURI, path) {
        this.path = path;
        if (addressURI !== undefined) {
            assert(addressURI.fragment() === "", `Ref URI with fragment is not allowed: ${addressURI.toString()}`);
            this.addressURI = normalizeURI(addressURI);
        }
        else {
            this.addressURI = undefined;
        }
    }
    get hasAddress() {
        return this.addressURI !== undefined;
    }
    get address() {
        return defined(this.addressURI).toString();
    }
    get isRoot() {
        return this.path.length === 1 && this.path[0].kind === PathElementKind.Root;
    }
    pushElement(pe) {
        const newPath = Array.from(this.path);
        newPath.push(pe);
        return new Ref(this.addressURI, newPath);
    }
    push(...keys) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let ref = this;
        for (const key of keys) {
            ref = ref.pushElement({ kind: PathElementKind.KeyOrIndex, key });
        }
        return ref;
    }
    pushObject() {
        return this.pushElement({ kind: PathElementKind.Object });
    }
    pushType(index) {
        return this.pushElement({ kind: PathElementKind.Type, index });
    }
    resolveAgainst(base) {
        let addressURI = this.addressURI;
        if ((base === null || base === void 0 ? void 0 : base.addressURI) !== undefined) {
            addressURI = addressURI === undefined ? base.addressURI : addressURI.absoluteTo(base.addressURI);
        }
        return new Ref(addressURI, this.path);
    }
    get name() {
        const path = Array.from(this.path);
        for (;;) {
            const e = path.pop();
            if (e === undefined || e.kind === PathElementKind.Root) {
                let name = this.addressURI !== undefined ? this.addressURI.filename() : "";
                const suffix = this.addressURI !== undefined ? this.addressURI.suffix() : "";
                if (name.length > suffix.length + 1) {
                    name = name.slice(0, name.length - suffix.length - 1);
                }
                if (name === "") {
                    return "Something";
                }
                return name;
            }
            switch (e.kind) {
                case PathElementKind.KeyOrIndex:
                    if (numberRegexp.test(e.key)) {
                        return e.key;
                    }
                    break;
                case PathElementKind.Type:
                case PathElementKind.Object:
                    return panic("We shouldn't try to get the name of Type or Object refs");
                default:
                    return assertNever(e);
            }
        }
    }
    get definitionName() {
        const pe = collectionUtils.arrayGetFromEnd(this.path, 2);
        if (pe === undefined)
            return undefined;
        if (keyOrIndex(pe) === "definitions")
            return keyOrIndex(defined(collectionUtils.arrayLast(this.path)));
        return undefined;
    }
    toString() {
        function elementToString(e) {
            switch (e.kind) {
                case PathElementKind.Root:
                    return "";
                case PathElementKind.Type:
                    return `type/${e.index.toString()}`;
                case PathElementKind.Object:
                    return "object";
                case PathElementKind.KeyOrIndex:
                    return e.key;
                default:
                    return assertNever(e);
            }
        }
        const address = this.addressURI === undefined ? "" : this.addressURI.toString();
        return address + "#" + this.path.map(elementToString).join("/");
    }
    lookup(local, path, root) {
        const refMaker = () => new Ref(this.addressURI, path);
        const first = path[0];
        if (first === undefined) {
            return checkJSONSchema(local, refMaker);
        }
        const rest = path.slice(1);
        switch (first.kind) {
            case PathElementKind.Root:
                return this.lookup(root, rest, root);
            case PathElementKind.KeyOrIndex:
                const key = first.key;
                if (Array.isArray(local)) {
                    if (!/^\d+$/.test(key)) {
                        return messageError("SchemaCannotIndexArrayWithNonNumber", withRef(refMaker, { actual: key }));
                    }
                    const index = parseInt(first.key, 10);
                    if (index >= local.length) {
                        return messageError("SchemaIndexNotInArray", withRef(refMaker, { index }));
                    }
                    return this.lookup(local[index], rest, root);
                }
                else {
                    if (!collectionUtils.hasOwnProperty(local, key)) {
                        return messageError("SchemaKeyNotInObject", withRef(refMaker, { key }));
                    }
                    return this.lookup(checkJSONSchemaObject(local, refMaker)[first.key], rest, root);
                }
            case PathElementKind.Type:
                return panic('Cannot look up path that indexes "type"');
            case PathElementKind.Object:
                return panic('Cannot look up path that indexes "object"');
            default:
                return assertNever(first);
        }
    }
    lookupRef(root) {
        return this.lookup(root, this.path, root);
    }
    equals(other) {
        if (!(other instanceof Ref))
            return false;
        if (this.addressURI !== undefined && other.addressURI !== undefined) {
            if (!this.addressURI.equals(other.addressURI))
                return false;
        }
        else {
            if ((this.addressURI === undefined) !== (other.addressURI === undefined))
                return false;
        }
        const l = this.path.length;
        if (l !== other.path.length)
            return false;
        for (let i = 0; i < l; i++) {
            if (!pathElementEquals(this.path[i], other.path[i]))
                return false;
        }
        return true;
    }
    hashCode() {
        let acc = collectionUtils.hashCodeOf(collectionUtils.definedMap(this.addressURI, u => u.toString()));
        for (const pe of this.path) {
            acc = collectionUtils.addHashCode(acc, pe.kind);
            switch (pe.kind) {
                case PathElementKind.Type:
                    acc = collectionUtils.addHashCode(acc, pe.index);
                    break;
                case PathElementKind.KeyOrIndex:
                    acc = collectionUtils.addHashCode(acc, collectionUtils.hashString(pe.key));
                    break;
            }
        }
        return acc;
    }
}
class Location {
    constructor(canonicalRef, virtualRef, haveID = false) {
        this.haveID = haveID;
        this.canonicalRef = canonicalRef;
        this.virtualRef = virtualRef !== null && virtualRef !== void 0 ? virtualRef : canonicalRef;
    }
    updateWithID(id) {
        if (typeof id !== "string")
            return this;
        const parsed = Ref.parse(id);
        const virtual = this.haveID ? parsed.resolveAgainst(this.virtualRef) : parsed;
        if (!this.haveID) {
            messageAssert(virtual.hasAddress, "SchemaIDMustHaveAddress", withRef(this, { id }));
        }
        return new Location(this.canonicalRef, virtual, true);
    }
    push(...keys) {
        return new Location(this.canonicalRef.push(...keys), this.virtualRef.push(...keys), this.haveID);
    }
    pushObject() {
        return new Location(this.canonicalRef.pushObject(), this.virtualRef.pushObject(), this.haveID);
    }
    pushType(index) {
        return new Location(this.canonicalRef.pushType(index), this.virtualRef.pushType(index), this.haveID);
    }
    toString() {
        return `${this.virtualRef.toString()} (${this.canonicalRef.toString()})`;
    }
}
class Canonizer {
    constructor(_ctx) {
        this._ctx = _ctx;
        this._map = new collectionUtils.EqualityMap();
        this._schemaAddressesAdded = new Set();
    }
    addIDs(schema, loc) {
        if (schema === null)
            return;
        if (Array.isArray(schema)) {
            for (let i = 0; i < schema.length; i++) {
                this.addIDs(schema[i], loc.push(i.toString()));
            }
            return;
        }
        if (typeof schema !== "object") {
            return;
        }
        const locWithoutID = loc;
        const maybeID = "$id" in schema ? schema.$id : undefined;
        if (typeof maybeID === "string") {
            loc = loc.updateWithID(maybeID);
        }
        if (loc.haveID) {
            if (this._ctx.debugPrintSchemaResolving) {
                console.log(`adding mapping ${loc.toString()}`);
            }
            this._map.set(loc.virtualRef, locWithoutID);
        }
        for (const property of Object.getOwnPropertyNames(schema)) {
            this.addIDs(schema[property], loc.push(property));
        }
    }
    addSchema(schema, address) {
        if (this._schemaAddressesAdded.has(address))
            return false;
        this.addIDs(schema, new Location(Ref.root(address), Ref.root(undefined)));
        this._schemaAddressesAdded.add(address);
        return true;
    }
    // Returns: Canonical ref
    canonize(base, ref) {
        const virtual = ref.resolveAgainst(base.virtualRef);
        const loc = this._map.get(virtual);
        if (loc !== undefined) {
            return loc;
        }
        const canonicalRef = virtual.addressURI === undefined ? new Ref(base.canonicalRef.addressURI, virtual.path) : virtual;
        return new Location(canonicalRef, new Ref(undefined, virtual.path));
    }
}
function checkTypeList(typeOrTypes, loc) {
    let set;
    if (typeof typeOrTypes === "string") {
        set = new Set([typeOrTypes]);
    }
    else if (Array.isArray(typeOrTypes)) {
        const arr = [];
        for (const t of typeOrTypes) {
            if (typeof t !== "string") {
                return messageError("SchemaTypeElementMustBeString", withRef(loc, { element: t }));
            }
            arr.push(t);
        }
        set = new Set(arr);
    }
    else {
        return messageError("SchemaTypeMustBeStringOrStringArray", withRef(loc, { actual: typeOrTypes }));
    }
    messageAssert(set.size > 0, "SchemaNoTypeSpecified", withRef(loc));
    const validTypes = ["null", "boolean", "object", "array", "number", "string", "integer"];
    const maybeInvalid = collectionUtils.iterableFind(set, s => !validTypes.includes(s));
    if (maybeInvalid !== undefined) {
        return messageError("SchemaInvalidType", withRef(loc, { type: maybeInvalid }));
    }
    return set;
}
function checkRequiredArray(arr, loc) {
    if (!Array.isArray(arr)) {
        return messageError("SchemaRequiredMustBeStringOrStringArray", withRef(loc, { actual: arr }));
    }
    for (const e of arr) {
        if (typeof e !== "string") {
            return messageError("SchemaRequiredElementMustBeString", withRef(loc, { element: e }));
        }
    }
    return arr;
}
const schemaTypeDict = {
    null: true,
    boolean: true,
    string: true,
    integer: true,
    number: true,
    array: true,
    object: true
};
const schemaTypes = Object.getOwnPropertyNames(schemaTypeDict);
function typeKindForJSONSchemaFormat(format) {
    const target = collectionUtils.iterableFind(transformedStringTypeTargetTypeKindsMap, ([_, { jsonSchema }]) => jsonSchema === format);
    if (target === undefined)
        return undefined;
    return target[0];
}
function schemaFetchError(base, address) {
    if (base === undefined) {
        return messageError("SchemaFetchErrorTopLevel", { address });
    }
    else {
        return messageError("SchemaFetchError", { address, base: base.canonicalRef });
    }
}
class Resolver {
    constructor(_ctx, _store, _canonizer) {
        this._ctx = _ctx;
        this._store = _store;
        this._canonizer = _canonizer;
    }
    tryResolveVirtualRef(fetchBase, lookupBase, virtualRef) {
        return __awaiter(this, void 0, void 0, function* () {
            let didAdd = false;
            // If we are resolving into a schema file that we haven't seen yet then
            // we don't know its $id mapping yet, which means we don't know where we
            // will end up.  What we do if we encounter a new schema is add all its
            // IDs first, and then try to canonize again.
            for (;;) {
                const loc = this._canonizer.canonize(fetchBase, virtualRef);
                const canonical = loc.canonicalRef;
                assert(canonical.hasAddress, "Canonical ref can't be resolved without an address");
                const address = canonical.address;
                let schema = canonical.addressURI === undefined
                    ? undefined
                    : yield this._store.get(address, this._ctx.debugPrintSchemaResolving);
                if (schema === undefined) {
                    return [undefined, loc];
                }
                if (this._canonizer.addSchema(schema, address)) {
                    assert(!didAdd, "We can't add a schema twice");
                    didAdd = true;
                }
                else {
                    let lookupLoc = this._canonizer.canonize(lookupBase, virtualRef);
                    if (fetchBase !== undefined) {
                        lookupLoc = new Location(new Ref(loc.canonicalRef.addressURI, lookupLoc.canonicalRef.path), lookupLoc.virtualRef, lookupLoc.haveID);
                    }
                    return [lookupLoc.canonicalRef.lookupRef(schema), lookupLoc];
                }
            }
        });
    }
    resolveVirtualRef(base, virtualRef) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._ctx.debugPrintSchemaResolving) {
                console.log(`resolving ${virtualRef.toString()} relative to ${base.toString()}`);
            }
            // Try with the virtual base first.  If that doesn't work, use the
            // canonical ref's address with the virtual base's path.
            let result = yield this.tryResolveVirtualRef(base, base, virtualRef);
            let schema = result[0];
            if (schema !== undefined) {
                if (this._ctx.debugPrintSchemaResolving) {
                    console.log(`resolved to ${result[1].toString()}`);
                }
                return [schema, result[1]];
            }
            const altBase = new Location(base.canonicalRef, new Ref(base.canonicalRef.addressURI, base.virtualRef.path), base.haveID);
            result = yield this.tryResolveVirtualRef(altBase, base, virtualRef);
            schema = result[0];
            if (schema !== undefined) {
                if (this._ctx.debugPrintSchemaResolving) {
                    console.log(`resolved to ${result[1].toString()}`);
                }
                return [schema, result[1]];
            }
            return schemaFetchError(base, virtualRef.address);
        });
    }
    resolveTopLevelRef(ref) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.resolveVirtualRef(new Location(new Ref(ref.addressURI, [])), new Ref(undefined, ref.path));
        });
    }
}
function addTypesInSchema(resolver, typeBuilder, references, attributeProducers) {
    return __awaiter(this, void 0, void 0, function* () {
        let typeForCanonicalRef = new collectionUtils.EqualityMap();
        function setTypeForLocation(loc, t) {
            const maybeRef = typeForCanonicalRef.get(loc.canonicalRef);
            if (maybeRef !== undefined) {
                assert(maybeRef === t, "Trying to set path again to different type");
            }
            typeForCanonicalRef.set(loc.canonicalRef, t);
        }
        function makeObject(loc, attributes, properties, requiredArray, additionalProperties, sortKey = (k) => k.toLowerCase()) {
            return __awaiter(this, void 0, void 0, function* () {
                const required = new Set(requiredArray);
                const propertiesMap = collectionUtils.mapSortBy(collectionUtils.mapFromObject(properties), (_, k) => sortKey(k));
                const props = yield collectionUtils.mapMapSync(propertiesMap, (propSchema, propName) => __awaiter(this, void 0, void 0, function* () {
                    const propLoc = loc.push("properties", propName);
                    const t = yield toType(checkJSONSchema(propSchema, propLoc.canonicalRef), propLoc, makeNamesTypeAttributes(propName, true));
                    const isOptional = !required.has(propName);
                    return typeBuilder.makeClassProperty(t, isOptional);
                }));
                let additionalPropertiesType;
                if (additionalProperties === undefined || additionalProperties === true) {
                    additionalPropertiesType = typeBuilder.getPrimitiveType("any");
                }
                else if (additionalProperties === false) {
                    additionalPropertiesType = undefined;
                }
                else {
                    const additionalLoc = loc.push("additionalProperties");
                    additionalPropertiesType = yield toType(checkJSONSchema(additionalProperties, additionalLoc.canonicalRef), additionalLoc, singularizeTypeNames(attributes));
                }
                const additionalRequired = collectionUtils.setSubtract(required, props.keys());
                if (additionalRequired.size > 0) {
                    const t = additionalPropertiesType;
                    if (t === undefined) {
                        return messageError("SchemaAdditionalTypesForbidRequired", withRef(loc));
                    }
                    const additionalProps = collectionUtils.mapFromIterable(additionalRequired, _name => typeBuilder.makeClassProperty(t, false));
                    collectionUtils.mapMergeInto(props, additionalProps);
                }
                return typeBuilder.getUniqueObjectType(attributes, props, additionalPropertiesType);
            });
        }
        function convertToType(schema, loc, typeAttributes) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                const enumArray = Array.isArray(schema.enum) ? schema.enum : undefined;
                const isConst = schema.const !== undefined;
                const typeSet = collectionUtils.definedMap(schema.type, t => checkTypeList(t, loc));
                function isTypeIncluded(name) {
                    var _a;
                    if (typeSet !== undefined && !typeSet.has(name)) {
                        return false;
                    }
                    if (enumArray !== undefined) {
                        let predicate;
                        switch (name) {
                            case "null":
                                predicate = (x) => x === null;
                                break;
                            case "integer":
                                predicate = (x) => typeof x === "number" && x === Math.floor(x);
                                break;
                            default:
                                predicate = (x) => typeof x === name;
                                break;
                        }
                        return enumArray.find(predicate) !== undefined;
                    }
                    if (isConst) {
                        return name === ((_a = schema.type) !== null && _a !== void 0 ? _a : typeof schema.const);
                    }
                    return true;
                }
                const includedTypes = collectionUtils.setFilter(schemaTypes, isTypeIncluded);
                let producedAttributesForNoCases = undefined;
                function forEachProducedAttribute(cases, f) {
                    let attributes;
                    if (cases === undefined && producedAttributesForNoCases !== undefined) {
                        attributes = producedAttributesForNoCases;
                    }
                    else {
                        attributes = [];
                        for (const producer of attributeProducers) {
                            const newAttributes = producer(schema, loc.canonicalRef, includedTypes, cases);
                            if (newAttributes === undefined)
                                continue;
                            attributes.push(newAttributes);
                        }
                        if (cases === undefined) {
                            producedAttributesForNoCases = attributes;
                        }
                    }
                    for (const a of attributes) {
                        f(a);
                    }
                }
                function combineProducedAttributes(f) {
                    let result = emptyTypeAttributes;
                    forEachProducedAttribute(undefined, attr => {
                        const maybeAttributes = f(attr);
                        if (maybeAttributes === undefined)
                            return;
                        result = combineTypeAttributes("union", result, maybeAttributes);
                    });
                    return result;
                }
                function makeAttributes(attributes) {
                    if (schema.oneOf === undefined) {
                        attributes = combineTypeAttributes("union", attributes, combineProducedAttributes(({ forType, forUnion, forCases }) => {
                            assert(forUnion === undefined && forCases === undefined, "We can't have attributes for unions and cases if we don't have a union");
                            return forType;
                        }));
                    }
                    return modifyTypeNames(attributes, maybeTypeNames => {
                        const typeNames = defined(maybeTypeNames);
                        if (!typeNames.areInferred) {
                            return typeNames;
                        }
                        let title = schema.title;
                        if (typeof title !== "string") {
                            title = loc.canonicalRef.definitionName;
                        }
                        if (typeof title === "string") {
                            return TypeNames.make(new Set([title]), new Set(), schema.$ref !== undefined);
                        }
                        else {
                            return typeNames.makeInferred();
                        }
                    });
                }
                typeAttributes = makeAttributes(typeAttributes);
                const inferredAttributes = makeTypeAttributesInferred(typeAttributes);
                function makeStringType(attributes) {
                    const kind = typeKindForJSONSchemaFormat(schema.format);
                    if (kind === undefined) {
                        return typeBuilder.getStringType(attributes, StringTypes.unrestricted);
                    }
                    else {
                        return typeBuilder.getPrimitiveType(kind, attributes);
                    }
                }
                function makeArrayType() {
                    return __awaiter(this, void 0, void 0, function* () {
                        const singularAttributes = singularizeTypeNames(typeAttributes);
                        const items = schema.items;
                        let itemType;
                        if (Array.isArray(items)) {
                            const itemsLoc = loc.push("items");
                            const itemTypes = yield collectionUtils.arrayMapSync(items, (item, i) => __awaiter(this, void 0, void 0, function* () {
                                const itemLoc = itemsLoc.push(i.toString());
                                return yield toType(checkJSONSchema(item, itemLoc.canonicalRef), itemLoc, singularAttributes);
                            }));
                            itemType = typeBuilder.getUnionType(emptyTypeAttributes, new Set(itemTypes));
                        }
                        else if (typeof items === "object") {
                            const itemsLoc = loc.push("items");
                            itemType = yield toType(checkJSONSchema(items, itemsLoc.canonicalRef), itemsLoc, singularAttributes);
                        }
                        else if (items !== undefined && items !== true) {
                            return messageError("SchemaArrayItemsMustBeStringOrArray", withRef(loc, { actual: items }));
                        }
                        else {
                            itemType = typeBuilder.getPrimitiveType("any");
                        }
                        typeBuilder.addAttributes(itemType, singularAttributes);
                        return typeBuilder.getArrayType(emptyTypeAttributes, itemType);
                    });
                }
                function makeObjectType() {
                    return __awaiter(this, void 0, void 0, function* () {
                        let required;
                        if (schema.required === undefined || typeof schema.required === "boolean") {
                            required = [];
                        }
                        else {
                            required = Array.from(checkRequiredArray(schema.required, loc));
                        }
                        let properties;
                        if (schema.properties === undefined) {
                            properties = {};
                        }
                        else {
                            properties = checkJSONSchemaObject(schema.properties, loc.canonicalRef);
                        }
                        // In Schema Draft 3, `required` is `true` on a property that's required.
                        for (const p of Object.getOwnPropertyNames(properties)) {
                            if (properties[p].required === true && !required.includes(p)) {
                                required.push(p);
                            }
                        }
                        let additionalProperties = schema.additionalProperties;
                        // This is an incorrect hack to fix an issue with a Go->Schema generator:
                        // https://github.com/quicktype/quicktype/issues/976
                        if (additionalProperties === undefined &&
                            typeof schema.patternProperties === "object" &&
                            collectionUtils.hasOwnProperty(schema.patternProperties, ".*")) {
                            additionalProperties = schema.patternProperties[".*"];
                        }
                        const objectAttributes = combineTypeAttributes("union", inferredAttributes, combineProducedAttributes(({ forObject }) => forObject));
                        const order = schema.quicktypePropertyOrder ? schema.quicktypePropertyOrder : [];
                        const orderKey = (propertyName) => {
                            // use the index of the order array
                            const index = order.indexOf(propertyName);
                            // if no index then use the property name
                            return index !== -1 ? index : propertyName.toLowerCase();
                        };
                        return yield makeObject(loc, objectAttributes, properties, required, additionalProperties, orderKey);
                    });
                }
                function makeTypesFromCases(cases, kind) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const kindLoc = loc.push(kind);
                        if (!Array.isArray(cases)) {
                            return messageError("SchemaSetOperationCasesIsNotArray", withRef(kindLoc, { operation: kind, cases }));
                        }
                        return yield collectionUtils.arrayMapSync(cases, (t, index) => __awaiter(this, void 0, void 0, function* () {
                            const caseLoc = kindLoc.push(index.toString());
                            return yield toType(checkJSONSchema(t, caseLoc.canonicalRef), caseLoc, makeTypeAttributesInferred(typeAttributes));
                        }));
                    });
                }
                const intersectionType = typeBuilder.getUniqueIntersectionType(typeAttributes, undefined);
                setTypeForLocation(loc, intersectionType);
                function convertOneOrAnyOf(cases, kind) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const typeRefs = yield makeTypesFromCases(cases, kind);
                        let unionAttributes = makeTypeAttributesInferred(typeAttributes);
                        if (kind === "oneOf") {
                            forEachProducedAttribute(cases, ({ forType, forUnion, forCases }) => {
                                if (forType !== undefined) {
                                    typeBuilder.addAttributes(intersectionType, forType);
                                }
                                if (forUnion !== undefined) {
                                    unionAttributes = combineTypeAttributes("union", unionAttributes, forUnion);
                                }
                                if (forCases !== undefined) {
                                    assert(forCases.length === typeRefs.length, "Number of case attributes doesn't match number of cases");
                                    for (let i = 0; i < typeRefs.length; i++) {
                                        typeBuilder.addAttributes(typeRefs[i], forCases[i]);
                                    }
                                }
                            });
                        }
                        const unionType = typeBuilder.getUniqueUnionType(unionAttributes, undefined);
                        typeBuilder.setSetOperationMembers(unionType, new Set(typeRefs));
                        return unionType;
                    });
                }
                const includeObject = enumArray === undefined && !isConst && (typeSet === undefined || typeSet.has("object"));
                const includeArray = enumArray === undefined && !isConst && (typeSet === undefined || typeSet.has("array"));
                const needStringEnum = includedTypes.has("string") &&
                    enumArray !== undefined &&
                    enumArray.find(x => typeof x === "string") !== undefined;
                const needUnion = typeSet !== undefined ||
                    schema.properties !== undefined ||
                    schema.additionalProperties !== undefined ||
                    schema.items !== undefined ||
                    schema.required !== undefined ||
                    enumArray !== undefined ||
                    isConst;
                const types = [];
                if (needUnion) {
                    const unionTypes = [];
                    const numberAttributes = combineProducedAttributes(({ forNumber }) => forNumber);
                    for (const [name, kind] of [
                        ["null", "null"],
                        ["number", "double"],
                        ["integer", "integer"],
                        ["boolean", "bool"]
                    ]) {
                        if (!includedTypes.has(name))
                            continue;
                        const attributes = isNumberTypeKind(kind) ? numberAttributes : undefined;
                        unionTypes.push(typeBuilder.getPrimitiveType(kind, attributes));
                    }
                    const stringAttributes = combineTypeAttributes("union", inferredAttributes, combineProducedAttributes(({ forString }) => forString));
                    if (needStringEnum || isConst) {
                        const cases = isConst ? [schema.const] : (_a = enumArray === null || enumArray === void 0 ? void 0 : enumArray.filter(x => typeof x === "string")) !== null && _a !== void 0 ? _a : [];
                        unionTypes.push(typeBuilder.getStringType(stringAttributes, StringTypes.fromCases(cases)));
                    }
                    else if (includedTypes.has("string")) {
                        unionTypes.push(makeStringType(stringAttributes));
                    }
                    if (includeArray) {
                        unionTypes.push(yield makeArrayType());
                    }
                    if (includeObject) {
                        unionTypes.push(yield makeObjectType());
                    }
                    types.push(typeBuilder.getUniqueUnionType(inferredAttributes, new Set(unionTypes)));
                }
                if (schema.$ref !== undefined) {
                    if (typeof schema.$ref !== "string") {
                        return messageError("SchemaRefMustBeString", withRef(loc, { actual: typeof schema.$ref }));
                    }
                    const virtualRef = Ref.parse(schema.$ref);
                    const [target, newLoc] = yield resolver.resolveVirtualRef(loc, virtualRef);
                    const attributes = modifyTypeNames(typeAttributes, tn => {
                        if (!defined(tn).areInferred)
                            return tn;
                        return TypeNames.make(new Set([newLoc.canonicalRef.name]), new Set(), true);
                    });
                    types.push(yield toType(target, newLoc, attributes));
                }
                if (schema.allOf !== undefined) {
                    types.push(...(yield makeTypesFromCases(schema.allOf, "allOf")));
                }
                if (schema.oneOf !== undefined) {
                    types.push(yield convertOneOrAnyOf(schema.oneOf, "oneOf"));
                }
                if (schema.anyOf !== undefined) {
                    types.push(yield convertOneOrAnyOf(schema.anyOf, "anyOf"));
                }
                typeBuilder.setSetOperationMembers(intersectionType, new Set(types));
                return intersectionType;
            });
        }
        function toType(schema, loc, typeAttributes) {
            return __awaiter(this, void 0, void 0, function* () {
                const maybeType = typeForCanonicalRef.get(loc.canonicalRef);
                if (maybeType !== undefined) {
                    return maybeType;
                }
                let result;
                if (typeof schema === "boolean") {
                    // FIXME: Empty union.  We'd have to check that it's supported everywhere,
                    // in particular in union flattening.
                    messageAssert(schema === true, "SchemaFalseNotSupported", withRef(loc));
                    result = typeBuilder.getPrimitiveType("any");
                }
                else {
                    loc = loc.updateWithID(schema.$id);
                    result = yield convertToType(schema, loc, typeAttributes);
                }
                setTypeForLocation(loc, result);
                return result;
            });
        }
        for (const [topLevelName, topLevelRef] of references) {
            const [target, loc] = yield resolver.resolveTopLevelRef(topLevelRef);
            const t = yield toType(target, loc, makeNamesTypeAttributes(topLevelName, false));
            typeBuilder.addTopLevel(topLevelName, t);
        }
    });
}
function removeExtension(fn) {
    const lower = fn.toLowerCase();
    const extensions = [".json", ".schema"];
    for (const ext of extensions) {
        if (lower.endsWith(ext)) {
            const base = fn.slice(0, fn.length - ext.length);
            if (base.length > 0) {
                return base;
            }
        }
    }
    return fn;
}
function nameFromURI(uri) {
    const fragment = uri.fragment();
    if (fragment !== "") {
        const components = fragment.split("/");
        const len = components.length;
        if (components[len - 1] !== "") {
            return removeExtension(components[len - 1]);
        }
        if (len > 1 && components[len - 2] !== "") {
            return removeExtension(components[len - 2]);
        }
    }
    const filename = uri.filename();
    if (filename !== "") {
        return removeExtension(filename);
    }
    return messageError("DriverCannotInferNameForSchema", { uri: uri.toString() });
}
function refsInSchemaForURI(resolver, uri, defaultName) {
    return __awaiter(this, void 0, void 0, function* () {
        const fragment = uri.fragment();
        let propertiesAreTypes = fragment.endsWith("/");
        if (propertiesAreTypes) {
            uri = uri.clone().fragment(fragment.slice(0, -1));
        }
        const ref = Ref.parseURI(uri);
        if (ref.isRoot) {
            propertiesAreTypes = false;
        }
        const schema = (yield resolver.resolveTopLevelRef(ref))[0];
        if (propertiesAreTypes) {
            if (typeof schema !== "object") {
                return messageError("SchemaCannotGetTypesFromBoolean", { ref: ref.toString() });
            }
            return collectionUtils.mapMap(collectionUtils.mapFromObject(schema), (_, name) => ref.push(name));
        }
        else {
            let name;
            if (typeof schema === "object" && typeof schema.title === "string") {
                name = schema.title;
            }
            else {
                const maybeName = nameFromURI(uri);
                name = maybeName !== null && maybeName !== void 0 ? maybeName : defaultName;
            }
            return [name, ref];
        }
    });
}
class InputJSONSchemaStore extends JSONSchemaStore {
    constructor(_inputs, _delegate) {
        super();
        this._inputs = _inputs;
        this._delegate = _delegate;
    }
    fetch(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const maybeInput = this._inputs.get(address);
            if (maybeInput !== undefined) {
                return checkJSONSchema(parseJSON(maybeInput, "JSON Schema", address), () => Ref.root(address));
            }
            if (this._delegate === undefined) {
                return panic(`Schema URI ${address} requested, but no store given`);
            }
            return yield this._delegate.fetch(address);
        });
    }
}
class JSONSchemaInput {
    constructor(_schemaStore, additionalAttributeProducers = [], _additionalSchemaAddresses = []) {
        this._schemaStore = _schemaStore;
        this._additionalSchemaAddresses = _additionalSchemaAddresses;
        this.kind = "schema";
        this.needSchemaProcessing = true;
        this._schemaInputs = new Map();
        this._schemaSources = [];
        this._topLevels = new Map();
        this._needIR = false;
        this._attributeProducers = [
            descriptionAttributeProducer,
            accessorNamesAttributeProducer,
            enumValuesAttributeProducer,
            uriSchemaAttributesProducer,
            minMaxAttributeProducer,
            minMaxLengthAttributeProducer,
            patternAttributeProducer
        ].concat(additionalAttributeProducers);
    }
    get needIR() {
        return this._needIR;
    }
    addTopLevel(name, ref) {
        this._topLevels.set(name, ref);
    }
    addTypes(ctx, typeBuilder) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._schemaSources.length === 0)
                return;
            let maybeSchemaStore = this._schemaStore;
            if (this._schemaInputs.size === 0) {
                if (maybeSchemaStore === undefined) {
                    return panic("Must have a schema store to process JSON Schema");
                }
            }
            else {
                maybeSchemaStore = this._schemaStore = new InputJSONSchemaStore(this._schemaInputs, maybeSchemaStore);
            }
            const schemaStore = maybeSchemaStore;
            const canonizer = new Canonizer(ctx);
            for (const address of this._additionalSchemaAddresses) {
                const schema = yield schemaStore.get(address, ctx.debugPrintSchemaResolving);
                if (schema === undefined) {
                    return messageError("SchemaFetchErrorAdditional", { address });
                }
                canonizer.addSchema(schema, address);
            }
            const resolver = new Resolver(ctx, defined(this._schemaStore), canonizer);
            for (const [normalizedURI, source] of this._schemaSources) {
                const givenName = source.name;
                const refs = yield refsInSchemaForURI(resolver, normalizedURI, givenName);
                if (Array.isArray(refs)) {
                    let name;
                    if (this._schemaSources.length === 1 && givenName !== undefined) {
                        name = givenName;
                    }
                    else {
                        name = refs[0];
                    }
                    this.addTopLevel(name, refs[1]);
                }
                else {
                    for (const [refName, ref] of refs) {
                        this.addTopLevel(refName, ref);
                    }
                }
            }
            yield addTypesInSchema(resolver, typeBuilder, this._topLevels, this._attributeProducers);
        });
    }
    addTypesSync() {
        return panic("addTypesSync not supported in JSONSchemaInput");
    }
    addSource(schemaSource) {
        return __awaiter(this, void 0, void 0, function* () {
            this.addSourceSync(schemaSource);
        });
    }
    addSourceSync(schemaSource) {
        const { name, uris, schema, isConverted } = schemaSource;
        if (isConverted !== true) {
            this._needIR = true;
        }
        let normalizedURIs;
        if (uris === undefined) {
            normalizedURIs = [new URI$1(name)];
        }
        else {
            normalizedURIs = uris.map(uri => {
                const normalizedURI = normalizeURI(uri);
                if (normalizedURI.clone().hash("").toString() === "") {
                    normalizedURI.path(name);
                }
                return normalizedURI;
            });
        }
        if (schema === undefined) {
            assert(uris !== undefined, "URIs must be given if schema source is not specified");
        }
        else {
            for (let i = 0; i < normalizedURIs.length; i++) {
                const normalizedURI = normalizedURIs[i];
                const uri = normalizedURI.clone().hash("");
                const path = uri.path();
                let suffix = 0;
                do {
                    if (suffix > 0) {
                        uri.path(`${path}-${suffix}`);
                    }
                    suffix++;
                } while (this._schemaInputs.has(uri.toString()));
                this._schemaInputs.set(uri.toString(), schema);
                normalizedURIs[i] = uri.hash(normalizedURI.hash());
            }
        }
        // FIXME: Why do we need both _schemaSources and _schemaInputs?
        for (const normalizedURI of normalizedURIs) {
            this._schemaSources.push([normalizedURI, schemaSource]);
        }
    }
    singleStringSchemaSource() {
        if (!this._schemaSources.every(([_, { schema }]) => typeof schema === "string")) {
            return undefined;
        }
        const set = new Set(this._schemaSources.map(([_, { schema }]) => schema));
        if (set.size === 1) {
            return defined(collectionUtils.iterableFirst(set));
        }
        return undefined;
    }
}

function addDescriptionToSchema(schema, description) {
    if (description === undefined)
        return;
    schema.description = Array.from(description).join("\n");
}
class DescriptionTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("description");
    }
    combine(attrs) {
        return collectionUtils.setUnionManyInto(new Set(), attrs);
    }
    makeInferred(_) {
        return undefined;
    }
    addToSchema(schema, _t, attrs) {
        addDescriptionToSchema(schema, attrs);
    }
    stringify(descriptions) {
        let result = collectionUtils.iterableFirst(descriptions);
        if (result === undefined)
            return undefined;
        if (result.length > 5 + 3) {
            result = `${result.slice(0, 5)}...`;
        }
        if (descriptions.size > 1) {
            result = `${result}, ...`;
        }
        return result;
    }
}
const descriptionTypeAttributeKind = new DescriptionTypeAttributeKind();
class PropertyDescriptionsTypeAttributeKind extends TypeAttributeKind {
    constructor() {
        super("propertyDescriptions");
    }
    combine(attrs) {
        // FIXME: Implement this with mutable sets
        const result = new Map();
        for (const attr of attrs) {
            collectionUtils.mapMergeWithInto(result, (sa, sb) => collectionUtils.setUnion(sa, sb), attr);
        }
        return result;
    }
    makeInferred(_) {
        return undefined;
    }
    stringify(propertyDescriptions) {
        if (propertyDescriptions.size === 0)
            return undefined;
        return `prop descs: ${propertyDescriptions.size}`;
    }
}
const propertyDescriptionsTypeAttributeKind = new PropertyDescriptionsTypeAttributeKind();
function isPropertiesKey(el) {
    return el.kind === PathElementKind.KeyOrIndex && el.key === "properties";
}
function descriptionAttributeProducer(schema, ref, types) {
    if (!(typeof schema === "object"))
        return undefined;
    let description = emptyTypeAttributes;
    let propertyDescription = emptyTypeAttributes;
    const pathLength = ref.path.length;
    if (types.has("object") ||
        collectionUtils.setSubtract(types, ["null"]).size > 1 ||
        schema.enum !== undefined ||
        pathLength < 2 ||
        !isPropertiesKey(ref.path[pathLength - 2])) {
        const maybeDescription = schema.description;
        if (typeof maybeDescription === "string") {
            description = descriptionTypeAttributeKind.makeAttributes(new Set([maybeDescription]));
        }
    }
    if (types.has("object") && typeof schema.properties === "object") {
        const propertyDescriptions = collectionUtils.mapFilterMap(collectionUtils.mapFromObject(schema.properties), propSchema => {
            if (propSchema && typeof propSchema === "object" && "description" in propSchema) {
                const desc = propSchema.description;
                if (typeof desc === "string") {
                    return new Set([desc]);
                }
            }
            return undefined;
        });
        if (propertyDescriptions.size > 0) {
            propertyDescription = propertyDescriptionsTypeAttributeKind.makeAttributes(propertyDescriptions);
        }
    }
    return { forType: description, forObject: propertyDescription };
}

class DeclarationIR {
    constructor(declarations, forwardedTypes) {
        this.forwardedTypes = forwardedTypes;
        this.declarations = Array.from(declarations);
    }
}
function findBreaker(t, path, canBreak) {
    const index = path.indexOf(t);
    if (index < 0)
        return undefined;
    if (canBreak === undefined) {
        return path[index];
    }
    const potentialBreakers = path.slice(0, index + 1).reverse();
    const maybeBreaker = potentialBreakers.find(canBreak);
    if (maybeBreaker === undefined) {
        return panic("Found a cycle that cannot be broken");
    }
    return maybeBreaker;
}
function cycleBreakerTypesForGraph(graph, isImplicitCycleBreaker, canBreakCycles) {
    const visitedTypes = new Set();
    const cycleBreakerTypes = new Set();
    const queue = Array.from(graph.topLevels.values());
    function visit(t, path) {
        if (visitedTypes.has(t))
            return;
        if (isImplicitCycleBreaker(t)) {
            for (const c of t.getChildren()) {
                queue.push(c);
            }
        }
        else {
            const maybeBreaker = findBreaker(t, path, canBreakCycles);
            if (maybeBreaker !== undefined) {
                cycleBreakerTypes.add(maybeBreaker);
                return;
            }
            for (const c of t.getChildren()) {
                path.unshift(t);
                visit(c, path);
                path.shift();
            }
        }
        visitedTypes.add(t);
    }
    for (;;) {
        const maybeType = queue.pop();
        if (maybeType === undefined)
            break;
        const path = [];
        visit(maybeType, path);
        assert(path.length === 0);
    }
    return cycleBreakerTypes;
}
function declarationsForGraph(typeGraph, canBeForwardDeclared, childrenOfType, needsDeclaration) {
    /*
    function nodeTitle(t: Type): string {
        const indexAndKind = `${t.typeRef.index} ${t.kind}`;
        if (t.hasNames) {
            return `${indexAndKind} ${t.getCombinedName()}`;
        } else {
            return indexAndKind;
        }
    }
    function componentName(c: Iterable<Type>): string {
        return Array.from(c).map(nodeTitle).join(", ");
    }
    */
    const topDown = canBeForwardDeclared === undefined;
    const declarations = [];
    const forwardedTypes = new Set();
    const visitedComponents = new Set();
    function processGraph(graph, _writeComponents) {
        const componentsGraph = graph.stronglyConnectedComponents();
        function visitComponent(component) {
            if (visitedComponents.has(component))
                return;
            visitedComponents.add(component);
            // console.log(`visiting component ${componentName(component)}`);
            const declarationNeeded = collectionUtils.setFilter(component, needsDeclaration);
            // 1. Only one node in the cycle needs a declaration, in which
            // case it's the breaker, and no forward declaration is necessary.
            if (declarationNeeded.size === 1) {
                declarations.push({ kind: "define", type: defined(collectionUtils.iterableFirst(declarationNeeded)) });
                return;
            }
            // 2. No node in the cycle needs a declaration, but it's also
            // the only node, so we don't actually need a declaration at all.
            if (declarationNeeded.size === 0 && component.size === 1) {
                return;
            }
            // 3. No node in the cycle needs a declaration, but there's more.
            // than one node total.  We have to pick a node to make a
            // declaration, so we can pick any one. This is not a forward
            // declaration, either.
            if (declarationNeeded.size === 0) {
                declarations.push({ kind: "define", type: defined(collectionUtils.iterableFirst(component)) });
                return;
            }
            // 4. More than one node needs a declaration, and we don't need
            // forward declarations.  Just declare all of them and be done
            // with it.
            if (canBeForwardDeclared === undefined) {
                for (const t of declarationNeeded) {
                    declarations.push({ kind: "define", type: t });
                }
                return;
            }
            // 5. More than one node needs a declaration, and we have
            // to make forward declarations.  We do the simple thing and first
            // forward-declare all forward-declarable types in the SCC.  If
            // there are none, we're stuck.  If there are, we take them out of
            // the component and try the whole thing again recursively.  Then
            // we declare the types we previously forward-declared.
            const forwardDeclarable = collectionUtils.setFilter(component, canBeForwardDeclared);
            if (forwardDeclarable.size === 0) {
                return messageError("IRNoForwardDeclarableTypeInCycle", {});
            }
            for (const t of forwardDeclarable) {
                declarations.push({ kind: "forward", type: t });
            }
            collectionUtils.setUnionInto(forwardedTypes, forwardDeclarable);
            const rest = collectionUtils.setSubtract(component, forwardDeclarable);
            const restGraph = new Graph(rest, true, t => collectionUtils.setIntersect(childrenOfType(t), rest));
            processGraph(restGraph);
            for (const t of forwardDeclarable) {
                declarations.push({ kind: "define", type: t });
            }
            return;
        }
        /*
        if (_writeComponents) {
            componentsGraph.nodes.forEach(types => {
                console.log(
                    `scc: ${types
                        .filter(t => t instanceof ClassType)
                        .map(t => t.getCombinedName())
                        .join(", ")}`
                );
            });
        }
        */
        const rootsUnordered = componentsGraph.findRoots();
        const roots = rootsUnordered;
        for (const component of roots) {
            componentsGraph.dfsTraversal(component, topDown, visitComponent);
        }
    }
    const fullGraph = typeGraph.makeGraph(false, childrenOfType);
    // fs.writeFileSync("graph.dot", fullGraph.makeDot(t => !(t instanceof PrimitiveType), nodeTitle));
    processGraph(fullGraph);
    return new DeclarationIR(declarations, forwardedTypes);
}

class Namespace {
    constructor(_name, parent, forbiddenNamespaces, additionalForbidden) {
        this._children = new Set();
        this._members = new Set();
        this.forbiddenNamespaces = new Set(forbiddenNamespaces);
        this.additionalForbidden = new Set(additionalForbidden);
        if (parent !== undefined) {
            parent.addChild(this);
        }
    }
    addChild(child) {
        this._children.add(child);
    }
    get children() {
        return this._children;
    }
    get members() {
        return this._members;
    }
    get forbiddenNameds() {
        // FIXME: cache
        return collectionUtils.setUnion(this.additionalForbidden, ...Array.from(this.forbiddenNamespaces).map(ns => ns.members));
    }
    add(named) {
        this._members.add(named);
        return named;
    }
}
// `Namer`s are invoked to figure out what names to assign non-fixed `Name`s,
// and in particular to resolve conflicts.  Those arise under two circumstances,
// which can also combine:
//
// 1. A proposed name is the same as an already assigned name that's forbidden
//    for the name to be assigned.
// 2. There is more than one `Name` about to be assigned a name that all have
//    the same proposed name.
//
// The namer is invoked with the set of all assigned, forbidden names,
// the requested name, and the `Name`s to assign names to.
//
// `Namer` is a class so that we can compare namers and put them into immutable
// collections.
class Namer {
    constructor(name, nameStyle, prefixes) {
        this.name = name;
        this.nameStyle = nameStyle;
        this.prefixes = prefixes;
        this._prefixes = new Set(prefixes);
    }
    // The namesIterable comes directly out of the context and will
    // be modified if we assign
    assignNames(names, forbiddenNamesIterable, namesToAssignIterable) {
        const forbiddenNames = new Set(forbiddenNamesIterable);
        const namesToAssign = Array.from(namesToAssignIterable);
        assert(namesToAssign.length > 0, "Number of names can't be less than 1");
        const allAssignedNames = new Map();
        let namesToPrefix = [];
        for (const name of namesToAssign) {
            const proposedNames = name.proposeUnstyledNames(names);
            const namingFunction = name.namingFunction;
            // Find the first proposed name that isn't proposed by
            // any of the other names and that isn't already forbidden.
            const maybeUniqueName = collectionUtils.iterableFind(proposedNames, proposed => !forbiddenNames.has(namingFunction.nameStyle(proposed)) &&
                namesToAssign.every(n => n === name || !n.proposeUnstyledNames(names).has(proposed)));
            if (maybeUniqueName !== undefined) {
                const styledName = namingFunction.nameStyle(maybeUniqueName);
                const assigned = name.nameAssignments(forbiddenNames, styledName);
                if (assigned !== null) {
                    collectionUtils.mapMergeInto(allAssignedNames, assigned);
                    collectionUtils.setUnionInto(forbiddenNames, assigned.values());
                    continue;
                }
            }
            // There's no unique name, or it couldn't be assigned, so
            // we need to prefix-name this one.
            namesToPrefix.push(name);
        }
        let prefixes = this._prefixes.values();
        let suffixNumber = 1;
        for (const name of namesToPrefix) {
            const originalName = defined(collectionUtils.iterableFirst(name.proposeUnstyledNames(names)));
            for (;;) {
                let nameToTry;
                const { done, value: prefix } = prefixes.next();
                if (!done) {
                    nameToTry = `${prefix}_${originalName}`;
                }
                else {
                    nameToTry = `${originalName}_${suffixNumber.toString()}`;
                    suffixNumber++;
                }
                const styledName = name.namingFunction.nameStyle(nameToTry);
                const assigned = name.nameAssignments(forbiddenNames, styledName);
                if (assigned === null)
                    continue;
                collectionUtils.mapMergeInto(allAssignedNames, assigned);
                collectionUtils.setUnionInto(forbiddenNames, assigned.values());
                break;
            }
        }
        return allAssignedNames;
    }
}
const funPrefixes = [
    "Purple",
    "Fluffy",
    "Tentacled",
    "Sticky",
    "Indigo",
    "Indecent",
    "Hilarious",
    "Ambitious",
    "Cunning",
    "Magenta",
    "Frisky",
    "Mischievous",
    "Braggadocious"
];
function funPrefixNamer(name, nameStyle) {
    return new Namer(name, nameStyle, funPrefixes);
}
// FIXME: I think the type hierarchy is somewhat wrong here.  `FixedName`
// should be a `Name`, but the non-fixed names should probably have their
// own common superclass.  Most methods of `Name` make sense only either
// for `FixedName` or the non-fixed names.
class Name {
    // If a Named is fixed, the namingFunction is undefined.
    constructor(_namingFunction, order) {
        this._namingFunction = _namingFunction;
        this.order = order;
        this._associates = new Set();
    }
    addAssociate(associate) {
        this._associates.add(associate);
    }
    isFixed() {
        return this instanceof FixedName;
    }
    get namingFunction() {
        return defined(this._namingFunction);
    }
    firstProposedName(names) {
        return defined(collectionUtils.iterableFirst(this.proposeUnstyledNames(names)));
    }
    nameAssignments(forbiddenNames, assignedName) {
        if (forbiddenNames.has(assignedName))
            return null;
        const assignments = new Map([[this, assignedName]]);
        for (const an of this._associates) {
            const associatedAssignedName = an.getName(assignedName);
            if (forbiddenNames.has(associatedAssignedName)) {
                return null;
            }
            assignments.set(an, associatedAssignedName);
        }
        return assignments;
    }
}
// FIXME: FixedNameds should optionally be user-configurable
class FixedName extends Name {
    constructor(_fixedName) {
        super(undefined, 0);
        this._fixedName = _fixedName;
    }
    get dependencies() {
        return [];
    }
    addAssociate(_) {
        return panic("Cannot add associates to fixed names");
    }
    get fixedName() {
        return this._fixedName;
    }
    proposeUnstyledNames(_) {
        return panic("Only fixedName should be called on FixedName.");
    }
}
class SimpleName extends Name {
    constructor(unstyledNames, namingFunction, order) {
        super(namingFunction, order);
        this._unstyledNames = new Set(unstyledNames);
    }
    get dependencies() {
        return [];
    }
    proposeUnstyledNames(_) {
        return this._unstyledNames;
    }
}
class DependencyName extends Name {
    constructor(namingFunction, order, _proposeUnstyledName) {
        super(namingFunction, order);
        this._proposeUnstyledName = _proposeUnstyledName;
        const dependencies = [];
        _proposeUnstyledName(n => {
            dependencies.push(n);
            return "0xDEADBEEF";
        });
        this._dependencies = new Set(dependencies);
    }
    get dependencies() {
        return Array.from(this._dependencies);
    }
    proposeUnstyledNames(names) {
        return new Set([
            this._proposeUnstyledName(n => {
                assert(this._dependencies.has(n), "DependencyName proposer is not pure");
                return defined(names.get(n));
            })
        ]);
    }
}
function keywordNamespace(name, keywords) {
    const ns = new Namespace(name, undefined, [], []);
    for (const kw of keywords) {
        ns.add(new FixedName(kw));
    }
    return ns;
}
function allNamespacesRecursively(namespaces) {
    return collectionUtils.setUnion(namespaces, ...Array.from(collectionUtils.setMap(namespaces, ns => allNamespacesRecursively(ns.children))));
}
class NamingContext {
    constructor(rootNamespaces) {
        this._names = new Map();
        this._namedsForName = new Map();
        this.namespaces = allNamespacesRecursively(rootNamespaces);
    }
    get names() {
        return this._names;
    }
    isReadyToBeNamed(named) {
        if (this._names.has(named))
            return false;
        return named.dependencies.every((n) => this._names.has(n));
    }
    areForbiddensFullyNamed(namespace) {
        return collectionUtils.iterableEvery(namespace.forbiddenNameds, n => this._names.has(n));
    }
    isConflicting(namedNamespace, proposed) {
        const namedsForProposed = this._namedsForName.get(proposed);
        // If the name is not assigned at all, there is no conflict.
        if (namedsForProposed === undefined)
            return false;
        // The name is assigned, but it might still not be forbidden.
        for (const n of namedsForProposed) {
            if (namedNamespace.members.has(n) || namedNamespace.forbiddenNameds.has(n)) {
                return true;
            }
        }
        return false;
    }
    assign(named, namedNamespace, name) {
        assert(!this.names.has(named), `Name "${name}" assigned twice`);
        assert(!this.isConflicting(namedNamespace, name), `Assigned name "${name}" conflicts`);
        this._names.set(named, name);
        let namedsForName = this._namedsForName.get(name);
        if (namedsForName === undefined) {
            namedsForName = new Set();
            this._namedsForName.set(name, namedsForName);
        }
        namedsForName.add(named);
    }
}
// Naming algorithm
function assignNames(rootNamespaces) {
    const ctx = new NamingContext(rootNamespaces);
    // Assign all fixed names.
    for (const ns of ctx.namespaces) {
        for (const n of ns.members) {
            if (!n.isFixed())
                continue;
            ctx.assign(n, ns, n.fixedName);
        }
    }
    for (;;) {
        // 1. Find a namespace whose forbiddens are all fully named, and which has
        //    at least one unnamed Named that has all its dependencies satisfied.
        //    If no such namespace exists we're either done, or there's an unallowed
        //    cycle.
        const unfinishedNamespaces = collectionUtils.setFilter(ctx.namespaces, ns => ctx.areForbiddensFullyNamed(ns));
        const readyNamespace = collectionUtils.iterableFind(unfinishedNamespaces, ns => collectionUtils.iterableSome(ns.members, member => ctx.isReadyToBeNamed(member)));
        if (readyNamespace === undefined) {
            // FIXME: Check for cycles?
            return ctx.names;
        }
        const allForbiddenNames = collectionUtils.setUnion(readyNamespace.members, readyNamespace.forbiddenNameds);
        let forbiddenNames = collectionUtils.setFilterMap(allForbiddenNames, n => ctx.names.get(n));
        // 2. From low order to high order, sort those names into sets where all
        //    members of a set propose the same name and have the same naming
        //    function.
        for (;;) {
            const allReadyNames = collectionUtils.setFilter(readyNamespace.members, member => ctx.isReadyToBeNamed(member));
            const minOrderName = collectionUtils.iterableMinBy(allReadyNames, n => n.order);
            if (minOrderName === undefined)
                break;
            const minOrder = minOrderName.order;
            const readyNames = collectionUtils.setFilter(allReadyNames, n => n.order === minOrder);
            // It would be nice if we had tuples, then we wouldn't have to do this in
            // two steps.
            const byNamingFunction = collectionUtils.setGroupBy(readyNames, n => n.namingFunction);
            for (const [namer, namedsForNamingFunction] of byNamingFunction) {
                const byProposed = collectionUtils.setGroupBy(namedsForNamingFunction, n => n.namingFunction.nameStyle(n.firstProposedName(ctx.names)));
                for (const [, nameds] of byProposed) {
                    // 3. Use each set's naming function to name its members.
                    const names = namer.assignNames(ctx.names, forbiddenNames, nameds);
                    for (const [name, assigned] of names) {
                        ctx.assign(name, readyNamespace, assigned);
                    }
                    collectionUtils.setUnionInto(forbiddenNames, names.values());
                }
            }
        }
    }
}

// eslint-disable-next-line @typescript-eslint/no-extraneous-class
class AnnotationData {
}
class IssueAnnotationData extends AnnotationData {
    constructor(message) {
        super();
        this.message = message;
    }
}
const anyTypeIssueAnnotation = new IssueAnnotationData("quicktype cannot infer this type because there is no data about it in the input.");
const nullTypeIssueAnnotation = new IssueAnnotationData("The only value for this in the input is null, which means you probably need a more complete input sample.");

function newline() {
    // We're returning a new object instead of using a singleton
    // here because `Renderer` will modify `indentationChange`.
    return { kind: "newline", indentationChange: 0 };
}
function sourcelikeToSource(sl) {
    if (sl instanceof Array) {
        return {
            kind: "sequence",
            sequence: sl.map(sourcelikeToSource)
        };
    }
    if (typeof sl === "string") {
        const lines = sl.split("\n");
        if (lines.length === 1) {
            return { kind: "text", text: sl };
        }
        return {
            kind: "sequence",
            sequence: collectionUtils.arrayIntercalate(newline(), lines.map((l) => ({ kind: "text", text: l })))
        };
    }
    if (sl instanceof Name) {
        return { kind: "name", named: sl };
    }
    return sl;
}
function annotated(annotation, sl) {
    return {
        kind: "annotated",
        annotation,
        source: sourcelikeToSource(sl)
    };
}
function maybeAnnotated(doAnnotate, annotation, sl) {
    if (!doAnnotate) {
        return sl;
    }
    return annotated(annotation, sl);
}
function modifySource(modifier, sl) {
    return {
        kind: "modified",
        modifier,
        source: sourcelikeToSource(sl)
    };
}
function sourceLineLength(source, names) {
    switch (source.kind) {
        case "text":
            return source.text.length;
        case "newline":
            return panic("Newline must not occur within a line.");
        case "sequence":
            return source.sequence
                .map((s) => sourceLineLength(s, names))
                .reduce((a, b) => a + b, 0);
        case "table":
            return panic("Table must not occur within a  line.");
        case "annotated":
            return sourceLineLength(source.source, names);
        case "name":
            return defined(names.get(source.named)).length;
        case "modified":
            return serializeRenderResult(source, names, "").lines.join("\n").length;
        default:
            return assertNever(source);
    }
}
function serializeRenderResult(rootSource, names, indentation) {
    let indent = 0;
    let indentNeeded = 0;
    const lines = [];
    let currentLine = [];
    const annotations = [];
    function indentIfNeeded() {
        if (indentNeeded === 0)
            return;
        currentLine.push(repeatString(indentation, indentNeeded));
        indentNeeded = 0;
    }
    function flattenCurrentLine() {
        const str = currentLine.join("");
        currentLine = [str];
        return str;
    }
    function currentLocation() {
        return { line: lines.length, column: flattenCurrentLine().length };
    }
    function finishLine() {
        lines.push(flattenCurrentLine());
        currentLine = [];
    }
    function serializeToStringArray(source) {
        switch (source.kind) {
            case "text":
                indentIfNeeded();
                currentLine.push(source.text);
                break;
            case "newline":
                finishLine();
                indent += source.indentationChange;
                indentNeeded = indent;
                break;
            case "sequence":
                for (const s of source.sequence) {
                    serializeToStringArray(s);
                }
                break;
            case "table":
                const t = source.table;
                const numRows = t.length;
                if (numRows === 0)
                    break;
                const widths = t.map(l => l.map(s => sourceLineLength(s, names)));
                const numColumns = defined(collectionUtils.iterableMax(t.map(l => l.length)));
                if (numColumns === 0)
                    break;
                const columnWidths = [];
                for (let i = 0; i < numColumns; i++) {
                    columnWidths.push(defined(collectionUtils.iterableMax(widths.map(l => collectionUtils.withDefault(l[i], 0)))));
                }
                for (let y = 0; y < numRows; y++) {
                    indentIfNeeded();
                    const row = defined(t[y]);
                    const rowWidths = defined(widths[y]);
                    for (let x = 0; x < numColumns; x++) {
                        const colWidth = columnWidths[x];
                        const src = collectionUtils.withDefault(row[x], { kind: "text", text: "" });
                        const srcWidth = collectionUtils.withDefault(rowWidths[x], 0);
                        serializeToStringArray(src);
                        if (x < numColumns - 1 && srcWidth < colWidth) {
                            currentLine.push(repeatString(" ", colWidth - srcWidth));
                        }
                    }
                    if (y < numRows - 1) {
                        finishLine();
                        indentNeeded = indent;
                    }
                }
                break;
            case "annotated":
                const start = currentLocation();
                serializeToStringArray(source.source);
                const end = currentLocation();
                annotations.push({ annotation: source.annotation, span: { start, end } });
                break;
            case "name":
                assert(names.has(source.named), "No name for Named");
                indentIfNeeded();
                currentLine.push(defined(names.get(source.named)));
                break;
            case "modified":
                indentIfNeeded();
                const serialized = serializeRenderResult(source.source, names, indentation).lines;
                assert(serialized.length === 1, "Cannot modify more than one line.");
                currentLine.push(source.modifier(serialized[0]));
                break;
            default:
                return assertNever(source);
        }
    }
    serializeToStringArray(rootSource);
    finishLine();
    return { lines, annotations: annotations };
}
function singleWord(...source) {
    return { source, needsParens: false };
}
function multiWord(separator, ...words) {
    assert(words.length > 0, "Zero words is not multiple");
    if (words.length === 1) {
        return singleWord(words[0]);
    }
    const items = [];
    for (let i = 0; i < words.length; i++) {
        if (i > 0)
            items.push(separator);
        items.push(words[i]);
    }
    return { source: items, needsParens: true };
}
function parenIfNeeded({ source, needsParens }) {
    if (needsParens) {
        return ["(", source, ")"];
    }
    return source;
}

function getBlankLineConfig(cfg) {
    if (Array.isArray(cfg)) {
        return { position: cfg[0], count: cfg[1] };
    }
    return { position: cfg, count: 1 };
}
function lineIndentation(line) {
    const len = line.length;
    let indent = 0;
    for (let i = 0; i < len; i++) {
        const c = line.charAt(i);
        if (c === " ") {
            indent += 1;
        }
        else if (c === "\t") {
            indent = (indent / 4 + 1) * 4;
        }
        else {
            return { indent, text: line.substring(i) };
        }
    }
    return { indent: 0, text: null };
}
class EmitContext {
    constructor() {
        this._currentEmitTarget = this._emitted = [];
        this._numBlankLinesNeeded = 0;
        this._preventBlankLine = true; // no blank lines at start of file
    }
    get isEmpty() {
        return this._emitted.length === 0;
    }
    get isNested() {
        return this._emitted !== this._currentEmitTarget;
    }
    get source() {
        return this._emitted;
    }
    pushItem(item) {
        this._currentEmitTarget.push(item);
        this._preventBlankLine = false;
    }
    emitNewline() {
        const nl = newline();
        this.pushItem(nl);
        this._lastNewline = nl;
    }
    emitItem(item) {
        if (!this.isEmpty) {
            for (let i = 0; i < this._numBlankLinesNeeded; i++) {
                this.emitNewline();
            }
        }
        this._numBlankLinesNeeded = 0;
        this.pushItem(item);
    }
    containsItem(item) {
        const existingItem = this._currentEmitTarget.find((value) => item === value);
        return existingItem !== undefined;
    }
    ensureBlankLine(numBlankLines) {
        if (this._preventBlankLine)
            return;
        this._numBlankLinesNeeded = Math.max(this._numBlankLinesNeeded, numBlankLines);
    }
    preventBlankLine() {
        this._numBlankLinesNeeded = 0;
        this._preventBlankLine = true;
    }
    changeIndent(offset) {
        if (this._lastNewline === undefined) {
            return panic("Cannot change indent for the first line");
        }
        this._lastNewline.indentationChange += offset;
    }
}
class Renderer {
    constructor(targetLanguage, renderContext) {
        this.targetLanguage = targetLanguage;
        this.emitTable = (tableArray) => {
            if (tableArray.length === 0)
                return;
            const table = tableArray.map(r => r.map(sl => sourcelikeToSource(sl)));
            this._emitContext.emitItem({ kind: "table", table });
            this._emitContext.emitNewline();
        };
        this.typeGraph = renderContext.typeGraph;
        this.leadingComments = renderContext.leadingComments;
        this._finishedFiles = new Map();
        this._finishedEmitContexts = new Map();
        this._emitContext = new EmitContext();
    }
    // FIXME: make protected once JavaDateTimeRenderer is refactored
    ensureBlankLine(numBlankLines = 1) {
        this._emitContext.ensureBlankLine(numBlankLines);
    }
    preventBlankLine() {
        this._emitContext.preventBlankLine();
    }
    emitItem(item) {
        this._emitContext.emitItem(item);
    }
    emitItemOnce(item) {
        if (this._emitContext.containsItem(item)) {
            return false;
        }
        this.emitItem(item);
        return true;
    }
    emitLineOnce(...lineParts) {
        let lineEmitted = true;
        if (lineParts.length === 1) {
            lineEmitted = this.emitItemOnce(lineParts[0]);
        }
        else if (lineParts.length > 1) {
            lineEmitted = this.emitItemOnce(lineParts);
        }
        if (lineEmitted) {
            this._emitContext.emitNewline();
        }
    }
    // FIXME: make protected once JavaDateTimeRenderer is refactored
    emitLine(...lineParts) {
        if (lineParts.length === 1) {
            this._emitContext.emitItem(lineParts[0]);
        }
        else if (lineParts.length > 1) {
            this._emitContext.emitItem(lineParts);
        }
        this._emitContext.emitNewline();
    }
    emitMultiline(linesString) {
        const lines = linesString.split("\n");
        const numLines = lines.length;
        if (numLines === 0)
            return;
        this.emitLine(lines[0]);
        let currentIndent = 0;
        for (let i = 1; i < numLines; i++) {
            const line = lines[i];
            const { indent, text } = lineIndentation(line);
            assert(indent % 4 === 0, "Indentation is not a multiple of 4.");
            if (text !== null) {
                const newIndent = indent / 4;
                this.changeIndent(newIndent - currentIndent);
                currentIndent = newIndent;
                this.emitLine(text);
            }
            else {
                this._emitContext.emitNewline();
            }
        }
        if (currentIndent !== 0) {
            this.changeIndent(-currentIndent);
        }
    }
    gatherSource(emitter) {
        const oldEmitContext = this._emitContext;
        this._emitContext = new EmitContext();
        emitter();
        assert(!this._emitContext.isNested, "emit context not restored correctly");
        const source = this._emitContext.source;
        this._emitContext = oldEmitContext;
        return source;
    }
    emitGatheredSource(items) {
        for (const item of items) {
            this._emitContext.emitItem(item);
        }
    }
    emitAnnotated(annotation, emitter) {
        const lines = this.gatherSource(emitter);
        const source = sourcelikeToSource(lines);
        this._emitContext.emitItem(annotated(annotation, source));
    }
    emitIssue(message, emitter) {
        this.emitAnnotated(new IssueAnnotationData(message), emitter);
    }
    changeIndent(offset) {
        this._emitContext.changeIndent(offset);
    }
    iterableForEach(iterable, emitter) {
        const items = Array.from(iterable);
        let onFirst = true;
        for (const [i, v] of collectionUtils.iterableEnumerate(items)) {
            const position = items.length === 1 ? "only" : onFirst ? "first" : i === items.length - 1 ? "last" : "middle";
            emitter(v, position);
            onFirst = false;
        }
    }
    forEach(iterable, interposedBlankLines, leadingBlankLines, emitter) {
        let didEmit = false;
        this.iterableForEach(iterable, ([k, v], position) => {
            if (position === "only" || position === "first") {
                this.ensureBlankLine(leadingBlankLines);
            }
            else {
                this.ensureBlankLine(interposedBlankLines);
            }
            emitter(v, k, position);
            didEmit = true;
        });
        return didEmit;
    }
    forEachWithBlankLines(iterable, blankLineConfig, emitter) {
        const { position, count } = getBlankLineConfig(blankLineConfig);
        const interposing = ["interposing", "leading-and-interposing"].includes(position);
        const leading = ["leading", "leading-and-interposing"].includes(position);
        return this.forEach(iterable, interposing ? count : 0, leading ? count : 0, emitter);
    }
    // FIXME: make protected once JavaDateTimeRenderer is refactored
    indent(fn) {
        this.changeIndent(1);
        fn();
        this.changeIndent(-1);
    }
    assignNames() {
        return assignNames(this.setUpNaming());
    }
    initializeEmitContextForFilename(filename) {
        if (this._finishedEmitContexts.has(filename.toLowerCase())) {
            const existingEmitContext = this._finishedEmitContexts.get(filename.toLowerCase());
            if (existingEmitContext !== undefined) {
                this._emitContext = existingEmitContext;
            }
        }
    }
    finishFile(filename) {
        if (this._finishedFiles.has(filename)) {
            console.log(`[WARNING] Tried to emit file ${filename} more than once. If performing multi-file output this warning can be safely ignored.`);
        }
        const source = sourcelikeToSource(this._emitContext.source);
        this._finishedFiles.set(filename, source);
        // [Michael Fey (@MrRooni), 2019-5-9] We save the current EmitContext for possible reuse later. We put it into the map with a lowercased version of the key so we can do a case-insensitive lookup later. The reason we lowercase it is because some schema (looking at you keyword-unions.schema) define objects of the same name with different casing. BOOL vs. bool, for example.
        this._finishedEmitContexts.set(filename.toLowerCase(), this._emitContext);
        this._emitContext = new EmitContext();
    }
    render(givenOutputFilename) {
        this._names = this.assignNames();
        this.emitSource(givenOutputFilename);
        if (!this._emitContext.isEmpty) {
            this.finishFile(givenOutputFilename);
        }
        return { sources: this._finishedFiles, names: this._names };
    }
    get names() {
        if (this._names === undefined) {
            return panic("Names accessed before they were assigned");
        }
        return this._names;
    }
}

const isStringComment = (comment) => {
    return typeof comment === "string";
};

const wordWrap = _wordwrap(90);
const topLevelNameOrder = 1;
const givenNameOrder = 10;
const inferredNameOrder = 30;
const classPropertyNameOrder = 20;
const assignedClassPropertyNameOrder = 10;
const enumCaseNameOrder = 20;
const assignedEnumCaseNameOrder = 10;
const unionMemberNameOrder = 40;
function splitDescription(descriptions) {
    if (descriptions === undefined)
        return undefined;
    const description = Array.from(descriptions).join("\n\n").trim();
    if (description === "")
        return undefined;
    return wordWrap(description)
        .split("\n")
        .map(l => l.trim());
}
const assignedNameAttributeKind = new TypeAttributeKind("assignedName");
const assignedPropertyNamesAttributeKind = new TypeAttributeKind("assignedPropertyNames");
const assignedMemberNamesAttributeKind = new TypeAttributeKind("assignedMemberNames");
const assignedCaseNamesAttributeKind = new TypeAttributeKind("assignedCaseNames");
class ConvenienceRenderer extends Renderer {
    constructor(targetLanguage, renderContext) {
        super(targetLanguage, renderContext);
        this._alphabetizeProperties = false;
    }
    get topLevels() {
        return this.typeGraph.topLevels;
    }
    /**
     * Return an array of strings which are not allowed as names in the global
     * namespace.  Since names of generated types are in the global namespace,
     * this will include anything built into the language or default libraries
     * that can conflict with that, such as reserved keywords or common type
     * names.
     */
    forbiddenNamesForGlobalNamespace() {
        return [];
    }
    /**
     * Returns which names are forbidden for the property names of an object
     * type.  `names` can contain strings as well as `Name`s.  In some
     * languages, the class name can't be used as the name for a property, for
     * example, in which case `_className` would have to be return in `names`.
     * If `includeGlobalForbidden` is set, then all names that are forbidden
     * in the global namespace will also be forbidden for the properties.
     * Note: That doesn't mean that the names in the global namespace will be
     * forbidden, too!
     */
    forbiddenForObjectProperties(_o, _className) {
        return { names: [], includeGlobalForbidden: false };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: false };
    }
    makeTopLevelDependencyNames(_t, _topLevelName) {
        return [];
    }
    makeNamedTypeDependencyNames(_t, _name) {
        return [];
    }
    makeNameForTransformation(_xf, _typeName) {
        return undefined;
    }
    namedTypeToNameForTopLevel(type) {
        if (isNamedType(type)) {
            return type;
        }
        return undefined;
    }
    get unionMembersInGlobalNamespace() {
        return false;
    }
    get enumCasesInGlobalNamespace() {
        return false;
    }
    get needsTypeDeclarationBeforeUse() {
        return false;
    }
    canBeForwardDeclared(_t) {
        return panic("If needsTypeDeclarationBeforeUse returns true, canBeForwardDeclared must be implemented");
    }
    unionNeedsName(u) {
        return nullableFromUnion(u) === null;
    }
    get globalNamespace() {
        return defined(this._globalNamespace);
    }
    get nameStoreView() {
        return defined(this._nameStoreView);
    }
    descriptionForType(t) {
        let description = this.typeGraph.attributeStore.tryGet(descriptionTypeAttributeKind, t);
        return splitDescription(description);
    }
    descriptionForClassProperty(o, name) {
        const descriptions = this.typeGraph.attributeStore.tryGet(propertyDescriptionsTypeAttributeKind, o);
        if (descriptions === undefined)
            return undefined;
        return splitDescription(descriptions.get(name));
    }
    setUpNaming() {
        this._nameStoreView = new TypeAttributeStoreView(this.typeGraph.attributeStore, assignedNameAttributeKind);
        this._propertyNamesStoreView = new TypeAttributeStoreView(this.typeGraph.attributeStore, assignedPropertyNamesAttributeKind);
        this._memberNamesStoreView = new TypeAttributeStoreView(this.typeGraph.attributeStore, assignedMemberNamesAttributeKind);
        this._caseNamesStoreView = new TypeAttributeStoreView(this.typeGraph.attributeStore, assignedCaseNamesAttributeKind);
        this._namesForTransformations = new Map();
        this._namedTypeNamer = this.makeNamedTypeNamer();
        this._unionMemberNamer = this.makeUnionMemberNamer();
        this._enumCaseNamer = this.makeEnumCaseNamer();
        this._globalForbiddenNamespace = keywordNamespace("forbidden", this.forbiddenNamesForGlobalNamespace());
        this._otherForbiddenNamespaces = new Map();
        this._globalNamespace = new Namespace("global", undefined, [this._globalForbiddenNamespace], []);
        const { objects, enums, unions } = this.typeGraph.allNamedTypesSeparated();
        const namedUnions = collectionUtils.setFilter(unions, u => this.unionNeedsName(u));
        for (const [name, t] of this.topLevels) {
            this.nameStoreView.setForTopLevel(name, this.addNameForTopLevel(t, name));
        }
        for (const o of objects) {
            const name = this.addNameForNamedType(o);
            this.addPropertyNames(o, name);
        }
        for (const e of enums) {
            const name = this.addNameForNamedType(e);
            this.addEnumCaseNames(e, name);
        }
        for (const u of namedUnions) {
            const name = this.addNameForNamedType(u);
            this.addUnionMemberNames(u, name);
        }
        for (const t of this.typeGraph.allTypesUnordered()) {
            this.addNameForTransformation(t);
        }
        return collectionUtils.setUnion([this._globalForbiddenNamespace, this._globalNamespace], this._otherForbiddenNamespaces.values());
    }
    addDependenciesForNamedType(type, named) {
        const dependencyNames = this.makeNamedTypeDependencyNames(type, named);
        for (const dn of dependencyNames) {
            this.globalNamespace.add(dn);
        }
    }
    makeNameForTopLevel(_t, givenName, _maybeNamedType) {
        return new SimpleName([givenName], defined(this._namedTypeNamer), topLevelNameOrder);
    }
    addNameForTopLevel(type, givenName) {
        const maybeNamedType = this.namedTypeToNameForTopLevel(type);
        const name = this.makeNameForTopLevel(type, givenName, maybeNamedType);
        this.globalNamespace.add(name);
        const dependencyNames = this.makeTopLevelDependencyNames(type, name);
        for (const dn of dependencyNames) {
            this.globalNamespace.add(dn);
        }
        if (maybeNamedType !== undefined) {
            this.addDependenciesForNamedType(maybeNamedType, name);
            this.nameStoreView.set(maybeNamedType, name);
        }
        return name;
    }
    makeNameForType(t, namer, givenOrder, inferredOrder) {
        const names = t.getNames();
        const order = names.areInferred ? inferredOrder : givenOrder;
        return new SimpleName(names.proposedNames, namer, order);
    }
    makeNameForNamedType(t) {
        return this.makeNameForType(t, defined(this._namedTypeNamer), givenNameOrder, inferredNameOrder);
    }
    addNameForNamedType(type) {
        const existing = this.nameStoreView.tryGet(type);
        if (existing !== undefined)
            return existing;
        const name = this.globalNamespace.add(this.makeNameForNamedType(type));
        this.addDependenciesForNamedType(type, name);
        this.nameStoreView.set(type, name);
        return name;
    }
    get typesWithNamedTransformations() {
        return defined(this._namesForTransformations);
    }
    nameForTransformation(t) {
        const xf = transformationForType(t);
        if (xf === undefined)
            return undefined;
        const name = defined(this._namesForTransformations).get(t);
        if (name === undefined) {
            return panic("No name for transformation");
        }
        return name;
    }
    addNameForTransformation(t) {
        const xf = transformationForType(t);
        if (xf === undefined)
            return;
        assert(defined(this._namesForTransformations).get(t) === undefined, "Tried to give two names to the same transformation");
        const name = this.makeNameForTransformation(xf, this.nameStoreView.tryGet(xf.targetType));
        if (name === undefined)
            return;
        this.globalNamespace.add(name);
        defined(this._namesForTransformations).set(t, name);
    }
    processForbiddenWordsInfo(info, namespaceName) {
        const forbiddenNames = [];
        const forbiddenStrings = [];
        for (const nameOrString of info.names) {
            if (typeof nameOrString === "string") {
                forbiddenStrings.push(nameOrString);
            }
            else {
                forbiddenNames.push(nameOrString);
            }
        }
        let namespace = defined(this._otherForbiddenNamespaces).get(namespaceName);
        if (forbiddenStrings.length > 0 && namespace === undefined) {
            namespace = keywordNamespace(namespaceName, forbiddenStrings);
            this._otherForbiddenNamespaces = defined(this._otherForbiddenNamespaces).set(namespaceName, namespace);
        }
        let forbiddenNamespaces = new Set();
        if (info.includeGlobalForbidden) {
            forbiddenNamespaces = forbiddenNamespaces.add(defined(this._globalForbiddenNamespace));
        }
        if (namespace !== undefined) {
            forbiddenNamespaces = forbiddenNamespaces.add(namespace);
        }
        return { forbiddenNames: new Set(forbiddenNames), forbiddenNamespaces };
    }
    makeNameForProperty(o, _className, p, jsonName, assignedName) {
        const namer = this.namerForObjectProperty(o, p);
        if (namer === null)
            return undefined;
        // FIXME: This alternative should really depend on what the
        // actual name of the class ends up being.  We can do this
        // with a DependencyName.
        // Also, we currently don't have any languages where properties
        // are global, so collisions here could only occur where two
        // properties of the same class have the same name, in which case
        // the alternative would also be the same, i.e. useless.  But
        // maybe we'll need global properties for some weird language at
        // some point.
        const alternative = `${o.getCombinedName()}_${jsonName}`;
        const order = assignedName === undefined ? classPropertyNameOrder : assignedClassPropertyNameOrder;
        const names = assignedName === undefined ? [jsonName, alternative] : [assignedName];
        return new SimpleName(names, namer, order);
    }
    makePropertyDependencyNames(_o, _className, _p, _jsonName, _name) {
        return [];
    }
    addPropertyNames(o, className) {
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForObjectProperties(o, className), "forbidden-for-properties");
        let ns;
        const accessorNames = objectPropertyNames(o, this.targetLanguage.name);
        const names = collectionUtils.mapFilterMap(o.getSortedProperties(), (p, jsonName) => {
            const [assignedName, isFixed] = getAccessorName(accessorNames, jsonName);
            let name;
            if (isFixed) {
                name = new FixedName(defined(assignedName));
            }
            else {
                name = this.makeNameForProperty(o, className, p, jsonName, assignedName);
            }
            if (name === undefined)
                return undefined;
            if (ns === undefined) {
                ns = new Namespace(o.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
            }
            ns.add(name);
            for (const depName of this.makePropertyDependencyNames(o, className, p, jsonName, name)) {
                ns.add(depName);
            }
            return name;
        });
        defined(this._propertyNamesStoreView).set(o, names);
    }
    makeNameForUnionMember(u, unionName, t) {
        const [assignedName, isFixed] = unionMemberName(u, t, this.targetLanguage.name);
        if (isFixed) {
            return new FixedName(defined(assignedName));
        }
        return new DependencyName(nonNull(this._unionMemberNamer), unionMemberNameOrder, lookup => {
            if (assignedName !== undefined)
                return assignedName;
            return this.proposeUnionMemberName(u, unionName, t, lookup);
        });
    }
    addUnionMemberNames(u, unionName) {
        const memberNamer = this._unionMemberNamer;
        if (memberNamer === null)
            return;
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForUnionMembers(u, unionName), "forbidden-for-union-members");
        let ns;
        if (this.unionMembersInGlobalNamespace) {
            ns = this.globalNamespace;
        }
        else {
            ns = new Namespace(u.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
        }
        let names = new Map();
        for (const t of u.members) {
            const name = this.makeNameForUnionMember(u, unionName, followTargetType(t));
            names.set(t, ns.add(name));
        }
        defined(this._memberNamesStoreView).set(u, names);
    }
    makeNameForEnumCase(e, _enumName, caseName, assignedName) {
        // FIXME: See the FIXME in `makeNameForProperty`.  We do have global
        // enum cases, though (in Go), so this is actually useful already.
        const alternative = `${e.getCombinedName()}_${caseName}`;
        const order = assignedName === undefined ? enumCaseNameOrder : assignedEnumCaseNameOrder;
        const names = assignedName === undefined ? [caseName, alternative] : [assignedName];
        return new SimpleName(names, nonNull(this._enumCaseNamer), order);
    }
    // FIXME: this is very similar to addPropertyNameds and addUnionMemberNames
    addEnumCaseNames(e, enumName) {
        if (this._enumCaseNamer === null)
            return;
        const { forbiddenNames, forbiddenNamespaces } = this.processForbiddenWordsInfo(this.forbiddenForEnumCases(e, enumName), "forbidden-for-enum-cases");
        let ns;
        if (this.enumCasesInGlobalNamespace) {
            ns = this.globalNamespace;
        }
        else {
            ns = new Namespace(e.getCombinedName(), this.globalNamespace, forbiddenNamespaces, forbiddenNames);
        }
        let names = new Map();
        const accessorNames = enumCaseNames(e, this.targetLanguage.name);
        for (const caseName of e.cases) {
            const [assignedName, isFixed] = getAccessorName(accessorNames, caseName);
            let name;
            if (isFixed) {
                name = new FixedName(defined(assignedName));
            }
            else {
                name = this.makeNameForEnumCase(e, enumName, caseName, assignedName);
            }
            names.set(caseName, ns.add(name));
        }
        defined(this._caseNamesStoreView).set(e, names);
    }
    childrenOfType(t) {
        const names = this.names;
        if (t instanceof ClassType) {
            const propertyNameds = defined(this._propertyNamesStoreView).get(t);
            const filteredMap = collectionUtils.mapFilterMap(t.getProperties(), (p, n) => {
                if (propertyNameds.get(n) === undefined)
                    return undefined;
                return p.type;
            });
            const sortedMap = collectionUtils.mapSortBy(filteredMap, (_, n) => defined(names.get(defined(propertyNameds.get(n)))));
            return new Set(sortedMap.values());
        }
        return t.getChildren();
    }
    get namedUnions() {
        return defined(this._namedUnions);
    }
    get haveNamedUnions() {
        return this.namedUnions.size > 0;
    }
    get haveNamedTypes() {
        return defined(this._namedTypes).length > 0;
    }
    get haveUnions() {
        return defined(this._haveUnions);
    }
    get haveMaps() {
        return defined(this._haveMaps);
    }
    get haveOptionalProperties() {
        return defined(this._haveOptionalProperties);
    }
    // FIXME: Inconsistently named, though technically correct.  Right now all enums are named,
    // but this should really be called `namedEnums`.
    get enums() {
        return defined(this._namedEnums);
    }
    get haveEnums() {
        return this.enums.size > 0;
    }
    proposedUnionMemberNameForTypeKind(_kind) {
        return null;
    }
    proposeUnionMemberName(_u, _unionName, fieldType, lookup) {
        const simpleName = this.proposedUnionMemberNameForTypeKind(fieldType.kind);
        if (simpleName !== null) {
            return simpleName;
        }
        const typeNameForUnionMember = (t) => matchTypeExhaustive(t, _noneType => {
            return panic("none type should have been replaced");
        }, _anyType => "anything", _nullType => "null", _boolType => "bool", _integerType => "integer", _doubleType => "double", _stringType => "string", arrayType => typeNameForUnionMember(arrayType.items) + "_array", classType => lookup(this.nameForNamedType(classType)), mapType => typeNameForUnionMember(mapType.values) + "_map", objectType => {
            assert(this.targetLanguage.supportsFullObjectType, "Object type should have been replaced in `replaceObjectType`");
            return lookup(this.nameForNamedType(objectType));
        }, _enumType => "enum", _unionType => "union", transformedType => transformedType.kind.replace("-", "_"));
        return typeNameForUnionMember(fieldType);
    }
    nameForNamedType(t) {
        return this.nameStoreView.get(t);
    }
    isForwardDeclaredType(t) {
        return defined(this._declarationIR).forwardedTypes.has(t);
    }
    isImplicitCycleBreaker(_t) {
        return panic("A renderer that invokes isCycleBreakerType must implement isImplicitCycleBreaker");
    }
    canBreakCycles(_t) {
        return true;
    }
    isCycleBreakerType(t) {
        if (this._cycleBreakerTypes === undefined) {
            this._cycleBreakerTypes = cycleBreakerTypesForGraph(this.typeGraph, s => this.isImplicitCycleBreaker(s), s => this.canBreakCycles(s));
        }
        return this._cycleBreakerTypes.has(t);
    }
    forEachTopLevel(blankLocations, f, predicate) {
        let topLevels;
        if (predicate !== undefined) {
            topLevels = collectionUtils.mapFilter(this.topLevels, predicate);
        }
        else {
            topLevels = this.topLevels;
        }
        return this.forEachWithBlankLines(topLevels, blankLocations, (t, name, pos) => f(t, this.nameStoreView.getForTopLevel(name), pos));
    }
    forEachDeclaration(blankLocations, f) {
        this.forEachWithBlankLines(collectionUtils.iterableEnumerate(defined(this._declarationIR).declarations), blankLocations, (decl, _, pos) => f(decl, pos));
    }
    setAlphabetizeProperties(value) {
        this._alphabetizeProperties = value;
    }
    getAlphabetizeProperties() {
        return this._alphabetizeProperties;
    }
    // Returns the number of properties defined for the specified object type.
    propertyCount(o) {
        const propertyNames = defined(this._propertyNamesStoreView).get(o);
        return propertyNames.size;
    }
    sortClassProperties(properties, propertyNames) {
        if (this._alphabetizeProperties) {
            return collectionUtils.mapSortBy(properties, (_p, jsonName) => {
                const name = defined(propertyNames.get(jsonName));
                return defined(this.names.get(name));
            });
        }
        else {
            return properties;
        }
    }
    forEachClassProperty(o, blankLocations, f) {
        const propertyNames = defined(this._propertyNamesStoreView).get(o);
        const sortedProperties = this.sortClassProperties(o.getProperties(), propertyNames);
        this.forEachWithBlankLines(sortedProperties, blankLocations, (p, jsonName, pos) => {
            const name = defined(propertyNames.get(jsonName));
            f(name, jsonName, p, pos);
        });
    }
    nameForUnionMember(u, t) {
        return defined(defined(this._memberNamesStoreView).get(u).get(t));
    }
    nameForEnumCase(e, caseName) {
        const caseNames = defined(this._caseNamesStoreView).get(e);
        return defined(caseNames.get(caseName));
    }
    forEachUnionMember(u, members, blankLocations, sortOrder, f) {
        const iterateMembers = members !== null && members !== void 0 ? members : u.members;
        if (sortOrder === null) {
            sortOrder = (n) => defined(this.names.get(n));
        }
        const memberNames = collectionUtils.mapFilter(defined(this._memberNamesStoreView).get(u), (_, t) => iterateMembers.has(t));
        const sortedMemberNames = collectionUtils.mapSortBy(memberNames, sortOrder);
        this.forEachWithBlankLines(sortedMemberNames, blankLocations, f);
    }
    forEachEnumCase(e, blankLocations, f) {
        const caseNames = defined(this._caseNamesStoreView).get(e);
        const sortedCaseNames = collectionUtils.mapSortBy(caseNames, n => defined(this.names.get(n)));
        this.forEachWithBlankLines(sortedCaseNames, blankLocations, f);
    }
    forEachTransformation(blankLocations, f) {
        this.forEachWithBlankLines(defined(this._namesForTransformations), blankLocations, f);
    }
    forEachSpecificNamedType(blankLocations, types, f) {
        this.forEachWithBlankLines(types, blankLocations, (t, _, pos) => f(t, this.nameForNamedType(t), pos));
    }
    forEachObject(blankLocations, f) {
        // FIXME: This is ugly.
        this.forEachSpecificNamedType(blankLocations, defined(this._namedObjects).entries(), f);
    }
    forEachEnum(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, this.enums.entries(), f);
    }
    forEachUnion(blankLocations, f) {
        this.forEachSpecificNamedType(blankLocations, this.namedUnions.entries(), f);
    }
    forEachUniqueUnion(blankLocations, uniqueValue, f) {
        const firstUnionByValue = new Map();
        for (const u of this.namedUnions) {
            const v = uniqueValue(u);
            if (!firstUnionByValue.has(v)) {
                firstUnionByValue.set(v, u);
            }
        }
        this.forEachWithBlankLines(firstUnionByValue, blankLocations, f);
    }
    forEachNamedType(blankLocations, objectFunc, enumFunc, unionFunc) {
        this.forEachWithBlankLines(defined(this._namedTypes).entries(), blankLocations, (t, _, pos) => {
            const name = this.nameForNamedType(t);
            if (t instanceof ObjectType) {
                // FIXME: This is ugly.  We can't runtime check that the function
                // takes full object types if we have them.
                objectFunc(t, name, pos);
            }
            else if (t instanceof EnumType) {
                enumFunc(t, name, pos);
            }
            else if (t instanceof UnionType) {
                unionFunc(t, name, pos);
            }
            else {
                return panic("Named type that's neither a class nor union");
            }
        });
    }
    // You should never have to use this to produce parts of your generated
    // code.  If you need to modify a Name, for example to change its casing,
    // use `modifySource`.
    sourcelikeToString(src) {
        return serializeRenderResult(sourcelikeToSource(src), this.names, "").lines.join("\n");
    }
    get commentLineStart() {
        return "// ";
    }
    emitComments(comments) {
        comments.forEach(comment => {
            if (isStringComment(comment)) {
                this.emitCommentLines([comment]);
            }
            else if ("lines" in comment) {
                this.emitCommentLines(comment.lines);
            }
            else if ("descriptionBlock" in comment) {
                this.emitDescriptionBlock(comment.descriptionBlock);
            }
            else {
                this.emitCommentLines(comment.customLines, comment);
            }
            this.ensureBlankLine();
        });
    }
    emitCommentLines(lines, { lineStart = this.commentLineStart, firstLineStart = lineStart, lineEnd, beforeComment, afterComment } = {}) {
        if (beforeComment !== undefined) {
            this.emitLine(beforeComment);
        }
        let first = true;
        for (const line of lines) {
            let start = first ? firstLineStart : lineStart;
            first = false;
            if (this.sourcelikeToString(line) === "") {
                start = trimEnd(start);
            }
            if (lineEnd) {
                this.emitLine(start, line, lineEnd);
            }
            else {
                this.emitLine(start, line);
            }
        }
        if (afterComment !== undefined) {
            this.emitLine(afterComment);
        }
    }
    emitDescription(description) {
        if (description === undefined)
            return;
        // FIXME: word-wrap
        this.emitDescriptionBlock(description);
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines);
    }
    emitPropertyTable(c, makePropertyRow) {
        let table = [];
        const emitTable = () => {
            if (table.length === 0)
                return;
            this.emitTable(table);
            table = [];
        };
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== undefined) {
                emitTable();
                this.emitDescription(description);
            }
            table.push(makePropertyRow(name, jsonName, p));
        });
        emitTable();
    }
    processGraph() {
        this._declarationIR = declarationsForGraph(this.typeGraph, this.needsTypeDeclarationBeforeUse ? (t) => this.canBeForwardDeclared(t) : undefined, t => this.childrenOfType(t), t => {
            if (t instanceof UnionType) {
                return this.unionNeedsName(t);
            }
            return isNamedType(t);
        });
        const types = this.typeGraph.allTypesUnordered();
        this._haveUnions = collectionUtils.iterableSome(types, t => t instanceof UnionType);
        this._haveMaps = collectionUtils.iterableSome(types, t => t instanceof MapType);
        const classTypes = collectionUtils.setFilter(types, t => t instanceof ClassType);
        this._haveOptionalProperties = collectionUtils.iterableSome(classTypes, c => collectionUtils.mapSome(c.getProperties(), p => p.isOptional));
        this._namedTypes = this._declarationIR.declarations.filter(d => d.kind === "define").map(d => d.type);
        const { objects, enums, unions } = separateNamedTypes(this._namedTypes);
        this._namedObjects = new Set(objects);
        this._namedEnums = new Set(enums);
        this._namedUnions = new Set(unions);
    }
    emitSource(givenOutputFilename) {
        this.processGraph();
        this.emitSourceStructure(givenOutputFilename);
    }
    forEachType(process) {
        const visitedTypes = new Set();
        const processed = new Set();
        const queue = Array.from(this.typeGraph.topLevels.values());
        function visit(t) {
            if (visitedTypes.has(t))
                return;
            for (const c of t.getChildren()) {
                queue.push(c);
            }
            visitedTypes.add(t);
            processed.add(process(t));
        }
        for (;;) {
            const maybeType = queue.pop();
            if (maybeType === undefined) {
                break;
            }
            visit(maybeType);
        }
        return processed;
    }
}

/* eslint-disable */
// https://github.com/epoberezkin/ajv/blob/4d76c6fb813b136b6ec4fe74990bc97233d75dea/lib/compile/formats.js
/*
The MIT License (MIT)

Copyright (c) 2015 Evgeny Poberezkin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const DAYS = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
const DATE_TIME_SEPARATOR = /t|\s/i;
class DefaultDateTimeRecognizer {
    isDate(str) {
        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
        const matches = DATE.exec(str);
        if (matches === null)
            return false;
        const month = +matches[2];
        const day = +matches[3];
        return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
    }
    isTime(str) {
        const matches = TIME.exec(str);
        if (matches === null)
            return false;
        const hour = +matches[1];
        const minute = +matches[2];
        const second = +matches[3];
        return hour <= 23 && minute <= 59 && second <= 59;
    }
    isDateTime(str) {
        // http://tools.ietf.org/html/rfc3339#section-5.6
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && this.isDate(dateTime[0]) && this.isTime(dateTime[1]);
    }
}

class TargetLanguage {
    constructor(displayName, names, extension) {
        this.displayName = displayName;
        this.names = names;
        this.extension = extension;
    }
    get optionDefinitions() {
        return this.getOptions().map(o => o.definition);
    }
    get cliOptionDefinitions() {
        let actual = [];
        let display = [];
        for (const { cliDefinitions } of this.getOptions()) {
            actual = actual.concat(cliDefinitions.actual);
            display = display.concat(cliDefinitions.display);
        }
        return { actual, display };
    }
    get name() {
        return defined(this.names[0]);
    }
    renderGraphAndSerialize(typeGraph, givenOutputFilename, alphabetizeProperties, leadingComments, rendererOptions, indentation) {
        if (indentation === undefined) {
            indentation = this.defaultIndentation;
        }
        const renderContext = { typeGraph, leadingComments };
        const renderer = this.makeRenderer(renderContext, rendererOptions);
        if (renderer instanceof ConvenienceRenderer) {
            renderer.setAlphabetizeProperties(alphabetizeProperties);
        }
        const renderResult = renderer.render(givenOutputFilename);
        return collectionUtils.mapMap(renderResult.sources, s => serializeRenderResult(s, renderResult.names, defined(indentation)));
    }
    get defaultIndentation() {
        return "    ";
    }
    get stringTypeMapping() {
        return new Map();
    }
    get supportsOptionalClassProperties() {
        return false;
    }
    get supportsUnionsWithBothNumberTypes() {
        return false;
    }
    get supportsFullObjectType() {
        return false;
    }
    needsTransformerForType(_t) {
        return false;
    }
    get dateTimeRecognizer() {
        return new DefaultDateTimeRecognizer();
    }
}

// FIXME: NEEDS REFACTOR
/* eslint-disable @typescript-eslint/no-shadow */
/* eslint-disable @typescript-eslint/naming-convention */
/**
 * CJSON.ts
 * This file is used to generate cJSON code with quicktype
 * The generated code depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable
 *
 * Similarly to C++ generator, it is possible to generate a single header file or multiple header files.
 * To generate multiple header files, use the following option: --source-style multi-source
 *
 * JSON data are represented using structures, and functions in the cJSON style are created to use them.
 * To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);
 * To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);
 * To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);
 * To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);
 * To delete json data use the following: cJSON_Delete<type>(<data>);
 *
 * TODO list for future enhancements:
 * - Management of Class, Union and TopLevel should be mutualized to reduce code size and to permit Union and TopLevel having recursive Array/Map
 * - Types check should be added to verify unwanted inputs (for example a Number passed while a String is expected, etc)
 * - Constraints should be implemented (verification of Enum values, min/max values for Numbers and min/max length for Strings, regex)
 * - Support of pure Any type for example providing a callback from the application to handle these cases dynamically
 * See test/languages.ts for the test cases which are not implmented/checked.
 */
/* Imports */
/* Naming styles */
const pascalValue$1 = ["pascal-case", "pascal"];
const underscoreValue$1 = ["underscore-case", "underscore"];
const camelValue$1 = ["camel-case", "camel"];
const upperUnderscoreValue$1 = ["upper-underscore-case", "upper-underscore"];
const pascalUpperAcronymsValue$1 = ["pascal-case-upper-acronyms", "pascal-upper-acronyms"];
const camelUpperAcronymsValue$1 = ["camel-case-upper-acronyms", "camel-upper-acronyms"];
/* cJSON generator options */
const cJSONOptions = {
    typeSourceStyle: new EnumOption("source-style", "Source code generation type, whether to generate single or multiple source files", [
        ["single-source", true],
        ["multi-source", false]
    ], "single-source", "secondary"),
    typeIntegerSize: new EnumOption("integer-size", "Integer code generation type (int64_t by default)", [
        ["int8_t", "int8_t"],
        ["int16_t", "int16_t"],
        ["int32_t", "int32_t"],
        ["int64_t", "int64_t"]
    ], "int64_t", "secondary"),
    hashtableSize: new StringOption("hashtable-size", "Hashtable size, used when maps are created (64 by default)", "SIZE", "64"),
    addTypedefAlias: new EnumOption("typedef-alias", "Add typedef alias to unions, structs, and enums (no typedef by default)", [
        ["no-typedef", false],
        ["add-typedef", true]
    ], "no-typedef", "secondary"),
    printStyle: new EnumOption("print-style", "Which cJSON print should be used (formatted by default)", [
        ["print-formatted", false],
        ["print-unformatted", true]
    ], "print-formatted", "secondary"),
    typeNamingStyle: new EnumOption("type-style", "Naming style for types", [
        pascalValue$1,
        underscoreValue$1,
        camelValue$1,
        upperUnderscoreValue$1,
        pascalUpperAcronymsValue$1,
        camelUpperAcronymsValue$1
    ]),
    memberNamingStyle: new EnumOption("member-style", "Naming style for members", [
        underscoreValue$1,
        pascalValue$1,
        camelValue$1,
        upperUnderscoreValue$1,
        pascalUpperAcronymsValue$1,
        camelUpperAcronymsValue$1
    ]),
    enumeratorNamingStyle: new EnumOption("enumerator-style", "Naming style for enumerators", [
        upperUnderscoreValue$1,
        underscoreValue$1,
        pascalValue$1,
        camelValue$1,
        pascalUpperAcronymsValue$1,
        camelUpperAcronymsValue$1
    ])
};
/* cJSON generator target language */
class CJSONTargetLanguage extends TargetLanguage {
    /**
     * Constructor
     * @param displayName: display name
     * @params names: names
     * @param extension: extension of files
     */
    constructor(displayName = "C (cJSON)", names = ["cjson", "cJSON"], extension = "h") {
        super(displayName, names, extension);
    }
    /**
     * Return cJSON generator options
     * @return cJSON generator options array
     */
    getOptions() {
        return [
            cJSONOptions.typeSourceStyle,
            cJSONOptions.typeIntegerSize,
            cJSONOptions.addTypedefAlias,
            cJSONOptions.printStyle,
            cJSONOptions.hashtableSize,
            cJSONOptions.typeNamingStyle,
            cJSONOptions.memberNamingStyle,
            cJSONOptions.enumeratorNamingStyle
        ];
    }
    /**
     * Indicate if language support union with both number types
     * @return true
     */
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    /**
     * Indicate if language support optional class properties
     * @return true
     */
    get supportsOptionalClassProperties() {
        return true;
    }
    /**
     * Create renderer
     * @param renderContext: render context
     * @param untypedOptionValues
     * @return cJSON renderer
     */
    makeRenderer(renderContext, untypedOptionValues) {
        return new CJSONRenderer(this, renderContext, getOptionValues(cJSONOptions, untypedOptionValues));
    }
}
/* Function used to format names */
const legalizeName$k = legalizeCharacters(cp => isAscii(cp) && isLetterOrUnderscoreOrDigit(cp));
/* Forbidden names for namespace */
const keywords$b = [
    /* C and C++ keywords */
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "char16_t",
    "char32_t",
    "class",
    "compl",
    "concept",
    "const",
    "constexpr",
    "const_cast",
    "continue",
    "co_await",
    "co_return",
    "co_yield",
    "decltype",
    "default",
    "delete",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "int",
    "long",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "requires",
    "restrict",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_assert",
    "static_cast",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "typeof",
    "union",
    "unsigned",
    "using",
    "virtual",
    "void",
    "volatile",
    "wchar_t",
    "while",
    "xor",
    "xor_eq",
    "override",
    "final",
    "transaction_safe",
    "transaction_safe_dynamic",
    "NULL",
    /* cJSON keywords */
    "Array",
    "ArrayReference",
    "Bool",
    "DoubleArray",
    "False",
    "FloatArray",
    "IntArray",
    "Object",
    "Null",
    "Number",
    "Raw",
    "String",
    "StringArray",
    "StringReference",
    "True"
];
/* Used to build forbidden global names */
var GlobalNames$1;
(function (GlobalNames) {
    GlobalNames[GlobalNames["ClassMemberConstraints"] = 1] = "ClassMemberConstraints";
    GlobalNames[GlobalNames["ClassMemberConstraintException"] = 2] = "ClassMemberConstraintException";
    GlobalNames[GlobalNames["ValueTooLowException"] = 3] = "ValueTooLowException";
    GlobalNames[GlobalNames["ValueTooHighException"] = 4] = "ValueTooHighException";
    GlobalNames[GlobalNames["ValueTooShortException"] = 5] = "ValueTooShortException";
    GlobalNames[GlobalNames["ValueTooLongException"] = 6] = "ValueTooLongException";
    GlobalNames[GlobalNames["InvalidPatternException"] = 7] = "InvalidPatternException";
    GlobalNames[GlobalNames["CheckConstraint"] = 8] = "CheckConstraint";
})(GlobalNames$1 || (GlobalNames$1 = {}));
/* To be able to support circles in multiple files - e.g. class#A using class#B using class#A (obviously not directly) we can forward declare them */
var IncludeKind$1;
(function (IncludeKind) {
    IncludeKind["ForwardDeclare"] = "ForwardDeclare";
    IncludeKind["Include"] = "Include";
})(IncludeKind$1 || (IncludeKind$1 = {}));
/* cJSON renderer */
class CJSONRenderer extends ConvenienceRenderer {
    /**
     * Constructor
     * @param targetLanguage: target language
     * @param renderContext: render context
     * @param _options: renderer options
     */
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this.typeIntegerSize = _options.typeIntegerSize;
        this.hashtableSize = _options.hashtableSize;
        this.typeNamingStyle = _options.typeNamingStyle;
        this.namedTypeNameStyle = makeNameStyle(this.typeNamingStyle, legalizeName$k);
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this.memberNameStyle = makeNameStyle(_options.memberNamingStyle, legalizeName$k);
        this.forbiddenGlobalNames = [];
        for (const type of numberEnumValues(GlobalNames$1)) {
            const genName = this.namedTypeNameStyle(GlobalNames$1[type]);
            this.forbiddenGlobalNames.push(genName);
        }
    }
    /**
     * Build forbidden names for namespace
     * @return Forbidden names for namespace
     */
    forbiddenNamesForGlobalNamespace() {
        return [...keywords$b, ...this.forbiddenGlobalNames];
    }
    /**
     * Build forbidden names for enums
     * @return Forbidden names for enums
     */
    forbiddenForEnumCases(_enumType, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    /**
     * Build forbidden names for unions members
     * @return Forbidden names for unions members
     */
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
    }
    /**
     * Build forbidden names for objects
     * @return Forbidden names for objects
     */
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    /**
     * Build types member names
     * @return types member namer
     */
    makeNamedTypeNamer() {
        return funPrefixNamer("types", this.namedTypeNameStyle);
    }
    /**
     * Build object properties member names
     * @return object properties member namer
     */
    namerForObjectProperty() {
        return funPrefixNamer("members", this.memberNameStyle);
    }
    /**
     * Build union member names
     * @return union member namer
     */
    makeUnionMemberNamer() {
        return funPrefixNamer("members", this.memberNameStyle);
    }
    /**
     * Build enum member names
     * @return enum member namer
     */
    makeEnumCaseNamer() {
        return funPrefixNamer("enumerators", makeNameStyle(this.enumeratorNamingStyle, legalizeName$k));
    }
    /**
     * Override of super proposeUnionMemberName function
     * @param unionType: union type
     * @param unionName: union name
     * @param fieldType: field type
     * @param lookup: Lookup function
     * @return Proposed union member name
     */
    proposeUnionMemberName(unionType, unionName, fieldType, lookup) {
        let fieldName = super.proposeUnionMemberName(unionType, unionName, fieldType, lookup);
        if ("bool" === fieldName) {
            fieldName = "boolean";
        }
        else if ("double" === fieldName) {
            fieldName = "number";
        }
        return fieldName;
    }
    /**
     * Function called to emit typedef alias for a a given type
     * @param fieldType: the variable type
     * @param fieldName: name of the variable
     */
    emitTypedefAlias(fieldType, fieldName) {
        if (this._options.addTypedefAlias) {
            this.emitLine("typedef ", this.quicktypeTypeToCJSON(fieldType, false).cType, " ", fieldName, ";");
            this.ensureBlankLine();
        }
    }
    /**
     * Function called to create header file(s)
     * @param proposedFilename: source filename provided from stdin
     */
    emitSourceStructure(proposedFilename) {
        /* Depending of source style option, generate a unique header or multiple header files */
        if (this._options.typeSourceStyle) {
            this.emitSingleSourceStructure(proposedFilename);
        }
        else {
            this.emitMultiSourceStructure();
        }
    }
    /**
     * Function called to create a single header file with types and generators
     * @param proposedFilename: source filename provided from stdin
     */
    emitSingleSourceStructure(proposedFilename) {
        /* Create file */
        this.startFile(proposedFilename);
        /* Create types */
        this.forEachDeclaration("leading-and-interposing", decl => {
            if (decl.kind === "forward") {
                this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
            }
            else if (decl.kind === "define") {
                const type = decl.type;
                if (type instanceof ClassType) {
                    this.emitClassTypedef(type);
                }
                else if (type instanceof EnumType) {
                    this.emitEnumTypedef(type);
                }
                else if (type instanceof UnionType) {
                    this.emitUnionTypedef(type);
                }
                else {
                    panic("Cannot declare type");
                }
            }
            else {
                assertNever(decl.kind);
            }
        });
        /* Create top level type */
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelTypedef(type, className), type => this.namedTypeToNameForTopLevel(type) === undefined);
        /* Create enum prototypes */
        this.forEachEnum("leading-and-interposing", (enumType, _enumName) => this.emitEnumPrototypes(enumType));
        /* Create union prototypes */
        this.forEachUnion("leading-and-interposing", (unionType) => this.emitUnionPrototypes(unionType));
        /* Create class prototypes */
        this.forEachObject("leading-and-interposing", (classType, _className) => this.emitClassPrototypes(classType));
        /* Create top level prototypes */
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelPrototypes(type, className), type => this.namedTypeToNameForTopLevel(type) === undefined);
        /* Create enum functions */
        this.forEachEnum("leading-and-interposing", (enumType, _enumName) => this.emitEnumFunctions(enumType));
        /* Create union functions */
        this.forEachUnion("leading-and-interposing", (unionType) => this.emitUnionFunctions(unionType));
        /* Create class functions */
        this.forEachObject("leading-and-interposing", (classType, _className) => this.emitClassFunctions(classType));
        /* Create top level functions */
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevelFunctions(type, className), type => this.namedTypeToNameForTopLevel(type) === undefined);
        /* Close file */
        this.finishFile();
    }
    /**
     * Function called to create a multiple header files with types and generators
     */
    emitMultiSourceStructure() {
        /* Array of includes */
        let includes;
        /* Create each file */
        this.forEachNamedType("leading-and-interposing", (classType, _name) => {
            this.emitClass(classType, includes);
        }, (enumType, _name) => {
            this.emitEnum(enumType, includes);
        }, (unionType, _name) => {
            this.emitUnion(unionType, includes);
        });
        /* Create top level file */
        this.forEachTopLevel("leading", (type, className) => this.emitTopLevel(type, className, includes), type => this.namedTypeToNameForTopLevel(type) === undefined);
    }
    /**
     * Function called to create an enum header files with types and generators
     * @param enumType: enum type
     * @param includes: Array of includes
     */
    emitEnum(enumType, includes) {
        /* Create file */
        const enumName = this.nameForNamedType(enumType);
        const filename = this.sourcelikeToString(enumName).concat(".h");
        includes.push(filename);
        this.startFile(filename);
        /* Create includes */
        this.emitIncludes(enumType, this.sourcelikeToString(filename));
        /* Create types */
        this.emitEnumTypedef(enumType);
        /* Create prototypes */
        this.emitEnumPrototypes(enumType);
        /* Create functions */
        this.emitEnumFunctions(enumType);
        /* Close file */
        this.finishFile();
    }
    /**
     * Function called to create enum typedef
     * @param enumType: enum type
     */
    emitEnumTypedef(enumType) {
        /* FIXME: Now there is a language with need of global enum name, see FIXME in makeNameForEnumCase of ConvenienceRenderer.ts, should simplify here when fixed */
        const enumName = this.nameForNamedType(enumType);
        const enumValues = enumCaseValues(enumType, this.targetLanguage.name);
        this.emitDescription(this.descriptionForType(enumType));
        this.emitBlock(["enum ", enumName], () => {
            const combinedName = allUpperWordStyle(this.sourcelikeToString(enumName));
            this.forEachEnumCase(enumType, "none", (name, jsonName) => {
                if (enumValues !== undefined) {
                    const [enumValue] = getAccessorName(enumValues, jsonName);
                    if (enumValue !== undefined) {
                        this.emitLine(combinedName, "_", name, " = ", enumValue.toString(), ",");
                    }
                    else {
                        this.emitLine(combinedName, "_", name, ",");
                    }
                }
                else {
                    this.emitLine(combinedName, "_", name, ",");
                }
            });
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(enumType, enumName);
    }
    /**
     * Function called to create enum prototypes
     * @param enumType: enum type
     */
    emitEnumPrototypes(enumType) {
        const enumName = this.nameForNamedType(enumType);
        this.emitLine("enum ", enumName, " cJSON_Get", enumName, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", enumName, "(", this.withConst(["enum ", enumName]), " x);");
        this.ensureBlankLine();
    }
    /**
     * Function called to create enum functions
     * @param enumType: enum type
     */
    emitEnumFunctions(enumType) {
        const enumName = this.nameForNamedType(enumType);
        /* Create cJSON to enumName generator function */
        this.emitBlock(["enum ", enumName, " cJSON_Get", enumName, "Value(", this.withConst("cJSON"), " * j)"], () => {
            this.emitLine("enum ", enumName, " x = 0;");
            this.emitBlock(["if (NULL != j)"], () => {
                let onFirst = true;
                const combinedName = allUpperWordStyle(this.sourcelikeToString(enumName));
                this.forEachEnumCase(enumType, "none", (name, jsonName) => {
                    this.emitLine(onFirst ? "" : "else ", 'if (!strcmp(cJSON_GetStringValue(j), "', jsonName, '")) x = ', combinedName, "_", name, ";");
                    onFirst = false;
                });
            });
            this.emitLine("return x;");
        });
        this.ensureBlankLine();
        /* Create enumName to cJSON generator function */
        this.emitBlock(["cJSON * cJSON_Create", enumName, "(", this.withConst(["enum ", enumName]), " x)"], () => {
            this.emitLine("cJSON * j = NULL;");
            this.emitBlock(["switch (x)"], () => {
                const combinedName = allUpperWordStyle(this.sourcelikeToString(enumName));
                this.forEachEnumCase(enumType, "none", (name, jsonName) => {
                    this.emitLine("case ", combinedName, "_", name, ': j = cJSON_CreateString("', jsonName, '"); break;');
                });
            });
            this.emitLine("return j;");
        });
        this.ensureBlankLine();
    }
    /**
     * Function called to create a union header files with types and generators
     * @param unionType: union type
     * @param includes: Array of includes
     */
    emitUnion(unionType, includes) {
        /* Create file */
        const unionName = this.nameForNamedType(unionType);
        const filename = this.sourcelikeToString(unionName).concat(".h");
        includes.push(filename);
        this.startFile(filename);
        /* Create includes */
        this.emitIncludes(unionType, this.sourcelikeToString(filename));
        /* Create types */
        this.emitUnionTypedef(unionType);
        /* Create prototypes */
        this.emitUnionPrototypes(unionType);
        /* Create functions */
        this.emitUnionFunctions(unionType);
        /* Close file */
        this.finishFile();
    }
    /**
     * Function called to create union typedef
     * @param unionType: union type
     */
    emitUnionTypedef(unionType) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [_hasNull, nonNulls] = removeNullFromUnion(unionType);
        const unionName = this.nameForNamedType(unionType);
        this.emitDescription(this.descriptionForType(unionType));
        this.emitBlock(["struct ", unionName], () => {
            this.emitLine("int type;");
            this.emitBlock(["union"], () => {
                for (const type of nonNulls) {
                    const cJSON = this.quicktypeTypeToCJSON(type, false);
                    this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " ", this.nameForUnionMember(unionType, type), ";");
                }
            }, "value", true);
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(unionType, unionName);
    }
    /**
     * Function called to create union prototypes
     * @param unionType: union type
     */
    emitUnionPrototypes(unionType) {
        const unionName = this.nameForNamedType(unionType);
        this.emitLine("struct ", unionName, " * cJSON_Get", unionName, "Value(const cJSON * j);");
        this.emitLine("cJSON * cJSON_Create", unionName, "(", this.withConst(["struct ", unionName]), " * x);");
        this.emitLine("void cJSON_Delete", unionName, "(struct ", unionName, " * x);");
        this.ensureBlankLine();
    }
    /**
     * Function called to create union functions
     * @param unionType: union type
     */
    emitUnionFunctions(unionType) {
        const [hasNull, nonNulls] = removeNullFromUnion(unionType);
        const unionName = this.nameForNamedType(unionType);
        /* Create cJSON to unionType generator function */
        this.emitBlock(["struct ", unionName, " * cJSON_Get", unionName, "Value(const cJSON * j)"], () => {
            let onFirst = true;
            this.emitLine("struct ", unionName, " * x = cJSON_malloc(sizeof(struct ", unionName, "));");
            this.emitBlock(["if (NULL != x)"], () => {
                this.emitLine("memset(x, 0, sizeof(struct ", unionName, "));");
                if (hasNull !== null) {
                    this.emitBlock(["if (cJSON_IsNull(j))"], () => {
                        this.emitLine("x->type = cJSON_NULL;");
                    });
                    onFirst = false;
                }
                for (const type of nonNulls) {
                    const cJSON = this.quicktypeTypeToCJSON(type, false);
                    this.emitBlock([onFirst === true ? "if (" : "else if (", cJSON.isType, "(j))"], () => {
                        this.emitLine("x->type = ", cJSON.cjsonType, ";");
                        if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                            const level = 0;
                            const child_level = 1;
                            this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_create(false, NULL);");
                            this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                                this.emitBlock([
                                    "cJSON_ArrayForEach(e",
                                    child_level.toString(),
                                    ", j",
                                    "",
                                    ")"
                                ], () => {
                                    var _a;
                                    const add = (cJSON, level, child_level) => {
                                        var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                                        if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                        else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                        else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" ||
                                            ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                            this.emitLine("list_add_tail(x", child_level.toString(), ", (", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                                        }
                                        else if (((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                                            this.emitLine("list_add_tail(x", child_level.toString(), ", strdup(", (_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e", child_level.toString(), ")), sizeof(", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                                        }
                                        else if (((_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.cjsonType) === "cJSON_Object" ||
                                            ((_m = cJSON.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Union") {
                                            this.emitLine("list_add_tail(x", child_level.toString(), ", ", (_o = cJSON.items) === null || _o === void 0 ? void 0 : _o.getValue, "(e", child_level.toString(), "), sizeof(", (_p = cJSON.items) === null || _p === void 0 ? void 0 : _p.cType, " *));");
                                        }
                                        else {
                                            this.emitLine(
                                            // @ts-expect-error awaiting refactor
                                            (_q = cJSON.items) === null || _q === void 0 ? void 0 : _q.cType, " * tmp", "", " = cJSON_malloc(sizeof(", (_r = cJSON.items) === null || _r === void 0 ? void 0 : _r.cType, "));");
                                            this.emitBlock(["if (NULL != tmp", "", ")"], () => {
                                                var _a, _b;
                                                this.emitLine("* tmp", "", " = ", 
                                                // @ts-expect-error awaiting refactor
                                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.getValue, "(e", child_level.toString(), ");");
                                                this.emitLine("list_add_tail(x", child_level.toString(), ", tmp", "", ", sizeof(", 
                                                // @ts-expect-error awaiting refactor
                                                (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                            });
                                        }
                                    };
                                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                        this.emitBlock(["if (!cJSON_IsNull(e", child_level.toString(), "))"], () => {
                                            add(cJSON, level, child_level);
                                        });
                                        this.emitBlock(["else"], () => {
                                            this.emitLine("list_add_tail(x", child_level.toString(), ", (void *)0xDEADBEEF, sizeof(void *));");
                                        });
                                    }
                                    else {
                                        add(cJSON, level, child_level);
                                    }
                                });
                                this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = x", child_level.toString(), ";");
                            });
                        }
                        else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                            const level = 0;
                            const child_level = 1;
                            this.emitLine(cJSON.cType, " * x", child_level.toString(), " = hashtable_create(", this.hashtableSize, ", false);");
                            this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                                this.emitBlock([
                                    "cJSON_ArrayForEach(e",
                                    child_level.toString(),
                                    ", j",
                                    "",
                                    ")"
                                ], () => {
                                    var _a;
                                    const add = (cJSON, level, child_level) => {
                                        var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
                                        if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                        else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                        else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" ||
                                            ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                            this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                                        }
                                        else if (((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                                            this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, strdup(", (_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e", child_level.toString(), ")), sizeof(", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                                        }
                                        else if (((_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.cjsonType) === "cJSON_Object" ||
                                            ((_m = cJSON.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Union") {
                                            this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, ", (_o = cJSON.items) === null || _o === void 0 ? void 0 : _o.getValue, "(e", child_level.toString(), "), sizeof(", (_p = cJSON.items) === null || _p === void 0 ? void 0 : _p.cType, " *));");
                                        }
                                        else {
                                            this.emitLine(
                                            // @ts-expect-error awaiting refactor
                                            (_q = cJSON.items) === null || _q === void 0 ? void 0 : _q.cType, " * tmp", "", " = cJSON_malloc(sizeof(", (_r = cJSON.items) === null || _r === void 0 ? void 0 : _r.cType, "));");
                                            this.emitBlock(["if (NULL != tmp", "", ")"], () => {
                                                var _a, _b;
                                                this.emitLine("* tmp", "", " = ", 
                                                // @ts-expect-error awaiting refactor
                                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.getValue, "(e", child_level.toString(), ");");
                                                this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, tmp", "", ", sizeof(", 
                                                // @ts-expect-error awaiting refactor
                                                (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                            });
                                        }
                                    };
                                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                        this.emitBlock(["if (!cJSON_IsNull(e", child_level.toString(), "))"], () => {
                                            add(cJSON, level, child_level);
                                        });
                                        this.emitBlock(["else"], () => {
                                            this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (void *)0xDEADBEEF, sizeof(void *));");
                                        });
                                    }
                                    else {
                                        add(cJSON, level, child_level);
                                    }
                                });
                                this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = x", child_level.toString(), ";");
                            });
                        }
                        else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") {
                            this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = (", cJSON.cType, " *)0xDEADBEEF;");
                        }
                        else if (cJSON.cjsonType === "cJSON_String") {
                            this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = strdup(", cJSON.getValue, "(j));");
                        }
                        else {
                            this.emitLine("x->value.", this.nameForUnionMember(unionType, type), " = ", cJSON.getValue, "(j);");
                        }
                    });
                    onFirst = false;
                }
            });
            this.emitLine("return x;");
        });
        this.ensureBlankLine();
        /* Create unionName to cJSON generator function */
        this.emitBlock(["cJSON * cJSON_Create", unionName, "(", this.withConst(["struct ", unionName]), " * x)"], () => {
            this.emitLine("cJSON * j = NULL;");
            this.emitBlock(["if (NULL != x)"], () => {
                let onFirst = true;
                if (hasNull !== null) {
                    this.emitBlock(["if (cJSON_NULL == x->type)"], () => {
                        this.emitLine("j = cJSON_CreateNull();");
                    });
                    onFirst = false;
                }
                for (const type of nonNulls) {
                    const cJSON = this.quicktypeTypeToCJSON(type, false);
                    this.emitBlock([onFirst === true ? "if (" : "else if (", cJSON.cjsonType, " == x->type)"], () => {
                        if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                            const child_level = 1;
                            this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                            this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                                var _a;
                                this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x", child_level.toString(), " = list_get_head(x", "", "->value.", this.nameForUnionMember(unionType, type), ");");
                                this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                                    var _a;
                                    const add = (cJSON, child_level) => {
                                        var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                                        if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                        else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                        else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") ;
                                        else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                            this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                        }
                                        else if (((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" ||
                                            ((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" ||
                                            ((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                            this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level.toString(), "));");
                                        }
                                        else {
                                            this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", 
                                            // @ts-expect-error awaiting refactor
                                            (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.createObject, "(*x", child_level.toString(), "));");
                                        }
                                    };
                                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                        this.emitBlock(["if ((void *)0xDEADBEEF != x", child_level.toString(), ")"], () => {
                                            add(cJSON, child_level);
                                        });
                                        this.emitBlock(["else"], () => {
                                            this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", cJSON_CreateNull());");
                                        });
                                    }
                                    else {
                                        add(cJSON, child_level);
                                    }
                                    this.emitLine("x", child_level.toString(), " = list_get_next(x", "", "->value.", this.nameForUnionMember(unionType, type), ");");
                                });
                                this.emitLine("j = j", child_level.toString(), ";");
                            });
                        }
                        else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                            const child_level = 1;
                            this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                            this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                                this.emitLine("char **keys", child_level.toString(), " = NULL;");
                                this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", "", "->value.", this.nameForUnionMember(unionType, type), ", &keys", child_level.toString(), ");");
                                this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                                    this.emitBlock([
                                        "for (size_t index",
                                        child_level.toString(),
                                        " = 0; index",
                                        child_level.toString(),
                                        " < count",
                                        child_level.toString(),
                                        "; index",
                                        child_level.toString(),
                                        "++)"
                                    ], () => {
                                        var _a, _b;
                                        this.emitLine(
                                        // @ts-expect-error awaiting refactor
                                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x", child_level.toString(), " = hashtable_lookup(x", "", "->value.", this.nameForUnionMember(unionType, type), ", keys", child_level.toString(), "[index", child_level.toString(), "]);");
                                        const add = (cJSON, child_level) => {
                                            var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                                            if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                            else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                            else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") ;
                                            else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                                this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], ", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                            }
                                            else if (((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" ||
                                                ((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" ||
                                                ((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                                this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], ", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level.toString(), "));");
                                            }
                                            else {
                                                this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], ", 
                                                // @ts-expect-error awaiting refactor
                                                (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.createObject, "(*x", child_level.toString(), "));");
                                            }
                                        };
                                        if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                                            this.emitBlock([
                                                "if ((void *)0xDEADBEEF != x",
                                                child_level.toString(),
                                                ")"
                                            ], () => {
                                                add(cJSON, child_level);
                                            });
                                            this.emitBlock(["else"], () => {
                                                this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], cJSON_CreateNull());");
                                            });
                                        }
                                        else {
                                            add(cJSON, child_level);
                                        }
                                    });
                                    this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                                });
                                this.emitLine("j = j", child_level.toString(), ";");
                            });
                        }
                        else if (cJSON.cjsonType === "cJSON_Invalid") ;
                        else if (cJSON.cjsonType === "cJSON_NULL") {
                            this.emitLine("j = ", cJSON.createObject, "();");
                        }
                        else {
                            this.emitLine("j = ", cJSON.createObject, "(x->value.", this.nameForUnionMember(unionType, type), ");");
                        }
                    });
                    onFirst = false;
                }
            });
            this.emitLine("return j;");
        });
        this.ensureBlankLine();
        /* Create unionName delete function */
        this.emitBlock(["void cJSON_Delete", unionName, "(struct ", unionName, " * x)"], () => {
            this.emitBlock(["if (NULL != x)"], () => {
                let onFirst = true;
                for (const type of nonNulls) {
                    const cJSON = this.quicktypeTypeToCJSON(type, false);
                    this.emitBlock([onFirst === true ? "if (" : "else if (", cJSON.cjsonType, " == x->type)"], () => {
                        if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                            const child_level = 1;
                            this.emitBlock([
                                "if (NULL != x",
                                "",
                                "->value.",
                                this.nameForUnionMember(unionType, type),
                                ")"
                            ], () => {
                                var _a;
                                this.emitLine(
                                // @ts-expect-error awaiting refactor
                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x", child_level.toString(), " = list_get_head(x", "", "->value.", this.nameForUnionMember(unionType, type), ");");
                                this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                                    var _a, _b, _d, _e, _f, _g;
                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                    else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" ||
                                        ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") ;
                                    else {
                                        if ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.isNullable) {
                                            this.emitBlock(["if ((void *)0xDEADBEEF != x", child_level.toString(), ")"], () => {
                                                var _a;
                                                this.emitLine(
                                                // @ts-expect-error awaiting refactor
                                                (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.deleteType, "(x", child_level.toString(), ");");
                                            });
                                        }
                                        else {
                                            this.emitLine(
                                            // @ts-expect-error awaiting refactor
                                            (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.deleteType, "(x", child_level.toString(), ");");
                                        }
                                    }
                                    this.emitLine("x", child_level.toString(), " = list_get_next(x", "", "->value.", this.nameForUnionMember(unionType, type), ");");
                                });
                                this.emitLine(cJSON.deleteType, "(x", "", "->value.", this.nameForUnionMember(unionType, type), ");");
                            });
                        }
                        else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                            const child_level = 1;
                            this.emitBlock([
                                "if (NULL != x",
                                "",
                                "->value.",
                                this.nameForUnionMember(unionType, type),
                                ")"
                            ], () => {
                                this.emitLine("char **keys", child_level.toString(), " = NULL;");
                                this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", "", "->value.", this.nameForUnionMember(unionType, type), ", &keys", child_level.toString(), ");");
                                this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                                    this.emitBlock([
                                        "for (size_t index",
                                        child_level.toString(),
                                        " = 0; index",
                                        child_level.toString(),
                                        " < count",
                                        child_level.toString(),
                                        "; index",
                                        child_level.toString(),
                                        "++)"
                                    ], () => {
                                        var _a;
                                        this.emitLine(
                                        // @ts-expect-error awaiting refactor
                                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x", child_level.toString(), " = hashtable_lookup(x", "", "->value.", this.nameForUnionMember(unionType, type), ", keys", child_level.toString(), "[index", child_level.toString(), "]);");
                                        this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                            var _a, _b, _d, _e, _f, _g;
                                            if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                            else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                            else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" ||
                                                ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") ;
                                            else {
                                                if ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.isNullable) {
                                                    this.emitBlock([
                                                        "if ((void *)0xDEADBEEF != x",
                                                        child_level.toString(),
                                                        ")"
                                                    ], () => {
                                                        var _a;
                                                        this.emitLine(
                                                        // @ts-expect-error awaiting refactor
                                                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.deleteType, "(x", child_level.toString(), ");");
                                                    });
                                                }
                                                else {
                                                    this.emitLine(
                                                    // @ts-expect-error awaiting refactor
                                                    (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.deleteType, "(x", child_level.toString(), ");");
                                                }
                                            }
                                        });
                                    });
                                    this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                                });
                                this.emitLine(cJSON.deleteType, "(x", "", "->value.", this.nameForUnionMember(unionType, type), ");");
                            });
                        }
                        else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") ;
                        else if (cJSON.cjsonType === "cJSON_String" ||
                            cJSON.cjsonType === "cJSON_Object" ||
                            cJSON.cjsonType === "cJSON_Union") {
                            this.emitLine(cJSON.deleteType, "(x->value.", this.nameForUnionMember(unionType, type), ");");
                        }
                        else ;
                    });
                    onFirst = false;
                }
                this.emitLine("cJSON_free(x);");
            });
        });
        this.ensureBlankLine();
    }
    /**
     * Function called to create a class header files with types and generators
     * @param classType: class type
     * @param includes: Array of includes
     */
    emitClass(classType, includes) {
        /* Create file */
        const className = this.nameForNamedType(classType);
        const filename = this.sourcelikeToString(className).concat(".h");
        includes.push(filename);
        this.startFile(filename);
        /* Create includes */
        this.emitIncludes(classType, this.sourcelikeToString(filename));
        /* Create types */
        this.emitClassTypedef(classType);
        /* Create prototypes */
        this.emitClassPrototypes(classType);
        /* Create functions */
        this.emitClassFunctions(classType);
        /* Close file */
        this.finishFile();
    }
    /**
     * Function called to create class typedef
     * @param classType: class type
     */
    emitClassTypedef(classType) {
        const className = this.nameForNamedType(classType);
        this.emitDescription(this.descriptionForType(classType));
        this.emitBlock(["struct ", className], () => {
            this.forEachClassProperty(classType, "none", (name, jsonName, property) => {
                this.emitDescription(this.descriptionForClassProperty(classType, jsonName));
                const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " ", name, ";");
            });
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(classType, className);
    }
    /**
     * Function called to create class prototypes
     * @param classType: class type
     */
    emitClassPrototypes(classType) {
        const className = this.nameForNamedType(classType);
        this.emitLine("struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s);");
        this.emitLine("struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("void cJSON_Delete", className, "(struct ", className, " * x);");
        this.ensureBlankLine();
    }
    /**
     * Function called to create class functions
     * @param classType: class type
     */
    emitClassFunctions(classType) {
        const className = this.nameForNamedType(classType);
        /* Create string to className generator function */
        this.emitBlock(["struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s)"], () => {
            this.emitLine("struct ", className, " * x = NULL;");
            this.emitBlock(["if (NULL != s)"], () => {
                this.emitLine("cJSON * j = cJSON_Parse(s);");
                this.emitBlock(["if (NULL != j)"], () => {
                    this.emitLine("x = cJSON_Get", className, "Value(j);");
                    this.emitLine("cJSON_Delete(j);");
                });
            });
            this.emitLine("return x;");
        });
        this.ensureBlankLine();
        /* Create cJSON to className generator function */
        this.emitBlock(["struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j)"], () => {
            this.emitLine("struct ", className, " * x = NULL;");
            this.emitBlock(["if (NULL != j)"], () => {
                this.emitBlock(["if (NULL != (x = cJSON_malloc(sizeof(struct ", className, "))))"], () => {
                    this.emitLine("memset(x, 0, sizeof(struct ", className, "));");
                    const recur = (type, level) => {
                        if (type instanceof ArrayType) {
                            const child_level = level + 1;
                            const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                            this.emitLine("list_t * x", child_level.toString(), " = list_create(false, NULL);");
                            this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                                this.emitBlock(["cJSON_ArrayForEach(e", child_level.toString(), ", e", level.toString(), ")"], () => {
                                    var _a;
                                    if (cJSON.cjsonType === "cJSON_Array") {
                                        const child_level2 = child_level + 1;
                                        recur(type.items, child_level);
                                        this.emitLine("list_add_tail(x", child_level.toString(), ", x", child_level2.toString(), ", sizeof(", 
                                        // @ts-expect-error awaiting refactor
                                        (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *));");
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Map") ;
                                    else if (cJSON.cjsonType === "cJSON_Invalid" ||
                                        cJSON.cjsonType === "cJSON_NULL") {
                                        this.emitLine("list_add_tail(x", child_level.toString(), ", (", cJSON.cType, " *)0xDEADBEEF, sizeof(", cJSON.cType, " *));");
                                    }
                                    else if (cJSON.cjsonType === "cJSON_String") {
                                        this.emitLine("list_add_tail(x", child_level.toString(), ", strdup(", cJSON.getValue, "(e", child_level.toString(), ")), sizeof(", cJSON.cType, " *));");
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Object" ||
                                        cJSON.cjsonType === "cJSON_Union") {
                                        this.emitLine("list_add_tail(x", child_level.toString(), ", ", cJSON.getValue, "(e", child_level.toString(), "), sizeof(", cJSON.cType, " *));");
                                    }
                                    else {
                                        this.emitLine(cJSON.cType, " * tmp", level > 0 ? level.toString() : "", " = cJSON_malloc(sizeof(", cJSON.cType, "));");
                                        this.emitBlock(["if (NULL != tmp", level > 0 ? level.toString() : "", ")"], () => {
                                            this.emitLine("* tmp", level > 0 ? level.toString() : "", " = ", cJSON.getValue, "(e", child_level.toString(), ");");
                                            this.emitLine("list_add_tail(x", child_level.toString(), ", tmp", level > 0 ? level.toString() : "", ", sizeof(", cJSON.cType, " *));");
                                        });
                                    }
                                });
                            });
                        }
                        else if (type instanceof ClassType) {
                            this.forEachClassProperty(type, "none", (name, jsonName, property) => {
                                const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                                this.emitBlock(!cJSON.isNullable
                                    ? [
                                        "if (cJSON_HasObjectItem(j",
                                        level > 0 ? level.toString() : "",
                                        ', "',
                                        jsonName,
                                        '"))'
                                    ]
                                    : [
                                        "if ((cJSON_HasObjectItem(j",
                                        level > 0 ? level.toString() : "",
                                        ', "',
                                        jsonName,
                                        '")) && (!cJSON_IsNull(cJSON_GetObjectItemCaseSensitive(j',
                                        level > 0 ? level.toString() : "",
                                        ', "',
                                        jsonName,
                                        '"))))'
                                    ], () => {
                                    if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                                        const child_level = level + 1;
                                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_create(false, NULL);");
                                        this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                            this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                                            this.emitLine("cJSON * j", child_level.toString(), " = cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                                            this.emitBlock([
                                                "cJSON_ArrayForEach(e",
                                                child_level.toString(),
                                                ", j",
                                                child_level.toString(),
                                                ")"
                                            ], () => {
                                                var _a;
                                                const add = (type, cJSON, level, child_level) => {
                                                    var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") {
                                                        if (type instanceof ArrayType) {
                                                            const child_level2 = child_level + 1;
                                                            recur(type.items, child_level);
                                                            this.emitLine("list_add_tail(x", child_level.toString(), ", x", child_level2.toString(), ", sizeof(", (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                                        }
                                                        else {
                                                            panic("Invalid type");
                                                        }
                                                    }
                                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") ;
                                                    else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" ||
                                                        ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                                                        this.emitLine("list_add_tail(x", child_level.toString(), ", (", (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cType, " *)0xDEADBEEF, sizeof(", (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cType, " *));");
                                                    }
                                                    else if (((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_String") {
                                                        this.emitLine("list_add_tail(x", child_level.toString(), ", strdup(", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.getValue, "(e", child_level.toString(), ")), sizeof(", (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.cType, " *));");
                                                    }
                                                    else if (((_m = cJSON.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Object" ||
                                                        ((_o = cJSON.items) === null || _o === void 0 ? void 0 : _o.cjsonType) === "cJSON_Union") {
                                                        this.emitLine("list_add_tail(x", child_level.toString(), ", ", (_p = cJSON.items) === null || _p === void 0 ? void 0 : _p.getValue, "(e", child_level.toString(), "), sizeof(", (_q = cJSON.items) === null || _q === void 0 ? void 0 : _q.cType, " *));");
                                                    }
                                                    else {
                                                        this.emitLine(
                                                        // @ts-expect-error awaiting refactor
                                                        (_r = cJSON.items) === null || _r === void 0 ? void 0 : _r.cType, " * tmp", level > 0 ? level.toString() : "", " = cJSON_malloc(sizeof(", (_s = cJSON.items) === null || _s === void 0 ? void 0 : _s.cType, "));");
                                                        this.emitBlock([
                                                            "if (NULL != tmp",
                                                            level > 0 ? level.toString() : "",
                                                            ")"
                                                        ], () => {
                                                            var _a, _b;
                                                            this.emitLine("* tmp", level > 0 ? level.toString() : "", " = ", 
                                                            // @ts-expect-error awaiting refactor
                                                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.getValue, "(e", child_level.toString(), ");");
                                                            this.emitLine("list_add_tail(x", child_level.toString(), ", tmp", level > 0 ? level.toString() : "", ", sizeof(", 
                                                            // @ts-expect-error awaiting refactor
                                                            (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                                        });
                                                    }
                                                };
                                                if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                                    this.emitBlock([
                                                        "if (!cJSON_IsNull(e",
                                                        child_level.toString(),
                                                        "))"
                                                    ], () => {
                                                        add(property.type, cJSON, level, child_level);
                                                    });
                                                    this.emitBlock(["else"], () => {
                                                        this.emitLine("list_add_tail(x", child_level.toString(), ", (void *)0xDEADBEEF, sizeof(void *));");
                                                    });
                                                }
                                                else {
                                                    add(property.type, cJSON, level, child_level);
                                                }
                                            });
                                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = x", child_level.toString(), ";");
                                        });
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                                        const child_level = level + 1;
                                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = hashtable_create(", this.hashtableSize, ", false);");
                                        this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                            this.emitLine("cJSON * e", child_level.toString(), " = NULL;");
                                            this.emitLine("cJSON * j", child_level.toString(), " = cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                                            this.emitBlock([
                                                "cJSON_ArrayForEach(e",
                                                child_level.toString(),
                                                ", j",
                                                child_level.toString(),
                                                ")"
                                            ], () => {
                                                var _a;
                                                const add = (type, cJSON, level, child_level) => {
                                                    var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") {
                                                        if (type instanceof MapType) {
                                                            const child_level2 = child_level + 1;
                                                            recur(type.values, child_level);
                                                            this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, x", child_level2.toString(), ", sizeof(", (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                                        }
                                                        else {
                                                            panic("Invalid type");
                                                        }
                                                    }
                                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") ;
                                                    else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" ||
                                                        ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") {
                                                        this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (", (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cType, " *)0xDEADBEEF, sizeof(", (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cType, " *));");
                                                    }
                                                    else if (((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_String") {
                                                        this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, strdup(", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.getValue, "(e", child_level.toString(), ")), sizeof(", (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.cType, " *));");
                                                    }
                                                    else if (((_m = cJSON.items) === null || _m === void 0 ? void 0 : _m.cjsonType) === "cJSON_Object" ||
                                                        ((_o = cJSON.items) === null || _o === void 0 ? void 0 : _o.cjsonType) === "cJSON_Union") {
                                                        this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, ", (_p = cJSON.items) === null || _p === void 0 ? void 0 : _p.getValue, "(e", child_level.toString(), "), sizeof(", (_q = cJSON.items) === null || _q === void 0 ? void 0 : _q.cType, " *));");
                                                    }
                                                    else {
                                                        this.emitLine(
                                                        // @ts-expect-error awaiting refactor
                                                        (_r = cJSON.items) === null || _r === void 0 ? void 0 : _r.cType, " * tmp", level > 0 ? level.toString() : "", " = cJSON_malloc(sizeof(", (_s = cJSON.items) === null || _s === void 0 ? void 0 : _s.cType, "));");
                                                        this.emitBlock([
                                                            "if (NULL != tmp",
                                                            level > 0 ? level.toString() : "",
                                                            ")"
                                                        ], () => {
                                                            var _a, _b;
                                                            this.emitLine("* tmp", level > 0 ? level.toString() : "", " = ", 
                                                            // @ts-expect-error awaiting refactor
                                                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.getValue, "(e", child_level.toString(), ");");
                                                            this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, tmp", level > 0 ? level.toString() : "", ", sizeof(", 
                                                            // @ts-expect-error awaiting refactor
                                                            (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *));");
                                                        });
                                                    }
                                                };
                                                if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                                    this.emitBlock([
                                                        "if (!cJSON_IsNull(e",
                                                        child_level.toString(),
                                                        "))"
                                                    ], () => {
                                                        add(property.type, cJSON, level, child_level);
                                                    });
                                                    this.emitBlock(["else"], () => {
                                                        this.emitLine("hashtable_add(x", child_level.toString(), ", e", child_level.toString(), "->string, (void *)0xDEADBEEF, sizeof(void *));");
                                                    });
                                                }
                                                else {
                                                    add(property.type, cJSON, level, child_level);
                                                }
                                            });
                                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = x", child_level.toString(), ";");
                                        });
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Invalid" ||
                                        cJSON.cjsonType === "cJSON_NULL") {
                                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = (", cJSON.cType, " *)0xDEADBEEF;");
                                    }
                                    else if (cJSON.cjsonType === "cJSON_String") {
                                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = strdup(", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '")));');
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Object" ||
                                        cJSON.cjsonType === "cJSON_Union") {
                                        this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                                    }
                                    else {
                                        if (property.isOptional || cJSON.isNullable) {
                                            this.emitBlock([
                                                "if (NULL != (x",
                                                level > 0 ? level.toString() : "",
                                                "->",
                                                name,
                                                " = cJSON_malloc(sizeof(",
                                                cJSON.cType,
                                                "))))"
                                            ], () => {
                                                this.emitLine("*x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                                            });
                                        }
                                        else {
                                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = ", cJSON.getValue, "(cJSON_GetObjectItemCaseSensitive(j", level > 0 ? level.toString() : "", ', "', jsonName, '"));');
                                        }
                                    }
                                });
                                if (!property.isOptional && !cJSON.isNullable) {
                                    if (cJSON.cjsonType === "cJSON_Array") {
                                        this.emitBlock(["else"], () => {
                                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = list_create(false, NULL);");
                                        });
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Map") {
                                        this.emitBlock(["else"], () => {
                                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = hashtable_create(", this.hashtableSize, ", false);");
                                        });
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Invalid" ||
                                        cJSON.cjsonType === "cJSON_NULL") {
                                        this.emitBlock(["else"], () => {
                                            this.emitLine("x", level > 0 ? level.toString() : "", "->", name, " = (", cJSON.cType, " *)0xDEADBEEF;");
                                        });
                                    }
                                    else if (cJSON.cjsonType === "cJSON_String") {
                                        this.emitBlock(["else"], () => {
                                            this.emitBlock([
                                                "if (NULL != (x",
                                                level > 0 ? level.toString() : "",
                                                "->",
                                                name,
                                                " = cJSON_malloc(sizeof(",
                                                cJSON.cType,
                                                "))))"
                                            ], () => {
                                                this.emitLine("x", level > 0 ? level.toString() : "", "->", name, "[0] = '\\0';");
                                            });
                                        });
                                    }
                                    else ;
                                }
                            });
                        }
                    };
                    recur(classType, 0);
                });
            });
            this.emitLine("return x;");
        });
        this.ensureBlankLine();
        /* Create className to cJSON generator function */
        this.emitBlock(["cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
            this.emitLine("cJSON * j = NULL;");
            this.emitBlock(["if (NULL != x)"], () => {
                this.emitBlock(["if (NULL != (j = cJSON_CreateObject()))"], () => {
                    const recur = (type, level) => {
                        if (type instanceof ArrayType) {
                            const child_level = level + 1;
                            const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                            this.emitLine("cJSON * j", child_level.toString(), " = cJSON_CreateArray();");
                            this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                                this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_get_head(x", level.toString(), ");");
                                this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                                    if (cJSON.cjsonType === "cJSON_Array") {
                                        const child_level2 = child_level + 1;
                                        recur(type.items, child_level);
                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", j", child_level2.toString(), ");");
                                    }
                                    else if (cJSON.cjsonType === "cJSON_Map") ;
                                    else if (cJSON.cjsonType === "cJSON_Invalid") ;
                                    else if (cJSON.cjsonType === "cJSON_NULL") {
                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "());");
                                    }
                                    else if (cJSON.cjsonType === "cJSON_String" ||
                                        cJSON.cjsonType === "cJSON_Object" ||
                                        cJSON.cjsonType === "cJSON_Union") {
                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "(x", child_level.toString(), "));");
                                    }
                                    else {
                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", cJSON.createObject, "(*x", child_level.toString(), "));");
                                    }
                                    this.emitLine("x", child_level.toString(), " = list_get_next(x", level.toString(), ");");
                                });
                            });
                        }
                        else if (type instanceof ClassType) {
                            this.forEachClassProperty(type, "none", (name, jsonName, property) => {
                                const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                                    const child_level = level + 1;
                                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                        this.emitLine("cJSON * j", child_level.toString(), " = cJSON_AddArrayToObject(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                                        this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                                            var _a;
                                            this.emitLine(
                                            // @ts-expect-error awaiting refactor
                                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x", child_level.toString(), " = list_get_head(x", level > 0 ? level.toString() : "", "->", name, ");");
                                            this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                                                var _a;
                                                const add = (type, cJSON, child_level) => {
                                                    var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") {
                                                        if (type instanceof ArrayType) {
                                                            const child_level2 = child_level + 1;
                                                            recur(type.items, child_level);
                                                            this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", j", child_level2.toString(), ");");
                                                        }
                                                        else {
                                                            panic("Invalid type");
                                                        }
                                                    }
                                                    else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") ;
                                                    else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                                    }
                                                    else if (((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" ||
                                                        ((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" ||
                                                        ((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level.toString(), "));");
                                                    }
                                                    else {
                                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", ", 
                                                        // @ts-expect-error awaiting refactor
                                                        (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.createObject, "(*x", child_level.toString(), "));");
                                                    }
                                                };
                                                if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                                    this.emitBlock([
                                                        "if ((void *)0xDEADBEEF != x",
                                                        child_level.toString(),
                                                        ")"
                                                    ], () => {
                                                        add(property.type, cJSON, child_level);
                                                    });
                                                    this.emitBlock(["else"], () => {
                                                        this.emitLine("cJSON_AddItemToArray(j", child_level.toString(), ", cJSON_CreateNull());");
                                                    });
                                                }
                                                else {
                                                    add(property.type, cJSON, child_level);
                                                }
                                                this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->", name, ");");
                                            });
                                        });
                                    });
                                }
                                else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                                    const child_level = level + 1;
                                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                        this.emitLine("cJSON * j", child_level.toString(), " = ", cJSON.createObject, "();");
                                        this.emitBlock(["if (NULL != j", child_level.toString(), ")"], () => {
                                            this.emitLine("char **keys", child_level.toString(), " = NULL;");
                                            this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->", name, ", &keys", child_level.toString(), ");");
                                            this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                                                this.emitBlock([
                                                    "for (size_t index",
                                                    child_level.toString(),
                                                    " = 0; index",
                                                    child_level.toString(),
                                                    " < count",
                                                    child_level.toString(),
                                                    "; index",
                                                    child_level.toString(),
                                                    "++)"
                                                ], () => {
                                                    var _a, _b;
                                                    this.emitLine(
                                                    // @ts-expect-error awaiting refactor
                                                    (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x", child_level.toString(), " = hashtable_lookup(x", level > 0 ? level.toString() : "", "->", name, ", keys", child_level.toString(), "[index", child_level.toString(), "]);");
                                                    const add = (type, cJSON, child_level) => {
                                                        var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                                                        if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") {
                                                            if (type instanceof MapType) {
                                                                const child_level2 = child_level + 1;
                                                                recur(type.values, child_level);
                                                                this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], j", child_level2.toString(), ");");
                                                            }
                                                            else {
                                                                panic("Invalid type");
                                                            }
                                                        }
                                                        else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                                        else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") ;
                                                        else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                                            this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], ", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                                        }
                                                        else if (((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" ||
                                                            ((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" ||
                                                            ((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                                            this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], ", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x", child_level.toString(), "));");
                                                        }
                                                        else {
                                                            this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], ", 
                                                            // @ts-expect-error awaiting refactor
                                                            (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.createObject, "(*x", child_level.toString(), "));");
                                                        }
                                                    };
                                                    if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                                                        this.emitBlock([
                                                            "if ((void *)0xDEADBEEF != x",
                                                            child_level.toString(),
                                                            ")"
                                                        ], () => {
                                                            add(property.type, cJSON, child_level);
                                                        });
                                                        this.emitBlock(["else"], () => {
                                                            this.emitLine(cJSON.addToObject, "(j", child_level.toString(), ", keys", child_level.toString(), "[index", child_level.toString(), "], cJSON_CreateNull());");
                                                        });
                                                    }
                                                    else {
                                                        add(property.type, cJSON, child_level);
                                                    }
                                                });
                                                this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                                            });
                                            this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", j', child_level.toString(), ");");
                                        });
                                    });
                                }
                                else if (cJSON.cjsonType === "cJSON_Invalid") ;
                                else if (cJSON.cjsonType === "cJSON_NULL") {
                                    if (property.isOptional) {
                                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                            this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                                        });
                                    }
                                    else {
                                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                                    }
                                }
                                else if (cJSON.cjsonType === "cJSON_String") {
                                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", x', level > 0 ? level.toString() : "", "->", name, ");");
                                    });
                                    if (!property.isOptional && !cJSON.isNullable) {
                                        this.emitBlock(["else"], () => {
                                            this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", "");');
                                        });
                                    }
                                }
                                else if (cJSON.cjsonType === "cJSON_Object" ||
                                    cJSON.cjsonType === "cJSON_Union") {
                                    if (property.isOptional || cJSON.isNullable) {
                                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                            this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                                        });
                                    }
                                    else {
                                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                                    }
                                }
                                else if (cJSON.cjsonType === "cJSON_Enum") {
                                    if (property.isOptional || cJSON.isNullable) {
                                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                            this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(*x", level > 0 ? level.toString() : "", "->", name, "));");
                                        });
                                    }
                                    else {
                                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", ', cJSON.createObject, "(x", level > 0 ? level.toString() : "", "->", name, "));");
                                    }
                                }
                                else {
                                    if (property.isOptional || cJSON.isNullable) {
                                        this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                            this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", *x', level > 0 ? level.toString() : "", "->", name, ");");
                                        });
                                    }
                                    else {
                                        this.emitLine(cJSON.addToObject, "(j", level > 0 ? level.toString() : "", ', "', jsonName, '", x', level > 0 ? level.toString() : "", "->", name, ");");
                                    }
                                }
                                if (cJSON.isNullable) {
                                    this.emitBlock(["else"], () => {
                                        this.emitLine("cJSON_AddNullToObject(j", level > 0 ? level.toString() : "", ', "', jsonName, '");');
                                    });
                                }
                            });
                        }
                    };
                    recur(classType, 0);
                });
            });
            this.emitLine("return j;");
        });
        this.ensureBlankLine();
        /* Create className to string generator function */
        this.emitBlock(["char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
            this.emitLine("char * s = NULL;");
            this.emitBlock(["if (NULL != x)"], () => {
                this.emitLine("cJSON * j = cJSON_Create", className, "(x);");
                this.emitBlock(["if (NULL != j)"], () => {
                    this.emitLine(this._options.printStyle ? "s = cJSON_PrintUnformatted(j);" : "s = cJSON_Print(j);");
                    this.emitLine("cJSON_Delete(j);");
                });
            });
            this.emitLine("return s;");
        });
        this.ensureBlankLine();
        /* Create className delete function */
        this.emitBlock(["void cJSON_Delete", className, "(struct ", className, " * x)"], () => {
            this.emitBlock(["if (NULL != x)"], () => {
                const recur = (type, level) => {
                    if (type instanceof ArrayType) {
                        const child_level = level + 1;
                        const cJSON = this.quicktypeTypeToCJSON(type.items, false);
                        this.emitLine(cJSON.cType, " * x", child_level.toString(), " = list_get_head(x", level.toString(), ");");
                        this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                            if (cJSON.cjsonType === "cJSON_Array") {
                                recur(type.items, child_level);
                                this.emitLine(cJSON.deleteType, "(x", child_level.toString(), ");");
                            }
                            else if (cJSON.cjsonType === "cJSON_Map") ;
                            else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") ;
                            else {
                                this.emitLine(cJSON.deleteType, "(x", child_level.toString(), ");");
                            }
                            this.emitLine("x", child_level.toString(), " = list_get_next(x", level.toString(), ");");
                        });
                    }
                    else if (type instanceof ClassType) {
                        this.forEachClassProperty(type, "none", (name, _jsonName, property) => {
                            const cJSON = this.quicktypeTypeToCJSON(property.type, property.isOptional);
                            if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                                const child_level = level + 1;
                                this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                    var _a;
                                    this.emitLine(
                                    // @ts-expect-error awaiting refactor
                                    (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x", child_level.toString(), " = list_get_head(x", level > 0 ? level.toString() : "", "->", name, ");");
                                    this.emitBlock(["while (NULL != x", child_level.toString(), ")"], () => {
                                        var _a, _b, _d, _e, _f, _g, _h;
                                        if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") {
                                            if (property.type instanceof ArrayType) {
                                                recur(property.type.items, child_level);
                                                this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x", child_level.toString(), ");");
                                            }
                                            else {
                                                panic("Invalid type");
                                            }
                                        }
                                        else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") ;
                                        else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" ||
                                            ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") ;
                                        else {
                                            if ((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.isNullable) {
                                                this.emitBlock(["if ((void *)0xDEADBEEF != x", child_level.toString(), ")"], () => {
                                                    var _a;
                                                    this.emitLine(
                                                    // @ts-expect-error awaiting refactor
                                                    (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.deleteType, "(x", child_level.toString(), ");");
                                                });
                                            }
                                            else {
                                                this.emitLine(
                                                // @ts-expect-error awaiting refactor
                                                (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.deleteType, "(x", child_level.toString(), ");");
                                            }
                                        }
                                        this.emitLine("x", child_level.toString(), " = list_get_next(x", level > 0 ? level.toString() : "", "->", name, ");");
                                    });
                                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                                });
                            }
                            else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                                const child_level = level + 1;
                                this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                    this.emitLine("char **keys", child_level.toString(), " = NULL;");
                                    this.emitLine("size_t count", child_level.toString(), " = hashtable_get_keys(x", level > 0 ? level.toString() : "", "->", name, ", &keys", child_level.toString(), ");");
                                    this.emitBlock(["if (NULL != keys", child_level.toString(), ")"], () => {
                                        this.emitBlock([
                                            "for (size_t index",
                                            child_level.toString(),
                                            " = 0; index",
                                            child_level.toString(),
                                            " < count",
                                            child_level.toString(),
                                            "; index",
                                            child_level.toString(),
                                            "++)"
                                        ], () => {
                                            var _a;
                                            this.emitLine(
                                            // @ts-expect-error awaiting refactor
                                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x", child_level.toString(), " = hashtable_lookup(x", level > 0 ? level.toString() : "", "->", name, ", keys", child_level.toString(), "[index", child_level.toString(), "]);");
                                            this.emitBlock(["if (NULL != x", child_level.toString(), ")"], () => {
                                                var _a, _b, _d, _e, _f, _g, _h;
                                                if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") {
                                                    if (property.type instanceof MapType) {
                                                        recur(property.type.values, child_level);
                                                        this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x", child_level.toString(), ");");
                                                    }
                                                    else {
                                                        panic("Invalid type");
                                                    }
                                                }
                                                else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Map") ;
                                                else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_Invalid" ||
                                                    ((_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cjsonType) === "cJSON_NULL") ;
                                                else {
                                                    if ((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.isNullable) {
                                                        this.emitBlock([
                                                            "if ((void *)0xDEADBEEF != x",
                                                            child_level.toString(),
                                                            ")"
                                                        ], () => {
                                                            var _a;
                                                            this.emitLine(
                                                            // @ts-expect-error awaiting refactor
                                                            (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.deleteType, "(x", child_level.toString(), ");");
                                                        });
                                                    }
                                                    else {
                                                        this.emitLine(
                                                        // @ts-expect-error awaiting refactor
                                                        (_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.deleteType, "(x", child_level.toString(), ");");
                                                    }
                                                }
                                            });
                                        });
                                        this.emitLine("cJSON_free(keys", child_level.toString(), ");");
                                    });
                                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                                });
                            }
                            else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") ;
                            else if (cJSON.cjsonType === "cJSON_String" ||
                                cJSON.cjsonType === "cJSON_Object" ||
                                cJSON.cjsonType === "cJSON_Union") {
                                this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                    this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                                });
                            }
                            else {
                                if (property.isOptional || cJSON.isNullable) {
                                    this.emitBlock(["if (NULL != x", level > 0 ? level.toString() : "", "->", name, ")"], () => {
                                        this.emitLine(cJSON.deleteType, "(x", level > 0 ? level.toString() : "", "->", name, ");");
                                    });
                                }
                            }
                        });
                    }
                };
                recur(classType, 0);
                this.emitLine("cJSON_free(x);");
            });
        });
        this.ensureBlankLine();
    }
    /**
     * Function called to create a top level header files with types and generators
     * @param type: type of the top level element
     * @param className: top level class name
     * @param includes: Array of includes
     */
    emitTopLevel(type, className, includes) {
        /* Create file */
        const filename = this.sourcelikeToString(className).concat(".h");
        this.startFile(filename);
        /* Create includes - This create too much includes but this is safer because of specific corner cases */
        includes.forEach(name => {
            this.emitIncludeLine(name);
        });
        this.ensureBlankLine();
        /* Create types */
        this.emitTopLevelTypedef(type, className);
        /* Create prototypes */
        this.emitTopLevelPrototypes(type, className);
        /* Create functions */
        this.emitTopLevelFunctions(type, className);
        /* Close file */
        this.finishFile();
    }
    /**
     * Function called to create top level typedef
     * @param type: type of the top level element
     * @param className: top level class name
     */
    emitTopLevelTypedef(type, className) {
        this.emitBlock(["struct ", className], () => {
            const cJSON = this.quicktypeTypeToCJSON(type, false);
            this.emitLine(cJSON.cType, cJSON.optionalQualifier !== "" ? " " : "", cJSON.optionalQualifier, " value;");
        }, "", true);
        this.ensureBlankLine();
        this.emitTypedefAlias(type, className);
    }
    /**
     * Function called to create top level prototypes
     * @param type: type of the top level element
     * @param className: top level class name
     */
    emitTopLevelPrototypes(_type, className) {
        this.emitLine("struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s);");
        this.emitLine("struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j);");
        this.emitLine("cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x);");
        this.emitLine("void cJSON_Delete", className, "(struct ", className, " * x);");
        this.ensureBlankLine();
    }
    /**
     * Function called to create top level functions
     * @param type: type of the top level element
     * @param className: top level class name
     */
    emitTopLevelFunctions(type, className) {
        /* Create string to className generator function */
        this.emitBlock(["struct ", className, " * cJSON_Parse", className, "(", this.withConst("char"), " * s)"], () => {
            this.emitLine("struct ", className, " * x = NULL;");
            this.emitBlock(["if (NULL != s)"], () => {
                this.emitLine("cJSON * j = cJSON_Parse(s);");
                this.emitBlock(["if (NULL != j)"], () => {
                    this.emitLine("x = cJSON_Get", className, "Value(j);");
                    this.emitLine("cJSON_Delete(j);");
                });
            });
            this.emitLine("return x;");
        });
        this.ensureBlankLine();
        /* Create cJSON to className generator function */
        this.emitBlock(["struct ", className, " * cJSON_Get", className, "Value(", this.withConst("cJSON"), " * j)"], () => {
            this.emitLine("struct ", className, " * x = NULL;");
            this.emitBlock(["if (NULL != j)"], () => {
                this.emitBlock(["if (NULL != (x = cJSON_malloc(sizeof(struct ", className, "))))"], () => {
                    this.emitLine("memset(x, 0, sizeof(struct ", className, "));");
                    const cJSON = this.quicktypeTypeToCJSON(type, false);
                    if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                        this.emitLine("x->value = list_create(false, NULL);");
                        this.emitBlock(["if (NULL != x->value)"], () => {
                            this.emitLine("cJSON * e = NULL;");
                            this.emitBlock(["cJSON_ArrayForEach(e, j)"], () => {
                                var _a;
                                const add = (cJSON) => {
                                    var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                    else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" ||
                                        ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                        this.emitLine("list_add_tail(x->value, (", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEAF, sizeof(", (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                                    }
                                    else if (((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                                        this.emitLine("list_add_tail(x->value, strdup(", (_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e)), sizeof(", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                                    }
                                    else {
                                        this.emitLine("list_add_tail(x->value, ", 
                                        // @ts-expect-error awaiting refactor
                                        (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.getValue, "(e), sizeof(", (_m = cJSON.items) === null || _m === void 0 ? void 0 : _m.cType, " *));");
                                    }
                                };
                                if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                    this.emitBlock(["if (!cJSON_IsNull(e))"], () => {
                                        add(cJSON);
                                    });
                                    this.emitBlock(["else"], () => {
                                        this.emitLine("list_add_tail(x->value, (void *)0xDEADBEEF, sizeof(void *));");
                                    });
                                }
                                else {
                                    add(cJSON);
                                }
                            });
                        });
                    }
                    else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                        this.emitLine("x->value = hashtable_create(", this.hashtableSize, ", false);");
                        this.emitBlock(["if (NULL != x->value)"], () => {
                            this.emitLine("cJSON * e = NULL;");
                            this.emitBlock(["cJSON_ArrayForEach(e, j)"], () => {
                                var _a;
                                const add = (cJSON) => {
                                    var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                    else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid" ||
                                        ((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                        this.emitLine("hashtable_add(x->value, e->string, (", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.cType, " *)0xDEADBEEF, sizeof(", (_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cType, " *));");
                                    }
                                    else if (((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_String") {
                                        this.emitLine("hashtable_add(x->value, e->string, strdup(", (_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.getValue, "(e)), sizeof(", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.cType, " *));");
                                    }
                                    else {
                                        this.emitLine("hashtable_add(x->value, e->string, ", 
                                        // @ts-expect-error awaiting refactor
                                        (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.getValue, "(e), sizeof(", (_m = cJSON.items) === null || _m === void 0 ? void 0 : _m.cType, " *));");
                                    }
                                };
                                if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                    this.emitBlock(["if (!cJSON_IsNull(e))"], () => {
                                        add(cJSON);
                                    });
                                    this.emitBlock(["else"], () => {
                                        this.emitLine("hashtable_add(x->value, e->string, (void *)0xDEADBEEF, sizeof(void *));");
                                    });
                                }
                                else {
                                    add(cJSON);
                                }
                            });
                        });
                    }
                    else if (cJSON.cjsonType === "cJSON_Invalid") ;
                    else if (cJSON.cjsonType === "cJSON_NULL") {
                        this.emitLine("x->value = (", cJSON.cType, " *)0xDEADBEEF;");
                    }
                    else if (cJSON.cjsonType === "cJSON_String") {
                        this.emitLine("x->value = strdup(", cJSON.getValue, "(j));");
                    }
                    else {
                        this.emitLine("x->value = ", cJSON.getValue, "(j);");
                    }
                });
            });
            this.emitLine("return x;");
        });
        this.ensureBlankLine();
        /* Create className to cJSON generator function */
        this.emitBlock(["cJSON * cJSON_Create", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
            this.emitLine("cJSON * j = NULL;");
            this.emitBlock(["if (NULL != x)"], () => {
                const cJSON = this.quicktypeTypeToCJSON(type, false);
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                    this.emitBlock(["if (NULL != x->value)"], () => {
                        this.emitLine("j = ", cJSON.createObject, "();");
                        this.emitBlock(["if (NULL != j)"], () => {
                            var _a;
                            // @ts-expect-error awaiting refactor
                            this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x1 = list_get_head(x->value);");
                            this.emitBlock(["while (NULL != x1)"], () => {
                                var _a;
                                const add = (cJSON) => {
                                    var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                                    if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                    else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                    else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") ;
                                    else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                        this.emitLine("cJSON_AddItemToArray(j, ", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                    }
                                    else if (((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" ||
                                        ((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" ||
                                        ((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                        this.emitLine("cJSON_AddItemToArray(j, ", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x1));");
                                    }
                                    else {
                                        this.emitLine("cJSON_AddItemToArray(j, ", 
                                        // @ts-expect-error awaiting refactor
                                        (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.createObject, "(*x1));");
                                    }
                                };
                                if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                    this.emitBlock(["if ((void *)0xDEADBEEF != x1)"], () => {
                                        add(cJSON);
                                    });
                                    this.emitBlock(["else"], () => {
                                        this.emitLine("cJSON_AddItemToArray(j, cJSON_CreateNull());");
                                    });
                                }
                                else {
                                    add(cJSON);
                                }
                                this.emitLine("x1 = list_get_next(x->value);");
                            });
                        });
                    });
                }
                else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                    this.emitBlock(["if (NULL != x->value)"], () => {
                        this.emitLine("j = ", cJSON.createObject, "();");
                        this.emitBlock(["if (NULL != j)"], () => {
                            this.emitLine("char **keys = NULL;");
                            this.emitLine("size_t count = hashtable_get_keys(x->value, &keys);");
                            this.emitBlock(["if (NULL != keys)"], () => {
                                this.emitBlock(["for (size_t index = 0; index < count; index++)"], () => {
                                    var _a, _b;
                                    this.emitLine(
                                    // @ts-expect-error awaiting refactor
                                    (_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x2 = hashtable_lookup(x->value, keys[index]);");
                                    const add = (cJSON) => {
                                        var _a, _b, _d, _e, _f, _g, _h, _j, _k, _l;
                                        if (((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cjsonType) === "cJSON_Array") ;
                                        else if (((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cjsonType) === "cJSON_Map") ;
                                        else if (((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.cjsonType) === "cJSON_Invalid") ;
                                        else if (((_e = cJSON.items) === null || _e === void 0 ? void 0 : _e.cjsonType) === "cJSON_NULL") {
                                            this.emitLine(cJSON.addToObject, "(j, keys[index], ", (_f = cJSON.items) === null || _f === void 0 ? void 0 : _f.createObject, "());");
                                        }
                                        else if (((_g = cJSON.items) === null || _g === void 0 ? void 0 : _g.cjsonType) === "cJSON_String" ||
                                            ((_h = cJSON.items) === null || _h === void 0 ? void 0 : _h.cjsonType) === "cJSON_Object" ||
                                            ((_j = cJSON.items) === null || _j === void 0 ? void 0 : _j.cjsonType) === "cJSON_Union") {
                                            this.emitLine(cJSON.addToObject, "(j, keys[index], ", (_k = cJSON.items) === null || _k === void 0 ? void 0 : _k.createObject, "(x2));");
                                        }
                                        else {
                                            this.emitLine(cJSON.addToObject, "(j, keys[index], ", 
                                            // @ts-expect-error awaiting refactor
                                            (_l = cJSON.items) === null || _l === void 0 ? void 0 : _l.createObject, "(*x2));");
                                        }
                                    };
                                    if ((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.isNullable) {
                                        this.emitBlock(["if ((void *)0xDEADBEEF != x2)"], () => {
                                            add(cJSON);
                                        });
                                        this.emitBlock(["else"], () => {
                                            this.emitLine(cJSON.addToObject, "(j, keys[index], cJSON_CreateNull());");
                                        });
                                    }
                                    else {
                                        add(cJSON);
                                    }
                                });
                                this.emitLine("cJSON_free(keys);");
                            });
                        });
                    });
                }
                else if (cJSON.cjsonType === "cJSON_Invalid") ;
                else if (cJSON.cjsonType === "cJSON_NULL") {
                    this.emitLine("j = ", cJSON.createObject, "();");
                }
                else {
                    this.emitLine("j = ", cJSON.createObject, "(x->value);");
                }
            });
            this.emitLine("return j;");
        });
        this.ensureBlankLine();
        /* Create className to string generator function */
        this.emitBlock(["char * cJSON_Print", className, "(", this.withConst(["struct ", className]), " * x)"], () => {
            this.emitLine("char * s = NULL;");
            this.emitBlock(["if (NULL != x)"], () => {
                this.emitLine("cJSON * j = cJSON_Create", className, "(x);");
                this.emitBlock(["if (NULL != j)"], () => {
                    this.emitLine("s = cJSON_Print(j);");
                    this.emitLine("cJSON_Delete(j);");
                });
            });
            this.emitLine("return s;");
        });
        this.ensureBlankLine();
        /* Create className delete function */
        this.emitBlock(["void cJSON_Delete", className, "(struct ", className, " * x)"], () => {
            this.emitBlock(["if (NULL != x)"], () => {
                const cJSON = this.quicktypeTypeToCJSON(type, false);
                if (cJSON.cjsonType === "cJSON_Array" && cJSON.items !== undefined) {
                    this.emitBlock(["if (NULL != x->value)"], () => {
                        var _a;
                        // @ts-expect-error awaiting refactor
                        this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " * x1 = list_get_head(x->value);");
                        this.emitBlock(["while (NULL != x1)"], () => {
                            var _a, _b;
                            if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                this.emitBlock(["if ((void *)0xDEADBEEF != x1)"], () => {
                                    var _a;
                                    // @ts-expect-error awaiting refactor
                                    this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.deleteType, "(x1);");
                                });
                            }
                            else {
                                // @ts-expect-error awaiting refactor
                                this.emitLine((_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.deleteType, "(x1);");
                            }
                            this.emitLine("x1 = list_get_next(x->value);");
                        });
                        this.emitLine(cJSON.deleteType, "(x->value);");
                    });
                }
                else if (cJSON.cjsonType === "cJSON_Map" && cJSON.items !== undefined) {
                    this.emitBlock(["if (NULL != x->value)"], () => {
                        this.emitLine("char **keys = NULL;");
                        this.emitLine("size_t count = hashtable_get_keys(x->value, &keys);");
                        this.emitBlock(["if (NULL != keys)"], () => {
                            this.emitBlock(["for (size_t index = 0; index < count; index++)"], () => {
                                var _a;
                                // @ts-expect-error awaiting refactor
                                this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.cType, " *x2 = hashtable_lookup(x->value, keys[index]);");
                                this.emitBlock(["if (NULL != x2)"], () => {
                                    var _a, _b, _d;
                                    if ((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.isNullable) {
                                        this.emitBlock(["if ((", (_b = cJSON.items) === null || _b === void 0 ? void 0 : _b.cType, " *)0xDEADBEEF != x2)"], () => {
                                            var _a;
                                            // @ts-expect-error awaiting refactor
                                            this.emitLine((_a = cJSON.items) === null || _a === void 0 ? void 0 : _a.deleteType, "(x2);");
                                        });
                                    }
                                    else {
                                        // @ts-expect-error awaiting refactor
                                        this.emitLine((_d = cJSON.items) === null || _d === void 0 ? void 0 : _d.deleteType, "(x2);");
                                    }
                                });
                            });
                            this.emitLine("cJSON_free(keys);");
                        });
                        this.emitLine(cJSON.deleteType, "(x->value);");
                    });
                }
                else if (cJSON.cjsonType === "cJSON_Invalid" || cJSON.cjsonType === "cJSON_NULL") ;
                else if (cJSON.cjsonType === "cJSON_String" ||
                    cJSON.cjsonType === "cJSON_Object" ||
                    cJSON.cjsonType === "cJSON_Union") {
                    this.emitLine(cJSON.deleteType, "(x->value);");
                }
                else ;
                this.emitLine("cJSON_free(x);");
            });
        });
        this.ensureBlankLine();
    }
    /**
     * Convert quicktype type to cJSON type
     * @param t: quicktype type
     * @param isOptional: true if the field is optional
     * @param isNullable: true if the field is nullable
     * @return cJSON type
     */
    quicktypeTypeToCJSON(t, isOptional, isNullable = false) {
        /* Compute cJSON type */
        return matchType(t, _anyType => {
            return {
                cType: "void",
                optionalQualifier: "*",
                cjsonType: "cJSON_Invalid",
                isType: "cJSON_IsInvalid",
                getValue: "",
                addToObject: "",
                createObject: "",
                deleteType: "",
                items: undefined,
                isNullable
            };
        }, _nullType => {
            return {
                cType: "void",
                optionalQualifier: "*",
                cjsonType: "cJSON_NULL",
                isType: "cJSON_IsNull",
                getValue: "",
                addToObject: "cJSON_AddNullToObject",
                createObject: "cJSON_CreateNull",
                deleteType: "cJSON_free",
                items: undefined,
                isNullable
            };
        }, _boolType => {
            return {
                cType: "bool",
                optionalQualifier: isOptional === true ? "*" : "",
                cjsonType: "cJSON_Bool",
                isType: "cJSON_IsBool",
                getValue: "cJSON_IsTrue",
                addToObject: "cJSON_AddBoolToObject",
                createObject: "cJSON_CreateBool",
                deleteType: "cJSON_free",
                items: undefined,
                isNullable
            };
        }, _integerType => {
            return {
                cType: this.typeIntegerSize,
                optionalQualifier: isOptional === true ? "*" : "",
                cjsonType: "cJSON_Number",
                isType: "cJSON_IsNumber",
                getValue: "cJSON_GetNumberValue",
                addToObject: "cJSON_AddNumberToObject",
                createObject: "cJSON_CreateNumber",
                deleteType: "cJSON_free",
                items: undefined,
                isNullable
            };
        }, _doubleType => {
            return {
                cType: "double",
                optionalQualifier: isOptional === true ? "*" : "",
                cjsonType: "cJSON_Number",
                isType: "cJSON_IsNumber",
                getValue: "cJSON_GetNumberValue",
                addToObject: "cJSON_AddNumberToObject",
                createObject: "cJSON_CreateNumber",
                deleteType: "cJSON_free",
                items: undefined,
                isNullable
            };
        }, _stringType => {
            return {
                cType: "char",
                optionalQualifier: "*",
                cjsonType: "cJSON_String",
                isType: "cJSON_IsString",
                getValue: "cJSON_GetStringValue",
                addToObject: "cJSON_AddStringToObject",
                createObject: "cJSON_CreateString",
                deleteType: "cJSON_free",
                items: undefined,
                isNullable
            };
        }, arrayType => {
            const items = this.quicktypeTypeToCJSON(arrayType.items, false);
            return {
                cType: "list_t",
                optionalQualifier: "*",
                cjsonType: "cJSON_Array",
                isType: "cJSON_IsArray",
                getValue: "cJSON_GetArrayItem",
                addToObject: "cJSON_AddItemToObject",
                createObject: "cJSON_CreateArray",
                deleteType: "list_release",
                items,
                isNullable
            };
        }, classType => {
            return {
                cType: ["struct ", this.nameForNamedType(classType)],
                optionalQualifier: "*",
                cjsonType: "cJSON_Object",
                isType: "cJSON_IsObject",
                getValue: ["cJSON_Get", this.nameForNamedType(classType), "Value"],
                addToObject: "cJSON_AddItemToObject",
                createObject: ["cJSON_Create", this.nameForNamedType(classType)],
                deleteType: ["cJSON_Delete", this.nameForNamedType(classType)],
                items: undefined,
                isNullable
            };
        }, mapType => {
            const items = this.quicktypeTypeToCJSON(mapType.values, false);
            return {
                cType: "hashtable_t",
                optionalQualifier: "*",
                cjsonType: "cJSON_Map",
                isType: "cJSON_IsObject",
                getValue: "",
                addToObject: "cJSON_AddItemToObject",
                createObject: "cJSON_CreateObject",
                deleteType: "hashtable_release",
                items,
                isNullable
            };
        }, enumType => {
            return {
                cType: ["enum ", this.nameForNamedType(enumType)],
                optionalQualifier: isOptional === true ? "*" : "",
                cjsonType: "cJSON_Enum",
                isType: "cJSON_IsString",
                getValue: ["cJSON_Get", this.nameForNamedType(enumType), "Value"],
                addToObject: "cJSON_AddItemToObject",
                createObject: ["cJSON_Create", this.nameForNamedType(enumType)],
                deleteType: "cJSON_free",
                items: undefined,
                isNullable
            };
        }, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return this.quicktypeTypeToCJSON(nullable, true, true);
            }
            else {
                return {
                    cType: ["struct ", this.nameForNamedType(unionType)],
                    optionalQualifier: "*",
                    cjsonType: "cJSON_Union",
                    isType: "",
                    getValue: ["cJSON_Get", this.nameForNamedType(unionType), "Value"],
                    addToObject: "cJSON_AddItemToObject",
                    createObject: ["cJSON_Create", this.nameForNamedType(unionType)],
                    deleteType: ["cJSON_Delete", this.nameForNamedType(unionType)],
                    items: undefined,
                    isNullable
                };
            }
        });
    }
    /**
     * Function called to create a file
     * @param proposedFilename: source filename provided from stdin
     */
    startFile(proposedFilename) {
        /* Check if previous file is closed, create a new file */
        assert(this.currentFilename === undefined, "Previous file wasn't finished");
        if (proposedFilename !== undefined) {
            this.currentFilename = this.sourcelikeToString(proposedFilename);
        }
        /* Check if file has been created */
        if (this.currentFilename !== undefined) {
            /* Write header */
            this.emitDescriptionBlock([
                this.currentFilename,
                "This file has been autogenerated using quicktype https://github.com/quicktype/quicktype - DO NOT EDIT",
                "This file depends of https://github.com/DaveGamble/cJSON, https://github.com/joelguittet/c-list and https://github.com/joelguittet/c-hashtable",
                "To parse json data from json string use the following: struct <type> * data = cJSON_Parse<type>(<string>);",
                "To get json data from cJSON object use the following: struct <type> * data = cJSON_Get<type>Value(<cjson>);",
                "To get cJSON object from json data use the following: cJSON * cjson = cJSON_Create<type>(<data>);",
                "To print json string from json data use the following: char * string = cJSON_Print<type>(<data>);",
                "To delete json data use the following: cJSON_Delete<type>(<data>);"
            ]);
            this.ensureBlankLine();
            /* Write include guard */
            this.emitLine("#ifndef __", allUpperWordStyle(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__");
            this.emitLine("#define __", allUpperWordStyle(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__");
            this.ensureBlankLine();
            /* Write C++ guard */
            this.emitLine("#ifdef __cplusplus");
            this.emitLine('extern "C" {');
            this.emitLine("#endif");
            this.ensureBlankLine();
            /* Write includes */
            this.emitIncludeLine("stdint.h", true);
            this.emitIncludeLine("stdbool.h", true);
            this.emitIncludeLine("stdlib.h", true);
            this.emitIncludeLine("string.h", true);
            this.emitIncludeLine("cJSON.h", true);
            this.emitIncludeLine("hashtable.h", true);
            this.emitIncludeLine("list.h", true);
            this.ensureBlankLine();
            /* Additional cJSON types */
            this.emitLine("#ifndef cJSON_Bool");
            this.emitLine("#define cJSON_Bool (cJSON_True | cJSON_False)");
            this.emitLine("#endif");
            this.emitLine("#ifndef cJSON_Map");
            this.emitLine("#define cJSON_Map (1 << 16)");
            this.emitLine("#endif");
            this.emitLine("#ifndef cJSON_Enum");
            this.emitLine("#define cJSON_Enum (1 << 17)");
            this.emitLine("#endif");
            this.ensureBlankLine();
        }
    }
    /**
     * Function called to close current file
     */
    finishFile() {
        /* Check if file has been created */
        if (this.currentFilename !== undefined) {
            /* Write C++ guard */
            this.emitLine("#ifdef __cplusplus");
            this.emitLine("}");
            this.emitLine("#endif");
            this.ensureBlankLine();
            /* Write include guard */
            this.emitLine("#endif /* __", allUpperWordStyle(this.currentFilename.replace(new RegExp(/[^a-zA-Z0-9]+/, "g"), "_")), "__ */");
            this.ensureBlankLine();
            /* Close file */
            super.finishFile(defined(this.currentFilename));
            this.currentFilename = undefined;
        }
    }
    /**
     * Check if type need declaration before use
     * @note If returning true, canBeForwardDeclared must be declared
     * @return Always returns true
     */
    get needsTypeDeclarationBeforeUse() {
        return true;
    }
    /**
     * Check if type can be forward declared
     * @return true for classes, false otherwise
     */
    canBeForwardDeclared(type) {
        return type.kind === "class";
    }
    /**
     * Add const to wanted Sourcelike
     * @return Const Sourcelike
     */
    withConst(s) {
        return ["const ", s];
    }
    /**
     * Emit include line
     * @param name: filename to include
     * @pram global: true if global include, false otherwise (default)
     */
    emitIncludeLine(name, global = false) {
        this.emitLine("#include ", global ? "<" : '"', name, global ? ">" : '"');
    }
    /**
     * Emit description block
     * @param lines: description block lines
     */
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    /**
     * Emit code block
     * @param line: code block line
     * @param f: callback function
     * @param withName: name of the block as string
     * @param withSemicolon: true to add semicolon at the end of the block, false otherwise
     * @param withIndent: true to indent the block (default), false otherwise
     */
    emitBlock(line, f, withName = "", withSemicolon = false, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
            this.indent(f);
        }
        else {
            f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
            if (withName !== "") {
                this.emitLine("} ", withName, ";");
            }
            else {
                this.emitLine("};");
            }
        }
        else {
            if (withName !== "") {
                this.emitLine("} ", withName);
            }
            else {
                this.emitLine("}");
            }
        }
    }
    /**
     * Emit includes
     * @param type: class, union or enum type
     * @param filename: current file name
     */
    emitIncludes(type, filename) {
        /* List required includes */
        const includes = new Map();
        if (type instanceof UnionType) {
            this.updateIncludes(false, includes, type);
        }
        else if (type instanceof ClassType) {
            this.forEachClassProperty(type, "none", (_name, _jsonName, property) => {
                this.updateIncludes(true, includes, property.type);
            });
        }
        /* Emit includes */
        if (includes.size !== 0) {
            includes.forEach((_rec, name) => {
                name = name.concat(".h");
                if (name !== filename) {
                    this.emitIncludeLine(name);
                }
            });
        }
        this.ensureBlankLine();
    }
    /**
     * Compute includes
     * @param isClassMender: true if class, false otherwise
     * @param includes: include map
     * @param propertyType: property type
     */
    updateIncludes(isClassMember, includes, propertyType) {
        const propTypes = this.generatedTypes(isClassMember, propertyType);
        for (const t of propTypes) {
            const typeName = this.sourcelikeToString(t.name);
            const propRecord = { kind: undefined, typeKind: undefined };
            if (t.type instanceof ClassType) {
                /* We can NOT forward declare direct class members, e.g. a class type is included at level#0 */
                /* HOWEVER if it is not a direct class member, then we can SURELY forward declare it */
                propRecord.typeKind = "class";
                propRecord.kind = t.level === 0 ? IncludeKind$1.Include : IncludeKind$1.ForwardDeclare;
                if (t.forceInclude) {
                    propRecord.kind = IncludeKind$1.Include;
                }
            }
            else if (t.type instanceof EnumType) {
                propRecord.typeKind = "enum";
                propRecord.kind = IncludeKind$1.ForwardDeclare;
            }
            else if (t.type instanceof UnionType) {
                propRecord.typeKind = "union";
                /* Recurse into the union */
                const [maybeNull] = removeNullFromUnion(t.type, true);
                if (maybeNull !== undefined) {
                    /* Houston this is a variant, include it */
                    propRecord.kind = IncludeKind$1.Include;
                }
                else {
                    if (t.forceInclude) {
                        propRecord.kind = IncludeKind$1.Include;
                    }
                    else {
                        propRecord.kind = IncludeKind$1.ForwardDeclare;
                    }
                }
            }
            if (includes.has(typeName)) {
                const incKind = includes.get(typeName);
                /* If we already include the type as typed include, do not write it over with forward declare */
                if (incKind !== undefined && incKind.kind === IncludeKind$1.ForwardDeclare) {
                    includes.set(typeName, propRecord);
                }
            }
            else {
                includes.set(typeName, propRecord);
            }
        }
    }
    /**
     * Compute generated types
     * @param isClassMender: true if class, false otherwise
     * @param type: type
     * @return Type record array
     */
    generatedTypes(isClassMember, type) {
        const result = [];
        const recur = (forceInclude, isVariant, l, t) => {
            if (t instanceof ArrayType) {
                recur(forceInclude, isVariant, l + 1, t.items);
            }
            else if (t instanceof ClassType) {
                result.push({
                    name: this.nameForNamedType(t),
                    type: t,
                    level: l,
                    variant: isVariant,
                    forceInclude
                });
            }
            else if (t instanceof MapType) {
                recur(forceInclude, isVariant, l + 1, t.values);
            }
            else if (t instanceof EnumType) {
                result.push({
                    name: this.nameForNamedType(t),
                    type: t,
                    level: l,
                    variant: isVariant,
                    forceInclude: false
                });
            }
            else if (t instanceof UnionType) {
                /**
                 * If we have a union as a class member and we see it as a "named union",
                 * we can safely include it as-is.
                 * HOWEVER if we define a union on its own, we must recurse into the
                 * typedefinition and include all subtypes.
                 */
                if (this.unionNeedsName(t) && isClassMember) {
                    /**
                     * This is NOT ENOUGH.
                     * We have a variant member in a class, e.g. defined with a boost::variant.
                     * The compiler can only compile the class if IT KNOWS THE SIZES
                     * OF ALL MEMBERS OF THE VARIANT.
                     * So it means that you must include ALL SUBTYPES (practically classes only)
                     * AS WELL
                     */
                    forceInclude = true;
                    result.push({
                        name: this.nameForNamedType(t),
                        type: t,
                        level: l,
                        variant: true,
                        forceInclude
                    });
                    /** intentional "fall-through", add all subtypes as well - but forced include */
                }
                const [hasNull, nonNulls] = removeNullFromUnion(t);
                isVariant = hasNull !== null;
                /** we need to collect all the subtypes of the union */
                for (const tt of nonNulls) {
                    recur(forceInclude, isVariant, l + 1, tt);
                }
            }
        };
        recur(false, false, 0, type);
        return result;
    }
}

const pascalValue = ["pascal-case", "pascal"];
const underscoreValue = ["underscore-case", "underscore"];
const camelValue = ["camel-case", "camel"];
const upperUnderscoreValue = ["upper-underscore-case", "upper-underscore"];
const pascalUpperAcronymsValue = ["pascal-case-upper-acronyms", "pascal-upper-acronyms"];
const camelUpperAcronymsValue = ["camel-case-upper-acronyms", "camel-upper-acronyms"];
const cPlusPlusOptions = {
    typeSourceStyle: new EnumOption("source-style", "Source code generation type,  whether to generate single or multiple source files", [
        ["single-source", true],
        ["multi-source", false]
    ], "single-source", "secondary"),
    includeLocation: new EnumOption("include-location", "Whether json.hpp is to be located globally or locally", [
        ["local-include", true],
        ["global-include", false]
    ], "local-include", "secondary"),
    codeFormat: new EnumOption("code-format", "Generate classes with getters/setters, instead of structs", [
        ["with-struct", false],
        ["with-getter-setter", true]
    ], "with-getter-setter"),
    wstring: new EnumOption("wstring", "Store strings using Utf-16 std::wstring, rather than Utf-8 std::string", [
        ["use-string", false],
        ["use-wstring", true]
    ], "use-string"),
    westConst: new EnumOption("const-style", "Put const to the left/west (const T) or right/east (T const)", [
        ["west-const", true],
        ["east-const", false]
    ], "west-const"),
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    namespace: new StringOption("namespace", "Name of the generated namespace(s)", "NAME", "quicktype"),
    enumType: new StringOption("enum-type", "Type of enum class", "NAME", "int", "secondary"),
    typeNamingStyle: new EnumOption("type-style", "Naming style for types", [
        pascalValue,
        underscoreValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
    ]),
    memberNamingStyle: new EnumOption("member-style", "Naming style for members", [
        underscoreValue,
        pascalValue,
        camelValue,
        upperUnderscoreValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
    ]),
    enumeratorNamingStyle: new EnumOption("enumerator-style", "Naming style for enumerators", [
        upperUnderscoreValue,
        underscoreValue,
        pascalValue,
        camelValue,
        pascalUpperAcronymsValue,
        camelUpperAcronymsValue
    ]),
    boost: new BooleanOption("boost", "Require a dependency on boost. Without boost, C++17 is required", true),
    hideNullOptional: new BooleanOption("hide-null-optional", "Hide null value for optional field", false)
};
class CPlusPlusTargetLanguage extends TargetLanguage {
    constructor(displayName = "C++", names = ["c++", "cpp", "cplusplus"], extension = "cpp") {
        super(displayName, names, extension);
    }
    getOptions() {
        return [
            cPlusPlusOptions.justTypes,
            cPlusPlusOptions.namespace,
            cPlusPlusOptions.codeFormat,
            cPlusPlusOptions.wstring,
            cPlusPlusOptions.westConst,
            cPlusPlusOptions.typeSourceStyle,
            cPlusPlusOptions.includeLocation,
            cPlusPlusOptions.typeNamingStyle,
            cPlusPlusOptions.memberNamingStyle,
            cPlusPlusOptions.enumeratorNamingStyle,
            cPlusPlusOptions.enumType,
            cPlusPlusOptions.boost,
            cPlusPlusOptions.hideNullOptional
        ];
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new CPlusPlusRenderer(this, renderContext, getOptionValues(cPlusPlusOptions, untypedOptionValues));
    }
}
function constraintsForType(t) {
    const minMax = minMaxValueForType(t);
    const minMaxLength = minMaxLengthForType(t);
    const pattern = patternForType(t);
    if (minMax === undefined && minMaxLength === undefined && pattern === undefined)
        return undefined;
    return { minMax, minMaxLength, pattern };
}
const legalizeName$j = legalizeCharacters(cp => isAscii(cp) && isLetterOrUnderscoreOrDigit(cp));
const keywords$a = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "bool",
    "break",
    "case",
    "catch",
    "char",
    "char16_t",
    "char32_t",
    "class",
    "compl",
    "concept",
    "const",
    "constexpr",
    "const_cast",
    "continue",
    "co_await",
    "co_return",
    "co_yield",
    "decltype",
    "default",
    "delete",
    "do",
    "double",
    "dynamic_cast",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "float",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "int",
    "long",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "private",
    "protected",
    "public",
    "register",
    "reinterpret_cast",
    "requires",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "static_assert",
    "static_cast",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "unsigned",
    "using",
    "virtual",
    "void",
    "volatile",
    "wchar_t",
    "while",
    "xor",
    "xor_eq",
    "override",
    "final",
    "transaction_safe",
    "transaction_safe_dynamic",
    "NULL"
];
/// Type to use as an optional if cycle breaking is required
const optionalAsSharedType = "std::shared_ptr";
/// Factory to use when creating an optional if cycle breaking is required
const optionalFactoryAsSharedType = "std::make_shared";
/**
 * To be able to support circles in multiple files -
 * e.g. class#A using class#B using class#A (obviously not directly,
 * but in vector or in variant) we can forward declare them;
 */
var IncludeKind;
(function (IncludeKind) {
    IncludeKind["ForwardDeclare"] = "ForwardDeclare";
    IncludeKind["Include"] = "Include";
})(IncludeKind || (IncludeKind = {}));
// FIXME: make these string enums eventually
var GlobalNames;
(function (GlobalNames) {
    GlobalNames[GlobalNames["ClassMemberConstraints"] = 1] = "ClassMemberConstraints";
    GlobalNames[GlobalNames["ClassMemberConstraintException"] = 2] = "ClassMemberConstraintException";
    GlobalNames[GlobalNames["ValueTooLowException"] = 3] = "ValueTooLowException";
    GlobalNames[GlobalNames["ValueTooHighException"] = 4] = "ValueTooHighException";
    GlobalNames[GlobalNames["ValueTooShortException"] = 5] = "ValueTooShortException";
    GlobalNames[GlobalNames["ValueTooLongException"] = 6] = "ValueTooLongException";
    GlobalNames[GlobalNames["InvalidPatternException"] = 7] = "InvalidPatternException";
    GlobalNames[GlobalNames["CheckConstraint"] = 8] = "CheckConstraint";
})(GlobalNames || (GlobalNames = {}));
// FIXME: make these string enums eventually
var MemberNames;
(function (MemberNames) {
    MemberNames[MemberNames["MinIntValue"] = 1] = "MinIntValue";
    MemberNames[MemberNames["GetMinIntValue"] = 2] = "GetMinIntValue";
    MemberNames[MemberNames["SetMinIntValue"] = 3] = "SetMinIntValue";
    MemberNames[MemberNames["MaxIntValue"] = 4] = "MaxIntValue";
    MemberNames[MemberNames["GetMaxIntValue"] = 5] = "GetMaxIntValue";
    MemberNames[MemberNames["SetMaxIntValue"] = 6] = "SetMaxIntValue";
    MemberNames[MemberNames["MinDoubleValue"] = 7] = "MinDoubleValue";
    MemberNames[MemberNames["GetMinDoubleValue"] = 8] = "GetMinDoubleValue";
    MemberNames[MemberNames["SetMinDoubleValue"] = 9] = "SetMinDoubleValue";
    MemberNames[MemberNames["MaxDoubleValue"] = 10] = "MaxDoubleValue";
    MemberNames[MemberNames["GetMaxDoubleValue"] = 11] = "GetMaxDoubleValue";
    MemberNames[MemberNames["SetMaxDoubleValue"] = 12] = "SetMaxDoubleValue";
    MemberNames[MemberNames["MinLength"] = 13] = "MinLength";
    MemberNames[MemberNames["GetMinLength"] = 14] = "GetMinLength";
    MemberNames[MemberNames["SetMinLength"] = 15] = "SetMinLength";
    MemberNames[MemberNames["MaxLength"] = 16] = "MaxLength";
    MemberNames[MemberNames["GetMaxLength"] = 17] = "GetMaxLength";
    MemberNames[MemberNames["SetMaxLength"] = 18] = "SetMaxLength";
    MemberNames[MemberNames["Pattern"] = 19] = "Pattern";
    MemberNames[MemberNames["GetPattern"] = 20] = "GetPattern";
    MemberNames[MemberNames["SetPattern"] = 21] = "SetPattern";
})(MemberNames || (MemberNames = {}));
function addQualifier(qualifier, qualified) {
    if (qualified.length === 0) {
        return [];
    }
    return [qualifier, qualified];
}
class WrappingCode {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
    wrap(qualifier, inner) {
        return [addQualifier(qualifier, this.start), inner, this.end];
    }
}
class BaseString {
    constructor(stringType, constStringType, smatch, regex, stringLiteralPrefix, toString, encodingClass, encodingFunction) {
        this._stringType = stringType;
        this._constStringType = constStringType;
        this._smatch = smatch;
        this._regex = regex;
        this._stringLiteralPrefix = stringLiteralPrefix;
        this._toString = toString;
        this._encodingClass = encodingClass;
        this._encodingFunction = encodingFunction;
    }
    getType() {
        return this._stringType;
    }
    getConstType() {
        return this._constStringType;
    }
    getSMatch() {
        return this._smatch;
    }
    getRegex() {
        return this._regex;
    }
    createStringLiteral(inner) {
        return [this._stringLiteralPrefix, '"', inner, '"'];
    }
    wrapToString(inner) {
        return this._toString.wrap([], inner);
    }
}
class CPlusPlusRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = new Map();
        this.NarrowString = new (class extends BaseString {
            constructor() {
                super("std::string", "const std::string & ", "std::smatch", "std::regex", "", new WrappingCode(["std::to_string("], [")"]), "", "");
            }
            wrapEncodingChange(_qualifier, _fromType, _toType, inner) {
                return inner;
            }
            emitHelperFunctions() {
                return;
            }
        })();
        this.WideString = new (class extends BaseString {
            constructor(superThis) {
                super("std::wstring", "const std::wstring & ", "std::wsmatch", "std::wregex", "L", new WrappingCode(["std::to_wstring("], [")"]), "Utf16_Utf8", "convert");
                this.superThis = superThis;
            }
            wrapEncodingChange(qualifier, fromType, toType, inner) {
                if (this.superThis.sourcelikeToString(fromType) === this.superThis.sourcelikeToString(toType)) {
                    return inner;
                }
                return [
                    addQualifier(qualifier, [this._encodingClass]),
                    "<",
                    fromType,
                    ", ",
                    toType,
                    ">::",
                    this._encodingFunction,
                    "(",
                    inner,
                    ")"
                ];
            }
            emitHelperFunctions() {
                this.superThis.emitLine("template<typename T>");
                this.superThis.emitLine("struct tag {};");
                this.superThis.ensureBlankLine();
                this.superThis.emitLine("template<typename fromType, typename toType>");
                this.superThis.emitBlock(["class Utf16_Utf8"], true, () => {
                    this.superThis.emitLine("private:");
                    this.superThis.emitLine("template<typename TF, typename TT>");
                    this.superThis.emitBlock(["static toType convert(tag<std::shared_ptr<TF> >, tag<std::shared_ptr<TT> >, fromType ptr)"], false, () => {
                        this.superThis.emitLine("if (ptr == nullptr) return std::unique_ptr<TT>(); else return std::unique_ptr<TT>(new TT(Utf16_Utf8<TF,TT>::convert(*ptr)));");
                    });
                    this.superThis.ensureBlankLine();
                    this.superThis.emitLine("template<typename TF, typename TT>");
                    this.superThis.emitBlock(["static toType convert(tag<std::vector<TF> >, tag<std::vector<TT> >, fromType v)"], false, () => {
                        this.superThis.emitLine("auto it = v.begin();");
                        this.superThis.emitLine("auto newVector = std::vector<TT>();");
                        this.superThis.emitBlock(["while (it != v.end())"], false, () => {
                            this.superThis.emitLine("newVector.push_back(Utf16_Utf8<TF,TT>::convert(*it));");
                            this.superThis.emitLine("it++;");
                        });
                        this.superThis.emitLine("return newVector;");
                    });
                    this.superThis.ensureBlankLine();
                    this.superThis.emitLine("template<typename KF, typename VF, typename KT, typename VT>");
                    this.superThis.emitBlock(["static toType convert(tag<std::map<KF,VF> >, tag<std::map<KT,VT> >, fromType m)"], false, () => {
                        this.superThis.emitLine("auto it = m.begin();");
                        this.superThis.emitLine("auto newMap = std::map<KT, VT>();");
                        this.superThis.emitBlock(["while (it != m.end())"], false, () => {
                            this.superThis.emitLine("newMap.insert(std::pair<KT, VT>(Utf16_Utf8<KF, KT>::convert(it->first), Utf16_Utf8<VF, VT>::convert(it->second)));");
                            this.superThis.emitLine("it++;");
                        });
                        this.superThis.emitLine("return newMap;");
                    });
                    this.superThis.ensureBlankLine();
                    this.superThis.emitLine("template<typename TF, typename TT>");
                    this.superThis.emitBlock(["static fromType convert(tag<TF>, tag<TT>, fromType from)"], false, () => {
                        this.superThis.emitLine("return from;");
                    });
                    this.superThis.ensureBlankLine();
                    this.superThis.emitBlock(["static std::wstring convert(tag<std::string>, tag<std::wstring>, std::string str)"], false, () => {
                        this.superThis.emitLine("return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t, 0x10ffff, std::little_endian>, wchar_t>{}.from_bytes(str.data());");
                    });
                    this.superThis.ensureBlankLine();
                    this.superThis.emitBlock(["static std::string convert(tag<std::wstring>, tag<std::string>, std::wstring str)"], false, () => {
                        this.superThis.emitLine("return std::wstring_convert<std::codecvt_utf8_utf16<wchar_t, 0x10ffff, std::little_endian>, wchar_t>{}.to_bytes(str.data());");
                    });
                    this.superThis.ensureBlankLine();
                    this.superThis.emitLine("public:");
                    this.superThis.emitBlock(["static toType convert(fromType in)"], false, () => {
                        this.superThis.emitLine("return convert(tag<fromType>(), tag<toType>(), in);");
                    });
                });
                this.superThis.ensureBlankLine();
                this.superThis.emitLine("template<typename T>");
                this.superThis.emitBlock(["std::wstring wdump(const T& j)"], false, () => {
                    this.superThis.emitLine("std::ostringstream s;");
                    this.superThis.emitLine("s << j;");
                    this.superThis.emitLine("return ", this.superThis.ourQualifier(false), "Utf16_Utf8<std::string, std::wstring>::convert(s.str()); ");
                });
                this.superThis.ensureBlankLine();
            }
        })(this);
        this._enumType = _options.enumType;
        this._namespaceNames = _options.namespace.split("::");
        this.typeNamingStyle = _options.typeNamingStyle;
        this._namedTypeNameStyle = makeNameStyle(this.typeNamingStyle, legalizeName$j);
        this.enumeratorNamingStyle = _options.enumeratorNamingStyle;
        this._memberNameStyle = makeNameStyle(_options.memberNamingStyle, legalizeName$j);
        this._memberNamingFunction = funPrefixNamer("members", this._memberNameStyle);
        this._gettersAndSettersForPropertyName = new Map();
        this._allTypeNames = new Set();
        this._generatedFiles = new Set();
        this._generatedGlobalNames = new Map();
        this._generatedMemberNames = new Map();
        this._forbiddenGlobalNames = [];
        if (_options.wstring) {
            this._stringType = this.WideString;
        }
        else {
            this._stringType = this.NarrowString;
        }
        if (_options.boost) {
            this._optionalType = "boost::optional";
            this._optionalFactory = "boost::optional";
            this._nulloptType = "boost::none";
            this._variantType = "boost::variant";
            this._variantIndexMethodName = "which";
        }
        else {
            this._optionalType = "std::optional";
            this._optionalFactory = "std::make_optional";
            this._nulloptType = "std::nullopt";
            this._variantType = "std::variant";
            this._variantIndexMethodName = "index";
        }
        this.setupGlobalNames();
    }
    // union typeguard
    isUnion(t) {
        return t.kind === "union";
    }
    // Returns true if the type can be stored in
    // a stack based optional type. This requires
    // that the type does not require forward declaration.
    isOptionalAsValuePossible(t) {
        if (this.isForwardDeclaredType(t))
            return false;
        if (this.isUnion(t)) {
            // There is something stinky about this test.
            // There is special handling somewhere that if you
            // have the following schema
            // {
            //     "$schema": "http://json-schema.org/draft-06/schema#",
            //     "$ref": "#/definitions/List",
            //     "definitions": {
            //         "List": {
            //             "type": "object",
            //             "additionalProperties": false,
            //             "properties": {
            //                 "data": {
            //                     "type": "string"
            //                 },
            //                 "next": {
            //                     "anyOf": [
            //                         {
            //                             "$ref": "#/definitions/List"
            //                         }
            //                         {
            //                             "type": "null"
            //                         }
            //                     ]
            //                 }
            //             },
            //             "required": [],
            //             "title": "List"
            //         }
            //     }
            // }
            // Then a variant is not output but the single item inlined
            //
            //     struct TopLevel {
            //       std::optional<std::string> data;
            //       std::optional<TopLevel> next;
            //     };
            //
            // instead of
            //     struct TopLevel {
            //       std::optional<std::string> data;
            //       std::shared_ptr<TopLevel> next;
            //     };
            //
            // checking to see if the collapse of the variant has
            // occured and then doing the isCycleBreakerType check
            // on the single type the variant would contain seems
            // to solve the problem. But does this point to a problem
            // with the core library or with the CPlusPlus package
            const [, nonNulls] = removeNullFromUnion(t);
            if (nonNulls.size === 1) {
                const tt = defined(collectionUtils.iterableFirst(nonNulls));
                return !this.isCycleBreakerType(tt);
            }
        }
        return !this.isCycleBreakerType(t);
    }
    isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
    }
    // Is likely to return std::optional or boost::optional
    optionalTypeStack() {
        return this._optionalType;
    }
    // Is likely to return std::make_optional or boost::optional
    optionalFactoryStack() {
        return this._optionalFactory;
    }
    // Is likely to return std::shared_ptr
    optionalTypeHeap() {
        return optionalAsSharedType;
    }
    // Is likely to return std::make_shared
    optionalFactoryHeap() {
        return optionalFactoryAsSharedType;
    }
    // Returns the optional type most suitable for the given type.
    // Classes that don't require forward declarations can be stored
    // in std::optional ( or boost::optional )
    optionalType(t) {
        if (this.isOptionalAsValuePossible(t))
            return this.optionalTypeStack();
        else
            return this.optionalTypeHeap();
    }
    // Returns a label that can be used to distinguish between
    // heap and stack based optional handling methods
    optionalTypeLabel(t) {
        if (this.isOptionalAsValuePossible(t))
            return "stack";
        else
            return "heap";
    }
    getConstraintMembers() {
        return [
            {
                name: MemberNames.MinIntValue,
                getter: MemberNames.GetMinIntValue,
                setter: MemberNames.SetMinIntValue,
                cppType: "int64_t"
            },
            {
                name: MemberNames.MaxIntValue,
                getter: MemberNames.GetMaxIntValue,
                setter: MemberNames.SetMaxIntValue,
                cppType: "int64_t"
            },
            {
                name: MemberNames.MinDoubleValue,
                getter: MemberNames.GetMinDoubleValue,
                setter: MemberNames.SetMinDoubleValue,
                cppType: "double"
            },
            {
                name: MemberNames.MaxDoubleValue,
                getter: MemberNames.GetMaxDoubleValue,
                setter: MemberNames.SetMaxDoubleValue,
                cppType: "double"
            },
            {
                name: MemberNames.MinLength,
                getter: MemberNames.GetMinLength,
                setter: MemberNames.SetMinLength,
                cppType: "size_t"
            },
            {
                name: MemberNames.MaxLength,
                getter: MemberNames.GetMaxLength,
                setter: MemberNames.SetMaxLength,
                cppType: "size_t"
            },
            {
                name: MemberNames.Pattern,
                getter: MemberNames.GetPattern,
                setter: MemberNames.SetPattern,
                cppType: this._stringType.getType(),
                cppConstType: this._stringType.getConstType()
            }
        ];
    }
    lookupGlobalName(type) {
        return defined(this._generatedGlobalNames.get(type));
    }
    lookupMemberName(type) {
        return defined(this._generatedMemberNames.get(type));
    }
    addGlobalName(type) {
        const genName = this._namedTypeNameStyle(GlobalNames[type]);
        this._generatedGlobalNames.set(type, genName);
        this._forbiddenGlobalNames.push(genName);
    }
    addMemberName(type) {
        this._generatedMemberNames.set(type, this._memberNameStyle(MemberNames[type]));
    }
    setupGlobalNames() {
        for (const v of numberEnumValues(GlobalNames)) {
            this.addGlobalName(v);
        }
        for (const v of numberEnumValues(MemberNames)) {
            this.addMemberName(v);
        }
    }
    forbiddenNamesForGlobalNamespace() {
        return [...keywords$a, ...this._forbiddenGlobalNames];
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("types", this._namedTypeNameStyle);
    }
    namerForObjectProperty() {
        return this._memberNamingFunction;
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("enumerators", makeNameStyle(this.enumeratorNamingStyle, legalizeName$j));
    }
    makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new DependencyName(this._memberNamingFunction, name.order, lookup => `get_${lookup(name)}`);
        const mutableGetterName = new DependencyName(this._memberNamingFunction, name.order, lookup => `getMutable_${lookup(name)}`);
        const setterName = new DependencyName(this._memberNamingFunction, name.order, lookup => `set_${lookup(name)}`);
        return [getterName, mutableGetterName, setterName];
    }
    makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
    }
    withConst(s) {
        if (this._options.westConst) {
            return ["const ", s];
        }
        else {
            return [s, " const"];
        }
    }
    emitInclude(global, name) {
        this.emitLine("#include ", global ? "<" : '"', name, global ? ">" : '"');
    }
    startFile(basename, includeHelper = true) {
        assert(this._currentFilename === undefined, "Previous file wasn't finished");
        if (basename !== undefined) {
            this._currentFilename = this.sourcelikeToString(basename);
        }
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else if (!this._options.justTypes) {
            this.emitCommentLines([" To parse this JSON data, first install", ""]);
            if (this._options.boost) {
                this.emitCommentLines(["     Boost     http://www.boost.org"]);
            }
            this.emitCommentLines([
                "     json.hpp  https://github.com/nlohmann/json",
                "",
                " Then include this file, and then do",
                ""
            ]);
            if (this._options.typeSourceStyle) {
                this.forEachTopLevel("none", (_, topLevelName) => {
                    this.emitLine("//     ", topLevelName, " data = nlohmann::json::parse(jsonString);");
                });
            }
            else {
                this.emitLine("//     ", basename, " data = nlohmann::json::parse(jsonString);");
            }
            if (this._options.wstring) {
                this.emitLine("//");
                this.emitLine("//  You can get std::wstring data back out using");
                this.emitLine("//");
                this.forEachTopLevel("none", (_, topLevelName) => {
                    this.emitLine("//     std::wcout << ", "wdump((nlohmann::json) ", topLevelName, ");");
                });
            }
        }
        this.ensureBlankLine();
        this.emitLine("#pragma once");
        this.ensureBlankLine();
        if (this.haveOptionalProperties) {
            if (this._options.boost) {
                this.emitInclude(true, "boost/optional.hpp");
            }
            else {
                this.emitInclude(true, "optional");
            }
        }
        if (this.haveNamedUnions) {
            if (this._options.boost) {
                this.emitInclude(true, "boost/variant.hpp");
            }
            else {
                this.emitInclude(true, "variant");
            }
        }
        if (!this._options.justTypes) {
            if (!this._options.includeLocation) {
                this.emitInclude(true, "nlohmann/json.hpp");
            }
            else {
                this.emitInclude(false, "json.hpp");
            }
            if (includeHelper && !this._options.typeSourceStyle) {
                this.emitInclude(false, "helper.hpp");
            }
        }
        this.ensureBlankLine();
    }
    finishFile() {
        super.finishFile(defined(this._currentFilename));
        this._currentFilename = undefined;
    }
    get needsTypeDeclarationBeforeUse() {
        return true;
    }
    canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class";
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    emitBlock(line, withSemicolon, f, withIndent = true) {
        this.emitLine(line, " {");
        this.preventBlankLine();
        if (withIndent) {
            this.indent(f);
        }
        else {
            f();
        }
        this.preventBlankLine();
        if (withSemicolon) {
            this.emitLine("};");
        }
        else {
            this.emitLine("}");
        }
    }
    emitNamespaces(namespaceNames, f) {
        const namesArray = collectionUtils.toReadonlyArray(namespaceNames);
        const first = namesArray[0];
        if (first === undefined) {
            f();
        }
        else {
            this.emitBlock(["namespace ", first], false, () => this.emitNamespaces(namesArray.slice(1), f), namesArray.length === 1);
        }
    }
    cppTypeInOptional(nonNulls, ctx, withIssues, forceNarrowString) {
        if (nonNulls.size === 1) {
            return this.cppType(defined(collectionUtils.iterableFirst(nonNulls)), ctx, withIssues, forceNarrowString, false);
        }
        const typeList = [];
        for (const t of nonNulls) {
            if (typeList.length !== 0) {
                typeList.push(", ");
            }
            typeList.push(this.cppType(t, {
                needsForwardIndirection: true,
                needsOptionalIndirection: false,
                inJsonNamespace: ctx.inJsonNamespace
            }, withIssues, false, false));
        }
        return [this._variantType, "<", typeList, ">"];
    }
    variantType(u, inJsonNamespace) {
        const [maybeNull, nonNulls] = removeNullFromUnion(u, true);
        assert(nonNulls.size >= 2, "Variant not needed for less than two types.");
        const indirection = maybeNull !== null;
        const variant = this.cppTypeInOptional(nonNulls, {
            needsForwardIndirection: !indirection,
            needsOptionalIndirection: !indirection,
            inJsonNamespace
        }, true, false);
        if (!indirection) {
            return variant;
        }
        return [this.optionalType(u), "<", variant, ">"];
    }
    ourQualifier(inJsonNamespace) {
        return inJsonNamespace ? [collectionUtils.arrayIntercalate("::", this._namespaceNames), "::"] : [];
    }
    jsonQualifier(inJsonNamespace) {
        return inJsonNamespace ? [] : "nlohmann::";
    }
    variantIndirection(type, needIndirection, typeSrc) {
        if (!needIndirection)
            return typeSrc;
        return [this.optionalType(type), "<", typeSrc, ">"];
    }
    cppType(t, ctx, withIssues, forceNarrowString, isOptional) {
        const inJsonNamespace = ctx.inJsonNamespace;
        if (isOptional && t instanceof UnionType) {
            // avoid have optionalType<optionalType<Type>>
            for (const tChild of t.getChildren()) {
                if (tChild.isNullable) {
                    isOptional = false;
                    break;
                }
            }
        }
        const typeSource = matchType(t, _anyType => {
            isOptional = false;
            return maybeAnnotated(withIssues, anyTypeIssueAnnotation, [
                this.jsonQualifier(inJsonNamespace),
                "json"
            ]);
        }, _nullType => {
            isOptional = false;
            return maybeAnnotated(withIssues, nullTypeIssueAnnotation, [
                this.jsonQualifier(inJsonNamespace),
                "json"
            ]);
        }, _boolType => "bool", _integerType => "int64_t", _doubleType => "double", _stringType => {
            if (forceNarrowString) {
                return "std::string";
            }
            else {
                return this._stringType.getType();
            }
        }, arrayType => [
            "std::vector<",
            this.cppType(arrayType.items, {
                needsForwardIndirection: false,
                needsOptionalIndirection: true,
                inJsonNamespace
            }, withIssues, forceNarrowString, false),
            ">"
        ], classType => this.variantIndirection(classType, ctx.needsForwardIndirection && this.isForwardDeclaredType(classType) && !isOptional, [this.ourQualifier(inJsonNamespace), this.nameForNamedType(classType)]), mapType => {
            let keyType = this._stringType.getType();
            if (forceNarrowString) {
                keyType = "std::string";
            }
            return [
                "std::map<",
                keyType,
                ", ",
                this.cppType(mapType.values, {
                    needsForwardIndirection: false,
                    needsOptionalIndirection: true,
                    inJsonNamespace
                }, withIssues, forceNarrowString, false),
                ">"
            ];
        }, enumType => [this.ourQualifier(inJsonNamespace), this.nameForNamedType(enumType)], unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                isOptional = true;
                return this.cppType(nullable, {
                    needsForwardIndirection: false,
                    needsOptionalIndirection: false,
                    inJsonNamespace
                }, withIssues, forceNarrowString, false);
            }
            else {
                return [this.ourQualifier(inJsonNamespace), this.nameForNamedType(unionType)];
            }
        });
        if (!isOptional)
            return typeSource;
        return [this.optionalType(t), "<", typeSource, ">"];
    }
    /**
     * similar to cppType, it practically gathers all the generated types within
     * 't'. It also records, whether a given sub-type is part of a variant or not.
     */
    generatedTypes(isClassMember, theType) {
        const result = [];
        const recur = (forceInclude, isVariant, l, t) => {
            if (t instanceof ArrayType) {
                recur(true, isVariant, l + 1, t.items);
            }
            else if (t instanceof ClassType) {
                result.push({
                    name: this.nameForNamedType(t),
                    type: t,
                    level: l,
                    variant: isVariant,
                    forceInclude
                });
            }
            else if (t instanceof MapType) {
                recur(true, isVariant, l + 1, t.values);
            }
            else if (t instanceof EnumType) {
                result.push({
                    name: this.nameForNamedType(t),
                    type: t,
                    level: l,
                    variant: isVariant,
                    forceInclude: false
                });
            }
            else if (t instanceof UnionType) {
                /**
                 * If we have a union as a class member and we see it as a "named union",
                 * we can safely include it as-is.
                 * HOWEVER if we define a union on its own, we must recurse into the
                 * typedefinition and include all subtypes.
                 */
                if (this.unionNeedsName(t) && isClassMember) {
                    /**
                     * This is NOT ENOUGH.
                     * We have a variant member in a class, e.g. defined with a boost::variant.
                     * The compiler can only compile the class if IT KNOWS THE SIZES
                     * OF ALL MEMBERS OF THE VARIANT.
                     * So it means that you must include ALL SUBTYPES (practically classes only)
                     * AS WELL
                     */
                    forceInclude = true;
                    result.push({
                        name: this.nameForNamedType(t),
                        type: t,
                        level: l,
                        variant: true,
                        forceInclude
                    });
                    /** intentional "fall-through", add all subtypes as well - but forced include */
                }
                const [hasNull, nonNulls] = removeNullFromUnion(t);
                isVariant = hasNull !== null;
                /** we need to collect all the subtypes of the union */
                for (const tt of nonNulls) {
                    recur(forceInclude, isVariant, l + 1, tt);
                }
            }
        };
        recur(false, false, 0, theType);
        return result;
    }
    constraintMember(jsonName) {
        return this._memberNameStyle(`${jsonName}Constraint`);
    }
    emitMember(cppType, name) {
        this.emitLine(cppType, " ", name, ";");
    }
    emitClassMembers(c, constraints) {
        if (this._options.codeFormat) {
            this.emitLine("private:");
            this.forEachClassProperty(c, "none", (name, jsonName, property) => {
                this.emitMember(this.cppType(property.type, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, true, false, property.isOptional), name);
                if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                    /** FIXME!!! NameStyle will/can collide with other Names */
                    const cnst = this.lookupGlobalName(GlobalNames.ClassMemberConstraints);
                    this.emitMember(cnst, this.constraintMember(jsonName));
                }
            });
            this.ensureBlankLine();
            this.emitLine("public:");
        }
        this.forEachClassProperty(c, "none", (name, jsonName, property) => {
            this.emitDescription(this.descriptionForClassProperty(c, jsonName));
            if (!this._options.codeFormat) {
                this.emitMember(this.cppType(property.type, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, true, false, property.isOptional), name);
            }
            else {
                const [getterName, mutableGetterName, setterName] = defined(this._gettersAndSettersForPropertyName.get(name));
                const rendered = this.cppType(property.type, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, true, false, property.isOptional);
                /**
                 * fix for optional type -> e.g. unique_ptrs can't be copied
                 * One might as why the "this->xxx = value". Simple if we have
                 * a member called 'value' value = value will screw up the compiler
                 */
                const checkConst = this.lookupGlobalName(GlobalNames.CheckConstraint);
                if ((property.type instanceof UnionType && property.type.findMember("null") !== undefined) ||
                    (property.isOptional && property.type.kind !== "null" && property.type.kind !== "any")) {
                    this.emitLine(rendered, " ", getterName, "() const { return ", name, "; }");
                    if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                        this.emitLine("void ", setterName, "(", rendered, " value) { if (value) ", checkConst, "(", this._stringType.createStringLiteral([name]), ", ", this.constraintMember(jsonName), ", *value); this->", name, " = value; }");
                    }
                    else {
                        this.emitLine("void ", setterName, "(", rendered, " value) { this->", name, " = value; }");
                    }
                }
                else {
                    this.emitLine(this.withConst(rendered), " & ", getterName, "() const { return ", name, "; }");
                    this.emitLine(rendered, " & ", mutableGetterName, "() { return ", name, "; }");
                    if (constraints === null || constraints === void 0 ? void 0 : constraints.has(jsonName)) {
                        this.emitLine("void ", setterName, "(", this.withConst(rendered), " & value) { ", checkConst, "(", this._stringType.createStringLiteral([name]), ", ", this.constraintMember(jsonName), ", value); this->", name, " = value; }");
                    }
                    else {
                        this.emitLine("void ", setterName, "(", this.withConst(rendered), " & value) { this->", name, " = value; }");
                    }
                }
                this.ensureBlankLine();
            }
        });
    }
    generateClassConstraints(c) {
        const res = new Map();
        this.forEachClassProperty(c, "none", (_name, jsonName, property) => {
            const constraints = constraintsForType(property.type);
            if (constraints === undefined)
                return;
            const { minMax, minMaxLength, pattern } = constraints;
            // TODO is there a better way to check if property.type is an interger or a number?
            const cppType = this.cppType(property.type, {
                needsForwardIndirection: true,
                needsOptionalIndirection: true,
                inJsonNamespace: false
            }, true, false, property.isOptional);
            res.set(jsonName, [
                this.constraintMember(jsonName),
                "(",
                (minMax === null || minMax === void 0 ? void 0 : minMax[0]) && cppType === "int64_t" ? String(minMax[0]) : this._nulloptType,
                ", ",
                (minMax === null || minMax === void 0 ? void 0 : minMax[1]) && cppType === "int64_t" ? String(minMax[1]) : this._nulloptType,
                ", ",
                (minMax === null || minMax === void 0 ? void 0 : minMax[0]) && cppType === "double" ? String(minMax[0]) : this._nulloptType,
                ", ",
                (minMax === null || minMax === void 0 ? void 0 : minMax[1]) && cppType === "double" ? String(minMax[1]) : this._nulloptType,
                ", ",
                (minMaxLength === null || minMaxLength === void 0 ? void 0 : minMaxLength[0]) ? String(minMaxLength[0]) : this._nulloptType,
                ", ",
                (minMaxLength === null || minMaxLength === void 0 ? void 0 : minMaxLength[1]) ? String(minMaxLength[1]) : this._nulloptType,
                ", ",
                pattern === undefined
                    ? this._nulloptType
                    : [
                        this._stringType.getType(),
                        "(",
                        this._stringType.createStringLiteral([stringEscape$7(pattern)]),
                        ")"
                    ],
                ")"
            ]);
        });
        return res.size === 0 ? undefined : res;
    }
    emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock([this._options.codeFormat ? "class " : "struct ", className], true, () => {
            const constraints = this.generateClassConstraints(c);
            if (this._options.codeFormat) {
                this.emitLine("public:");
                if (constraints === undefined) {
                    this.emitLine(className, "() = default;");
                }
                else {
                    this.emitLine(className, "() :");
                    let numEmits = 0;
                    constraints.forEach((initializer, _propName) => {
                        numEmits++;
                        this.indent(() => {
                            if (numEmits === constraints.size) {
                                this.emitLine(initializer);
                            }
                            else {
                                this.emitLine(initializer, ",");
                            }
                        });
                    });
                    this.emitLine("{}");
                }
                this.emitLine("virtual ~", className, "() = default;");
                this.ensureBlankLine();
            }
            this.emitClassMembers(c, constraints);
        });
    }
    emitTopLevelHeaders(t, className) {
        // Forward declarations for std::map<std::wstring, Key> (need to convert UTF16 <-> UTF8)
        if (t instanceof MapType && this._stringType !== this.NarrowString) {
            const ourQualifier = this.ourQualifier(true);
            this.emitBlock(["struct adl_serializer<", ourQualifier, className, ">"], true, () => {
                this.emitLine("template <>");
                this.emitLine("static void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, " & x);");
                this.emitLine("static void to_json(json & j, ", this.withConst([ourQualifier, className]), " & x);");
            });
        }
    }
    emitClassHeaders(className) {
        const ourQualifier = this.ourQualifier(false);
        this.emitLine("void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, " & x);");
        this.emitLine("void to_json(json & j, ", this.withConst([ourQualifier, className]), " & x);");
    }
    emitTopLevelFunction(t, className) {
        // Function definitions for std::map<std::wstring, Key> (need to convert UTF16 <-> UTF8)
        if (t instanceof MapType && this._stringType !== this.NarrowString) {
            const ourQualifier = this.ourQualifier(true);
            let cppType;
            let toType;
            this.emitBlock([
                "inline void adl_serializer<",
                ourQualifier,
                className,
                ">::from_json(",
                this.withConst("json"),
                " & j, ",
                ourQualifier,
                className,
                "& x)"
            ], false, () => {
                cppType = this.cppType(t, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: true
                }, false, true, false);
                toType = this.cppType(t, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: true
                }, false, false, false);
                this.emitLine([
                    "x = ",
                    this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                        "j.get<",
                        cppType,
                        ">()"
                    ]),
                    ";"
                ]);
            });
            this.emitBlock([
                "inline void adl_serializer<",
                ourQualifier,
                className,
                ">::to_json(json & j, ",
                this.withConst([ourQualifier, className]),
                " & x)"
            ], false, () => {
                cppType = this.cppType(t, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: true
                }, false, false, false);
                toType = this.cppType(t, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: true
                }, false, true, false);
                this.emitLine([
                    "j = ",
                    this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, "x"),
                    ";"
                ]);
            });
        }
    }
    emitClassFunctions(c, className) {
        const ourQualifier = this.ourQualifier(false);
        let cppType;
        let toType;
        this.emitBlock(["inline void from_json(", this.withConst("json"), " & j, ", ourQualifier, className, "& x)"], false, () => {
            this.forEachClassProperty(c, "none", (name, json, p) => {
                const [, , setterName] = defined(this._gettersAndSettersForPropertyName.get(name));
                const propType = p.type;
                let assignment;
                if (this._options.codeFormat) {
                    assignment = new WrappingCode(["x.", setterName, "("], [")"]);
                }
                else {
                    assignment = new WrappingCode(["x.", name, " = "], []);
                }
                if (propType.kind === "null" || propType.kind === "any") {
                    this.emitLine(assignment.wrap([], [
                        ourQualifier,
                        "get_untyped(j, ",
                        this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([stringEscape$7(json)])]),
                        ")"
                    ]), ";");
                    return;
                }
                if (p.isOptional || propType instanceof UnionType) {
                    const [nullOrOptional, typeSet] = (function () {
                        if (propType instanceof UnionType) {
                            const [maybeNull, nonNulls] = removeNullFromUnion(propType, true);
                            return [maybeNull !== null || p.isOptional, nonNulls];
                        }
                        else {
                            const set = new Set();
                            set.add(propType);
                            return [true, set];
                        }
                    })();
                    if (nullOrOptional) {
                        cppType = this.cppTypeInOptional(typeSet, {
                            needsForwardIndirection: false,
                            needsOptionalIndirection: false,
                            inJsonNamespace: false
                        }, false, true);
                        toType = this.cppTypeInOptional(typeSet, {
                            needsForwardIndirection: false,
                            needsOptionalIndirection: false,
                            inJsonNamespace: false
                        }, false, false);
                        this.emitLine(assignment.wrap([], [
                            this._stringType.wrapEncodingChange([ourQualifier], [this.optionalType(propType), "<", cppType, ">"], [this.optionalType(propType), "<", toType, ">"], [
                                ourQualifier,
                                `get_${this.optionalTypeLabel(propType)}_optional<`,
                                cppType,
                                ">(j, ",
                                this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([stringEscape$7(json)])]),
                                ")"
                            ])
                        ]), ";");
                        return;
                    }
                }
                cppType = this.cppType(propType, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, false, true, p.isOptional);
                toType = this.cppType(propType, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, false, false, p.isOptional);
                this.emitLine(assignment.wrap([], this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                    "j.at(",
                    this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), this._stringType.createStringLiteral([stringEscape$7(json)])),
                    ").get<",
                    cppType,
                    ">()"
                ])), ";");
            });
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json & j, ", this.withConst([ourQualifier, className]), " & x)"], false, () => {
            this.emitLine("j = json::object();");
            this.forEachClassProperty(c, "none", (name, json, p) => {
                const propType = p.type;
                cppType = this.cppType(propType, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, false, false, p.isOptional);
                toType = this.cppType(propType, {
                    needsForwardIndirection: true,
                    needsOptionalIndirection: true,
                    inJsonNamespace: false
                }, false, true, p.isOptional);
                const [getterName, ,] = defined(this._gettersAndSettersForPropertyName.get(name));
                let getter;
                if (this._options.codeFormat) {
                    getter = [getterName, "()"];
                }
                else {
                    getter = [name];
                }
                const assignment = [
                    "j[",
                    this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), this._stringType.createStringLiteral([stringEscape$7(json)])),
                    "] = ",
                    this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, ["x.", getter]),
                    ";"
                ];
                if (p.isOptional && this._options.hideNullOptional) {
                    this.emitBlock([
                        "if (",
                        this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, ["x.", getter]),
                        ")"
                    ], false, () => {
                        this.emitLine(assignment);
                    });
                }
                else {
                    this.emitLine(assignment);
                }
            });
        });
    }
    emitEnum(e, enumName) {
        const caseNames = [];
        const enumValues = enumCaseValues(e, this.targetLanguage.name);
        this.forEachEnumCase(e, "none", (name, jsonName) => {
            if (caseNames.length > 0)
                caseNames.push(", ");
            caseNames.push(name);
            if (enumValues !== undefined) {
                const [enumValue] = getAccessorName(enumValues, jsonName);
                if (enumValue !== undefined) {
                    caseNames.push(" = ", enumValue.toString());
                }
            }
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum class ", enumName, " : ", this._enumType, " { ", caseNames, " };");
    }
    emitUnionTypedefs(u, unionName) {
        this.emitLine("using ", unionName, " = ", this.variantType(u, false), ";");
    }
    emitUnionHeaders(u) {
        // Forward declarations for boost::variant<Ts...>. If none of the Ts were defined by us (e.g. if we have
        // boost::variant<int32_t, std::string>) then we need to specialize nlohmann::adl_serializer for our
        // variant type. If at least one of the Ts is our type then we could get away with regular adl definitions,
        // but it's nontrivial to detect that (consider variant<string, variant<map<string, string>, int>> which
        // does need an adl_serializer specialization) so we'll just specialize every time.
        const nonNulls = removeNullFromUnion(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, {
            needsForwardIndirection: false,
            needsOptionalIndirection: false,
            inJsonNamespace: true
        }, false, false);
        this.emitLine("template <>");
        this.emitBlock(["struct adl_serializer<", variantType, ">"], true, () => {
            this.emitLine("static void from_json(", this.withConst("json"), " & j, ", variantType, " & x);");
            this.emitLine("static void to_json(json & j, ", this.withConst(variantType), " & x);");
        });
    }
    emitUnionFunctions(u) {
        // Function definitions for boost::variant<Ts...>.
        const ourQualifier = this.ourQualifier(true);
        const functionForKind = [
            ["bool", "is_boolean"],
            ["integer", "is_number_integer"],
            ["double", "is_number"],
            ["string", "is_string"],
            ["class", "is_object"],
            ["map", "is_object"],
            ["array", "is_array"],
            ["enum", "is_string"]
        ];
        const nonNulls = removeNullFromUnion(u, true)[1];
        const variantType = this.cppTypeInOptional(nonNulls, {
            needsForwardIndirection: false,
            needsOptionalIndirection: false,
            inJsonNamespace: true
        }, false, false);
        this.emitBlock([
            "inline void adl_serializer<",
            variantType,
            ">::from_json(",
            this.withConst("json"),
            " & j, ",
            variantType,
            " & x)"
        ], false, () => {
            let onFirst = true;
            for (const [kind, func] of functionForKind) {
                const typeForKind = collectionUtils.iterableFind(nonNulls, t => t.kind === kind);
                if (typeForKind === undefined)
                    continue;
                this.emitLine(onFirst ? "if" : "else if", " (j.", func, "())");
                this.indent(() => {
                    const cppType = this.cppType(typeForKind, {
                        needsForwardIndirection: true,
                        needsOptionalIndirection: true,
                        inJsonNamespace: true
                    }, false, true, false);
                    const toType = this.cppType(typeForKind, {
                        needsForwardIndirection: true,
                        needsOptionalIndirection: true,
                        inJsonNamespace: true
                    }, false, false, false);
                    this.emitLine("x = ", this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                        "j.get<",
                        cppType,
                        ">()"
                    ]), ";");
                });
                onFirst = false;
            }
            this.emitLine('else throw std::runtime_error("Could not deserialise!");');
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void adl_serializer<", variantType, ">::to_json(json & j, ", this.withConst(variantType), " & x)"], false, () => {
            this.emitBlock(["switch (x.", this._variantIndexMethodName, "())"], false, () => {
                let i = 0;
                for (const t of nonNulls) {
                    this.emitLine("case ", i.toString(), ":");
                    this.indent(() => {
                        const cppType = this.cppType(t, {
                            needsForwardIndirection: true,
                            needsOptionalIndirection: true,
                            inJsonNamespace: true
                        }, false, false, false);
                        const toType = this.cppType(t, {
                            needsForwardIndirection: true,
                            needsOptionalIndirection: true,
                            inJsonNamespace: true
                        }, false, true, false);
                        this.emitLine("j = ", this._stringType.wrapEncodingChange([ourQualifier], cppType, toType, [
                            this._options.boost ? "boost::get<" : "std::get<",
                            cppType,
                            ">(x)"
                        ]), ";");
                        this.emitLine("break;");
                    });
                    i++;
                }
                this.emitLine('default: throw std::runtime_error("Input JSON does not conform to schema!");');
            });
        });
    }
    emitEnumHeaders(enumName) {
        const ourQualifier = this.ourQualifier(false);
        this.emitLine("void from_json(", this.withConst("json"), " & j, ", ourQualifier, enumName, " & x);");
        this.emitLine("void to_json(json & j, ", this.withConst([ourQualifier, enumName]), " & x);");
    }
    isLargeEnum(e) {
        // This is just an estimation. Someone might want to do some
        // benchmarks to find the optimum value here
        return e.cases.size > 15;
    }
    emitEnumFunctions(e, enumName) {
        const ourQualifier = this.ourQualifier(false);
        this.emitBlock(["inline void from_json(", this.withConst("json"), " & j, ", ourQualifier, enumName, " & x)"], false, () => {
            if (this.isLargeEnum(e)) {
                this.emitBlock([
                    "static std::unordered_map<",
                    this._stringType.getType(),
                    ", ",
                    ourQualifier,
                    enumName,
                    "> enumValues"
                ], true, () => {
                    this.forEachEnumCase(e, "none", (name, jsonName) => {
                        this.emitLine("{", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([stringEscape$7(jsonName)])]), ", ", ourQualifier, enumName, "::", name, "},");
                    });
                });
                this.emitLine(`auto iter = enumValues.find(j.get<${this._stringType.getType()}>());`);
                this.emitBlock("if (iter != enumValues.end())", false, () => {
                    this.emitLine("x = iter->second;");
                });
            }
            else {
                let onFirst = true;
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    const maybeElse = onFirst ? "" : "else ";
                    this.emitLine(maybeElse, "if (j == ", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([stringEscape$7(jsonName)])]), ") x = ", ourQualifier, enumName, "::", name, ";");
                    onFirst = false;
                });
                this.emitLine('else { throw std::runtime_error("Input JSON does not conform to schema!"); }');
            }
        });
        this.ensureBlankLine();
        this.emitBlock(["inline void to_json(json & j, ", this.withConst([ourQualifier, enumName]), " & x)"], false, () => {
            this.emitBlock("switch (x)", false, () => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    this.emitLine("case ", ourQualifier, enumName, "::", name, ": j = ", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), [this._stringType.createStringLiteral([stringEscape$7(jsonName)])]), "; break;");
                });
                this.emitLine(`default: throw std::runtime_error("Unexpected value in enumeration \\"${enumName}\\": " + std::to_string(static_cast<int>(x)));`);
            });
        });
    }
    emitTopLevelTypedef(t, name) {
        this.emitLine("using ", name, " = ", this.cppType(t, {
            needsForwardIndirection: true,
            needsOptionalIndirection: true,
            inJsonNamespace: false
        }, true, false, false), ";");
    }
    emitAllUnionFunctions() {
        this.forEachUniqueUnion("leading-and-interposing", u => this.sourcelikeToString(this.cppTypeInOptional(removeNullFromUnion(u, true)[1], {
            needsForwardIndirection: false,
            needsOptionalIndirection: false,
            inJsonNamespace: true
        }, false, false)), (u) => this.emitUnionFunctions(u));
    }
    emitAllUnionHeaders() {
        this.forEachUniqueUnion("interposing", u => this.sourcelikeToString(this.cppTypeInOptional(removeNullFromUnion(u, true)[1], {
            needsForwardIndirection: false,
            needsOptionalIndirection: false,
            inJsonNamespace: true
        }, false, false)), (u) => this.emitUnionHeaders(u));
    }
    emitOptionalHelpers() {
        this.emitLine("#ifndef NLOHMANN_OPT_HELPER");
        this.emitLine("#define NLOHMANN_OPT_HELPER");
        this.emitNamespaces(["nlohmann"], () => {
            const emitAdlStruct = (optType, factory) => {
                this.emitLine("template <typename T>");
                this.emitBlock(["struct adl_serializer<", optType, "<T>>"], true, () => {
                    this.emitBlock(["static void to_json(json & j, ", this.withConst([optType, "<T>"]), " & opt)"], false, () => {
                        this.emitLine("if (!opt) j = nullptr; else j = *opt;");
                    });
                    this.ensureBlankLine();
                    this.emitBlock(["static ", optType, "<T> from_json(", this.withConst("json"), " & j)"], false, () => {
                        this.emitLine(`if (j.is_null()) return ${factory}<T>(); else return ${factory}<T>(j.get<T>());`);
                    });
                });
            };
            emitAdlStruct(this.optionalTypeHeap(), this.optionalFactoryHeap());
            emitAdlStruct(this.optionalTypeStack(), this.optionalFactoryStack());
        });
        this.emitLine("#endif");
    }
    emitDeclaration(decl) {
        if (decl.kind === "forward") {
            if (this._options.codeFormat) {
                this.emitLine("class ", this.nameForNamedType(decl.type), ";");
            }
            else {
                this.emitLine("struct ", this.nameForNamedType(decl.type), ";");
            }
        }
        else if (decl.kind === "define") {
            const type = decl.type;
            const name = this.nameForNamedType(type);
            if (type instanceof ClassType) {
                this.emitClass(type, name);
            }
            else if (type instanceof EnumType) {
                this.emitEnum(type, name);
            }
            else if (type instanceof UnionType) {
                this.emitUnionTypedefs(type, name);
            }
            else {
                panic(`Cannot declare type ${type.kind}`);
            }
        }
        else {
            assertNever(decl.kind);
        }
    }
    emitGetterSetter(t, getterName, setterName, memberName) {
        this.emitLine("void ", setterName, "(", t, " ", memberName, ") { this->", memberName, " = ", memberName, "; }");
        this.emitLine("auto ", getterName, "() const { return ", memberName, "; }");
    }
    emitNumericCheckConstraints(checkConst, classConstraint, getterMinValue, getterMaxValue, cppType) {
        this.emitBlock([
            "inline void ",
            checkConst,
            "(",
            this._stringType.getConstType(),
            " name, ",
            this.withConst(classConstraint),
            " & c, ",
            cppType,
            " value)"
        ], false, () => {
            this.emitBlock(["if (c.", getterMinValue, "() != ", this._nulloptType, " && value < *c.", getterMinValue, "())"], false, () => {
                this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooLowException), " (", this._stringType.createStringLiteral(["Value too low for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value"]), " + ", this._stringType.createStringLiteral(["<"]), " + ", this._stringType.wrapToString(["*c.", getterMinValue, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
            });
            this.ensureBlankLine();
            this.emitBlock(["if (c.", getterMaxValue, "() != ", this._nulloptType, " && value > *c.", getterMaxValue, "())"], false, () => {
                this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooHighException), " (", this._stringType.createStringLiteral(["Value too high for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value"]), " + ", this._stringType.createStringLiteral([">"]), " + ", this._stringType.wrapToString(["*c.", getterMaxValue, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
            });
            this.ensureBlankLine();
        });
        this.ensureBlankLine();
    }
    emitConstraintClasses() {
        const ourQualifier = this.ourQualifier(false);
        const getterMinIntValue = this.lookupMemberName(MemberNames.GetMinIntValue);
        const getterMaxIntValue = this.lookupMemberName(MemberNames.GetMaxIntValue);
        const getterMinDoubleValue = this.lookupMemberName(MemberNames.GetMinDoubleValue);
        const getterMaxDoubleValue = this.lookupMemberName(MemberNames.GetMaxDoubleValue);
        const getterMinLength = this.lookupMemberName(MemberNames.GetMinLength);
        const getterMaxLength = this.lookupMemberName(MemberNames.GetMaxLength);
        const getterPattern = this.lookupMemberName(MemberNames.GetPattern);
        const classConstraint = this.lookupGlobalName(GlobalNames.ClassMemberConstraints);
        this.emitBlock(["class ", classConstraint], true, () => {
            this.emitLine("private:");
            const constraintMembers = this.getConstraintMembers();
            for (const member of constraintMembers) {
                this.emitMember([this._optionalType, "<", member.cppType, ">"], this.lookupMemberName(member.name));
            }
            this.ensureBlankLine();
            this.emitLine("public:");
            this.emitLine(classConstraint, "(");
            this.indent(() => {
                this.iterableForEach(constraintMembers, ({ name, cppType }, pos) => {
                    const comma = pos === "first" || pos === "middle" ? "," : [];
                    this.emitLine(this._optionalType, "<", cppType, "> ", this.lookupMemberName(name), comma);
                });
            });
            const args = constraintMembers.map(({ name }) => {
                const member = this.lookupMemberName(name);
                return [member, "(", member, ")"];
            });
            this.emitLine(") : ", collectionUtils.arrayIntercalate([", "], args), " {}");
            this.emitLine(classConstraint, "() = default;");
            this.emitLine("virtual ~", classConstraint, "() = default;");
            for (const member of constraintMembers) {
                this.ensureBlankLine();
                this.emitGetterSetter(collectionUtils.withDefault(member.cppConstType, member.cppType), this.lookupMemberName(member.getter), this.lookupMemberName(member.setter), this.lookupMemberName(member.name));
            }
        });
        this.ensureBlankLine();
        const classConstEx = this.lookupGlobalName(GlobalNames.ClassMemberConstraintException);
        this.emitBlock(["class ", classConstEx, " : public std::runtime_error"], true, () => {
            this.emitLine("public:");
            this.emitLine(classConstEx, "(", this._stringType.getConstType(), " msg) : std::runtime_error(", this._stringType.wrapEncodingChange([ourQualifier], this._stringType.getType(), this.NarrowString.getType(), ["msg"]), ") {}");
        });
        this.ensureBlankLine();
        const exceptions = [
            GlobalNames.ValueTooLowException,
            GlobalNames.ValueTooHighException,
            GlobalNames.ValueTooShortException,
            GlobalNames.ValueTooLongException,
            GlobalNames.InvalidPatternException
        ];
        for (const ex of exceptions) {
            const name = this.lookupGlobalName(ex);
            this.emitBlock(["class ", name, " : public ", classConstEx], true, () => {
                this.emitLine("public:");
                this.emitLine(name, "(", this._stringType.getConstType(), " msg) : ", classConstEx, "(msg) {}");
            });
            this.ensureBlankLine();
        }
        const checkConst = this.lookupGlobalName(GlobalNames.CheckConstraint);
        this.emitNumericCheckConstraints(checkConst, classConstraint, getterMinIntValue, getterMaxIntValue, "int64_t");
        this.emitNumericCheckConstraints(checkConst, classConstraint, getterMinDoubleValue, getterMaxDoubleValue, "double");
        this.emitBlock([
            "inline void ",
            checkConst,
            "(",
            this._stringType.getConstType(),
            " name, ",
            this.withConst(classConstraint),
            " & c, ",
            this._stringType.getConstType(),
            " value)"
        ], false, () => {
            this.emitBlock([
                "if (c.",
                getterMinLength,
                "() != ",
                this._nulloptType,
                " && value.length() < *c.",
                getterMinLength,
                "())"
            ], false, () => {
                this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooShortException), " (", this._stringType.createStringLiteral(["Value too short for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value.length()"]), " + ", this._stringType.createStringLiteral(["<"]), " + ", this._stringType.wrapToString(["*c.", getterMinLength, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
            });
            this.ensureBlankLine();
            this.emitBlock([
                "if (c.",
                getterMaxLength,
                "() != ",
                this._nulloptType,
                " && value.length() > *c.",
                getterMaxLength,
                "())"
            ], false, () => {
                this.emitLine("throw ", this.lookupGlobalName(GlobalNames.ValueTooLongException), " (", this._stringType.createStringLiteral(["Value too long for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + ", this._stringType.wrapToString(["value.length()"]), " + ", this._stringType.createStringLiteral([">"]), " + ", this._stringType.wrapToString(["*c.", getterMaxLength, "()"]), " + ", this._stringType.createStringLiteral([")"]), ");");
            });
            this.ensureBlankLine();
            this.emitBlock(["if (c.", getterPattern, "() != ", this._nulloptType, ")"], false, () => {
                this.emitLine(this._stringType.getSMatch(), " result;");
                this.emitLine("std::regex_search(value, result, ", this._stringType.getRegex(), "( *c.", getterPattern, "() ));");
                this.emitBlock(["if (result.empty())"], false, () => {
                    this.emitLine("throw ", this.lookupGlobalName(GlobalNames.InvalidPatternException), " (", this._stringType.createStringLiteral(["Value doesn't match pattern for "]), " + name + ", this._stringType.createStringLiteral([" ("]), " + value +", this._stringType.createStringLiteral([" != "]), " + *c.", getterPattern, "() + ", this._stringType.createStringLiteral([")"]), ");");
                });
            });
            this.ensureBlankLine();
        });
    }
    emitHelperFunctions() {
        this._stringType.emitHelperFunctions();
        if (this._options.codeFormat &&
            collectionUtils.iterableSome(this.typeGraph.allTypesUnordered(), t => constraintsForType(t) !== undefined)) {
            this.emitConstraintClasses();
            this.ensureBlankLine();
        }
        this.ensureBlankLine();
        let untypedMacroName = "NLOHMANN_UNTYPED_";
        let optionalMacroName = "NLOHMANN_OPTIONAL_";
        this._namespaceNames.forEach(value => {
            // We can't use upper name, because namespaces are case sensitive
            untypedMacroName += value;
            untypedMacroName += "_";
            optionalMacroName += value;
            optionalMacroName += "_";
        });
        untypedMacroName += "HELPER";
        optionalMacroName += "HELPER";
        this.emitLine(`#ifndef ${untypedMacroName}`);
        this.emitLine(`#define ${untypedMacroName}`);
        this.emitBlock(["inline json get_untyped(", this.withConst("json"), " & j, ", this.withConst("char"), " * property)"], false, () => {
            this.emitBlock(["if (j.find(property) != j.end())"], false, () => {
                this.emitLine("return j.at(property).get<json>();");
            });
            this.emitLine("return json();");
        });
        this.ensureBlankLine();
        this.emitBlock(["inline json get_untyped(", this.withConst("json"), " & j, std::string property)"], false, () => {
            this.emitLine("return get_untyped(j, property.data());");
        });
        this.emitLine("#endif");
        this.ensureBlankLine();
        if (this.haveUnions || this.haveOptionalProperties) {
            this.ensureBlankLine();
            this.emitLine(`#ifndef ${optionalMacroName}`);
            this.emitLine(`#define ${optionalMacroName}`);
            const emitGetOptional = (optionalType, label) => {
                this.emitLine("template <typename T>");
                this.emitBlock([
                    "inline ",
                    optionalType,
                    `<T> get_${label}_optional(`,
                    this.withConst("json"),
                    " & j, ",
                    this.withConst("char"),
                    " * property)"
                ], false, () => {
                    this.emitLine(["auto it = j.find(property);"]);
                    this.emitBlock(["if (it != j.end() && !it->is_null())"], false, () => {
                        this.emitLine("return j.at(property).get<", optionalType, "<T>>();");
                    });
                    this.emitLine("return ", optionalType, "<T>();");
                });
                this.ensureBlankLine();
                this.emitLine("template <typename T>");
                this.emitBlock([
                    "inline ",
                    optionalType,
                    `<T> get_${label}_optional(`,
                    this.withConst("json"),
                    " & j, std::string property)"
                ], false, () => {
                    this.emitLine(`return get_${label}_optional<T>(j, property.data());`);
                });
            };
            emitGetOptional(this.optionalTypeHeap(), "heap");
            emitGetOptional(this.optionalTypeStack(), "stack");
            this.emitLine("#endif");
            this.ensureBlankLine();
        }
    }
    emitExtraIncludes() {
        this.ensureBlankLine();
        if (this._options.codeFormat) {
            if (this._options.boost) {
                this.emitInclude(true, "boost/optional.hpp");
            }
            else {
                this.emitInclude(true, "optional");
            }
            this.emitInclude(true, "stdexcept");
            this.emitInclude(true, "regex");
        }
        if (this._options.wstring) {
            this.emitInclude(true, "codecvt");
            this.emitInclude(true, "locale");
        }
        // Include unordered_map if contains large enums
        if (Array.from(this.enums).some(enumType => this.isLargeEnum(enumType))) {
            this.emitInclude(true, "unordered_map");
        }
        this.ensureBlankLine();
    }
    emitHelper() {
        this.startFile("helper.hpp", false);
        this.emitExtraIncludes();
        this.emitInclude(true, "sstream");
        this.ensureBlankLine();
        this.emitNamespaces(this._namespaceNames, () => {
            this.emitLine("using nlohmann::json;");
            this.ensureBlankLine();
            this.emitHelperFunctions();
        });
        if (this.haveUnions || this.haveOptionalProperties) {
            this.ensureBlankLine();
            this.emitOptionalHelpers();
        }
        this.finishFile();
    }
    emitTypes() {
        if (!this._options.justTypes) {
            this.emitLine("using nlohmann::json;");
            this.ensureBlankLine();
            this.emitHelperFunctions();
        }
        this.forEachDeclaration("interposing", decl => this.emitDeclaration(decl));
        if (this._options.justTypes)
            return;
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
    }
    gatherUserNamespaceForwardDecls() {
        return this.gatherSource(() => {
            this.forEachObject("leading-and-interposing", (_, className) => this.emitClassHeaders(className));
            this.forEachEnum("leading-and-interposing", (_, enumName) => this.emitEnumHeaders(enumName));
        });
    }
    gatherNlohmannNamespaceForwardDecls() {
        return this.gatherSource(() => {
            this.forEachTopLevel("leading-and-interposing", (t, className) => this.emitTopLevelHeaders(t, className));
            this.ensureBlankLine();
            this.emitAllUnionHeaders();
        });
    }
    emitUserNamespaceImpls() {
        this.forEachObject("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className));
        this.forEachEnum("leading-and-interposing", (e, enumName) => this.emitEnumFunctions(e, enumName));
    }
    emitNlohmannNamespaceImpls() {
        this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevelFunction(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.ensureBlankLine();
        this.emitAllUnionFunctions();
    }
    emitGenerators() {
        if (this._options.justTypes) {
            let didEmit = false;
            const gathered = this.gatherSource(() => this.emitNamespaces(this._namespaceNames, () => {
                didEmit = this.forEachTopLevel("none", (t, name) => this.emitTopLevelTypedef(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
            }));
            if (didEmit) {
                this.emitGatheredSource(gathered);
                this.ensureBlankLine();
            }
        }
        else {
            const userNamespaceForwardDecls = this.gatherUserNamespaceForwardDecls();
            const nlohmannNamespaceForwardDecls = this.gatherNlohmannNamespaceForwardDecls();
            if (userNamespaceForwardDecls.length === 0 && nlohmannNamespaceForwardDecls.length > 0) {
                this.emitNamespaces(["nlohmann"], () => {
                    this.emitGatheredSource(nlohmannNamespaceForwardDecls);
                    this.emitNlohmannNamespaceImpls();
                });
            }
            else if (userNamespaceForwardDecls.length > 0 && nlohmannNamespaceForwardDecls.length === 0) {
                this.emitNamespaces(this._namespaceNames, () => {
                    this.emitGatheredSource(userNamespaceForwardDecls);
                    this.emitUserNamespaceImpls();
                });
            }
            else if (userNamespaceForwardDecls.length > 0 && nlohmannNamespaceForwardDecls.length > 0) {
                this.emitNamespaces(this._namespaceNames, () => {
                    this.emitGatheredSource(userNamespaceForwardDecls);
                });
                this.emitNamespaces(["nlohmann"], () => {
                    this.emitGatheredSource(nlohmannNamespaceForwardDecls);
                });
                this.emitNamespaces(this._namespaceNames, () => {
                    this.emitUserNamespaceImpls();
                });
                this.emitNamespaces(["nlohmann"], () => {
                    this.emitNlohmannNamespaceImpls();
                });
            }
        }
    }
    emitSingleSourceStructure(proposedFilename) {
        this.startFile(proposedFilename);
        this._generatedFiles.add(proposedFilename);
        this.emitExtraIncludes();
        if (this._options.justTypes) {
            this.emitTypes();
        }
        else {
            if (!this._options.justTypes && this.haveNamedTypes && (this.haveUnions || this.haveOptionalProperties)) {
                this.emitOptionalHelpers();
                this.ensureBlankLine();
            }
            this.emitNamespaces(this._namespaceNames, () => this.emitTypes());
        }
        this.ensureBlankLine();
        this.emitGenerators();
        this.finishFile();
    }
    updateIncludes(isClassMember, includes, propertyType, _defName) {
        const propTypes = this.generatedTypes(isClassMember, propertyType);
        for (const t of propTypes) {
            const typeName = this.sourcelikeToString(t.name);
            const propRecord = { kind: undefined, typeKind: undefined };
            if (t.type instanceof ClassType) {
                /**
                 * Ok. We can NOT forward declare direct class members, e.g. a class type is included
                 * at level#0. HOWEVER if it is not a direct class member (e.g. std::shared_ptr<Class>),
                 * - level > 0 - then we can SURELY forward declare it.
                 */
                propRecord.typeKind = "class";
                propRecord.kind = t.level === 0 ? IncludeKind.Include : IncludeKind.ForwardDeclare;
                if (t.forceInclude) {
                    propRecord.kind = IncludeKind.Include;
                }
            }
            else if (t.type instanceof EnumType) {
                propRecord.typeKind = "enum";
                propRecord.kind = IncludeKind.ForwardDeclare;
            }
            else if (t.type instanceof UnionType) {
                propRecord.typeKind = "union";
                /** Recurse into the union */
                const [maybeNull] = removeNullFromUnion(t.type, true);
                if (maybeNull !== undefined) {
                    /** Houston this is a variant, include it */
                    propRecord.kind = IncludeKind.Include;
                }
                else {
                    if (t.forceInclude) {
                        propRecord.kind = IncludeKind.Include;
                    }
                    else {
                        propRecord.kind = IncludeKind.ForwardDeclare;
                    }
                }
            }
            if (includes.has(typeName)) {
                const incKind = includes.get(typeName);
                /**
                 * If we already include the type as typed include,
                 * do not write it over with forward declare
                 */
                if (incKind !== undefined && incKind.kind === IncludeKind.ForwardDeclare) {
                    includes.set(typeName, propRecord);
                }
            }
            else {
                includes.set(typeName, propRecord);
            }
        }
    }
    emitIncludes(c, defName) {
        /**
         * Need to generate "includes", in terms 'c' has members, which
         * are defined by others
         */
        const includes = new Map();
        if (c instanceof UnionType) {
            this.updateIncludes(false, includes, c, defName);
        }
        else if (c instanceof ClassType) {
            this.forEachClassProperty(c, "none", (_name, _jsonName, property) => {
                this.updateIncludes(true, includes, property.type, defName);
            });
        }
        if (includes.size !== 0) {
            let numForwards = 0;
            let numIncludes = 0;
            includes.forEach((rec, name) => {
                /** Don't bother including the one we are defining */
                if (name === defName) {
                    return;
                }
                if (rec.kind !== IncludeKind.ForwardDeclare) {
                    this.emitInclude(false, [name, ".hpp"]);
                    numIncludes++;
                }
                else {
                    numForwards++;
                }
            });
            if (numIncludes > 0) {
                this.ensureBlankLine();
            }
            if (numForwards > 0) {
                this.emitNamespaces(this._namespaceNames, () => {
                    includes.forEach((rec, name) => {
                        /** Don't bother including the one we are defining */
                        if (name === defName) {
                            return;
                        }
                        if (rec.kind !== IncludeKind.ForwardDeclare) {
                            return;
                        }
                        if (rec.typeKind === "class" || rec.typeKind === "union") {
                            if (this._options.codeFormat) {
                                this.emitLine("class ", name, ";");
                            }
                            else {
                                this.emitLine("struct ", name, ";");
                            }
                        }
                        else if (rec.typeKind === "enum") {
                            this.emitLine("enum class ", name, " : ", this._enumType, ";");
                        }
                        else {
                            panic(`Invalid type "${rec.typeKind}" to forward declare`);
                        }
                    });
                });
            }
            this.ensureBlankLine();
        }
    }
    emitDefinition(d, defName) {
        const name = `${this.sourcelikeToString(defName)}.hpp`;
        this.startFile(name, true);
        this._generatedFiles.add(name);
        this.emitIncludes(d, this.sourcelikeToString(defName));
        this.emitNamespaces(this._namespaceNames, () => {
            this.emitDescription(this.descriptionForType(d));
            this.ensureBlankLine();
            this.emitLine("using nlohmann::json;");
            this.ensureBlankLine();
            if (d instanceof ClassType) {
                this.emitClass(d, defName);
            }
            else if (d instanceof EnumType) {
                this.emitEnum(d, defName);
            }
            else if (d instanceof UnionType) {
                this.emitUnionTypedefs(d, defName);
            }
        });
        this.finishFile();
    }
    emitMultiSourceStructure(proposedFilename) {
        if (!this._options.justTypes && this.haveNamedTypes) {
            this.emitHelper();
            this.startFile("Generators.hpp", true);
            this._allTypeNames.forEach(t => {
                this.emitInclude(false, [t, ".hpp"]);
            });
            this.ensureBlankLine();
            this.emitGenerators();
            this.finishFile();
        }
        this.forEachNamedType("leading-and-interposing", (c, n) => {
            this.emitDefinition(c, n);
        }, (e, n) => {
            this.emitDefinition(e, n);
        }, (u, n) => {
            this.emitDefinition(u, n);
        });
        /**
         * If for some reason we have not generated anything,
         * it means that a unnamed type has been generated - or nothing.
         */
        if (!this._generatedFiles.has(proposedFilename)) {
            if (!this.haveNamedTypes) {
                this.emitHelper();
            }
            this.startFile(proposedFilename);
            this._generatedFiles.forEach(f => {
                this.emitInclude(false, f);
            });
            this.emitNamespaces(this._namespaceNames, () => {
                this.forEachTopLevel("leading", (t, name) => this.emitTopLevelTypedef(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
            });
            this.finishFile();
        }
    }
    emitSourceStructure(proposedFilename) {
        this._generatedFiles.clear();
        /** Gather all the unique/custom types used by the schema */
        this._allTypeNames.clear();
        this.forEachDeclaration("none", decl => {
            const definedTypes = directlyReachableTypes(decl.type, t => {
                if (isNamedType(t) && (t instanceof ClassType || t instanceof EnumType || t instanceof UnionType)) {
                    return new Set([
                        this.sourcelikeToString(this.cppType(t, {
                            needsForwardIndirection: false,
                            needsOptionalIndirection: false,
                            inJsonNamespace: false
                        }, true, false, false))
                    ]);
                }
                return null;
            });
            this._allTypeNames = collectionUtils.setUnion(definedTypes, this._allTypeNames);
        });
        if (this._options.typeSourceStyle) {
            this.emitSingleSourceStructure(proposedFilename);
        }
        else {
            this.emitMultiSourceStructure(proposedFilename);
        }
    }
    isConversionRequired(t) {
        const originalType = this.cppType(t, {
            needsForwardIndirection: true,
            needsOptionalIndirection: true,
            inJsonNamespace: true
        }, false, false, false);
        const newType = this.cppType(t, {
            needsForwardIndirection: true,
            needsOptionalIndirection: true,
            inJsonNamespace: true
        }, false, true, false);
        return originalType !== newType;
    }
}

class CrystalTargetLanguage extends TargetLanguage {
    makeRenderer(renderContext) {
        return new CrystalRenderer(this, renderContext);
    }
    constructor() {
        super("Crystal", ["crystal", "cr", "crystallang"], "cr");
    }
    get defaultIndentation() {
        return "  ";
    }
    getOptions() {
        return [];
    }
}
const keywords$9 = [
    "Any",
    "Array",
    "Atomic",
    "Bool",
    "Channel",
    "Char",
    "Class",
    "Enum",
    "Enumerable",
    "Event",
    "Extern",
    "Exception",
    "File",
    "Float",
    "Float32",
    "Float64",
    "GC",
    "GZip",
    "Hash",
    "HTML",
    "HTTP",
    "Int",
    "Int128",
    "Int16",
    "Int32",
    "Int64",
    "Int8",
    "Iterable",
    "Link",
    "Logger",
    "Math",
    "Mutex",
    "Nil",
    "Number",
    "JSON",
    "IO",
    "Object",
    "Pointer",
    "Proc",
    "Process",
    "Range",
    "Random",
    "Regex",
    "Reference",
    "Set",
    "Signal",
    "Slice",
    "Spec",
    "StaticArray",
    "String",
    "Struct",
    "Symbol",
    "System",
    "TCPServer",
    "TCPSocket",
    "Socket",
    "Tempfile",
    "Termios",
    "Time",
    "Tuple",
    "ThreadLocal",
    "UDPSocket",
    "UInt128",
    "UInt16",
    "UInt32",
    "UInt64",
    "UInt8",
    "Union",
    "UNIXServer",
    "UNIXSocket",
    "UUID",
    "URI",
    "VaList",
    "Value",
    "Void",
    "WeakRef",
    "XML",
    "YAML",
    "Zip",
    "Zlib",
    "abstract",
    "alias",
    "as",
    "as?",
    "asm",
    "begin",
    "break",
    "case",
    "class",
    "def",
    "do",
    "else",
    "elsif",
    "end",
    "ensure",
    "enum",
    "extend",
    "false",
    "for",
    "fun",
    "if",
    "in",
    "include",
    "instance_sizeof",
    "is_a?",
    "lib",
    "macro",
    "module",
    "next",
    "nil",
    "nil?",
    "of",
    "out",
    "pointerof",
    "private",
    "protected",
    "require",
    "rescue",
    "return",
    "select",
    "self",
    "sizeof",
    "struct",
    "super",
    "then",
    "true",
    "type",
    "typeof",
    "uninitialized",
    "union",
    "unless",
    "until",
    "when",
    "while",
    "with",
    "yield"
];
function isAsciiLetterOrUnderscoreOrDigit$1(codePoint) {
    if (!isAscii(codePoint)) {
        return false;
    }
    return isLetterOrUnderscoreOrDigit(codePoint);
}
function isAsciiLetterOrUnderscore$1(codePoint) {
    if (!isAscii(codePoint)) {
        return false;
    }
    return isLetterOrUnderscore(codePoint);
}
const legalizeName$i = legalizeCharacters(isAsciiLetterOrUnderscoreOrDigit$1);
function crystalStyle(original, isSnakeCase) {
    const words = splitIntoWords(original);
    const wordStyle = isSnakeCase ? allLowerWordStyle : firstUpperWordStyle;
    const combined = combineWords(words, legalizeName$i, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore$1);
    return combined === "_" ? "_underscore" : combined;
}
const snakeNamingFunction$1 = funPrefixNamer("default", (original) => crystalStyle(original, true));
const camelNamingFunction$1 = funPrefixNamer("camel", (original) => crystalStyle(original, false));
function standardUnicodeCrystalEscape(codePoint) {
    if (codePoint <= 0xffff) {
        return "\\u{" + intToHex(codePoint, 4) + "}";
    }
    else {
        return "\\u{" + intToHex(codePoint, 6) + "}";
    }
}
const crystalStringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeCrystalEscape));
class CrystalRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext) {
        super(targetLanguage, renderContext);
    }
    makeNamedTypeNamer() {
        return camelNamingFunction$1;
    }
    namerForObjectProperty() {
        return snakeNamingFunction$1;
    }
    makeUnionMemberNamer() {
        return camelNamingFunction$1;
    }
    makeEnumCaseNamer() {
        return camelNamingFunction$1;
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$9;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    get commentLineStart() {
        return "# ";
    }
    nullableCrystalType(t, withIssues) {
        return [this.crystalType(t, withIssues), "?"];
    }
    isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
    }
    crystalType(t, withIssues = false) {
        return matchType(t, _anyType => maybeAnnotated(withIssues, anyTypeIssueAnnotation, "JSON::Any?"), _nullType => maybeAnnotated(withIssues, nullTypeIssueAnnotation, "Nil"), _boolType => "Bool", _integerType => "Int32", _doubleType => "Float64", _stringType => "String", arrayType => ["Array(", this.crystalType(arrayType.items, withIssues), ")"], classType => this.nameForNamedType(classType), mapType => ["Hash(String, ", this.crystalType(mapType.values, withIssues), ")"], _enumType => "String", unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return this.nullableCrystalType(nullable, withIssues);
            const [hasNull] = removeNullFromUnion(unionType);
            const name = this.nameForNamedType(unionType);
            return hasNull !== null ? [name, "?"] : name;
        });
    }
    breakCycle(t, withIssues) {
        return this.crystalType(t, withIssues);
    }
    emitRenameAttribute(propName, jsonName) {
        const escapedName = crystalStringEscape(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer) {
            this.emitLine('@[JSON::Field(key: "', escapedName, '")]');
        }
    }
    emitStructDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        const structBody = () => this.forEachClassProperty(c, "none", (name, jsonName, prop) => {
            this.ensureBlankLine();
            this.emitDescription(this.descriptionForClassProperty(c, jsonName));
            this.emitRenameAttribute(name, jsonName);
            this.emitLine("property ", name, " : ", this.crystalType(prop.type, true));
        });
        this.emitBlock(["class ", className], structBody);
    }
    emitBlock(line, f) {
        this.emitLine(line);
        this.indent(() => {
            this.emitLine("include JSON::Serializable");
        });
        this.ensureBlankLine();
        this.indent(f);
        this.emitLine("end");
    }
    emitEnum(line, f) {
        this.emitLine(line);
        this.indent(f);
        this.emitLine("end");
    }
    emitUnion(u, unionName) {
        const isMaybeWithSingleType = nullableFromUnion(u);
        if (isMaybeWithSingleType !== null) {
            return;
        }
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = removeNullFromUnion(u);
        let types = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_name, t) => {
            const crystalType = this.breakCycle(t, true);
            types.push([crystalType]);
        });
        this.emitLine([
            "alias ",
            unionName,
            " = ",
            types.map(r => r.map(sl => this.sourcelikeToString(sl))).join(" | ")
        ]);
    }
    emitTopLevelAlias(t, name) {
        this.emitLine("alias ", name, " = ", this.crystalType(t));
    }
    emitLeadingComments() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
            return;
        }
    }
    emitSourceStructure() {
        this.emitLeadingComments();
        this.ensureBlankLine();
        this.emitLine('require "json"');
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelAlias(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.forEachObject("leading-and-interposing", (c, name) => this.emitStructDefinition(c, name));
        this.forEachUnion("leading-and-interposing", (u, name) => this.emitUnion(u, name));
    }
}

var Framework$3;
(function (Framework) {
    Framework["Newtonsoft"] = "Newtonsoft";
    Framework["SystemTextJson"] = "SystemTextJson";
})(Framework$3 || (Framework$3 = {}));
var AccessModifier;
(function (AccessModifier) {
    AccessModifier["None"] = "None";
    AccessModifier["Public"] = "Public";
    AccessModifier["Internal"] = "Internal";
})(AccessModifier || (AccessModifier = {}));
function noFollow(t) {
    return t;
}
function needTransformerForType(t) {
    if (t instanceof UnionType) {
        const maybeNullable = nullableFromUnion(t);
        if (maybeNullable === null)
            return "automatic";
        if (needTransformerForType(maybeNullable) === "manual")
            return "nullable";
        return "none";
    }
    if (t instanceof ArrayType) {
        const itemsNeed = needTransformerForType(t.items);
        if (itemsNeed === "manual" || itemsNeed === "nullable")
            return "automatic";
        return "none";
    }
    if (t instanceof EnumType)
        return "automatic";
    if (t.kind === "double")
        return minMaxValueForType(t) !== undefined ? "manual" : "none";
    if (t.kind === "integer-string" || t.kind === "bool-string")
        return "manual";
    if (t.kind === "string") {
        return minMaxLengthForType(t) !== undefined ? "manual" : "none";
    }
    return "none";
}
function alwaysApplyTransformation(xf) {
    const t = xf.targetType;
    if (t instanceof EnumType)
        return true;
    if (t instanceof UnionType)
        return nullableFromUnion(t) === null;
    return false;
}
/**
 * The C# type for a given transformed string type.
 */
function csTypeForTransformedStringType(t) {
    switch (t.kind) {
        case "date-time":
            return "DateTimeOffset";
        case "uuid":
            return "Guid";
        case "uri":
            return "Uri";
        default:
            return panic(`Transformed string type ${t.kind} not supported`);
    }
}
const cSharpOptions = {
    framework: new EnumOption("framework", "Serialization framework", [
        ["NewtonSoft", Framework$3.Newtonsoft],
        ["SystemTextJson", Framework$3.SystemTextJson]
    ], "NewtonSoft"),
    useList: new EnumOption("array-type", "Use T[] or List<T>", [
        ["array", false],
        ["list", true]
    ]),
    dense: new EnumOption("density", "Property density", [
        ["normal", false],
        ["dense", true]
    ], "normal", "secondary"),
    // FIXME: Do this via a configurable named eventually.
    namespace: new StringOption("namespace", "Generated namespace", "NAME", "QuickType"),
    version: new EnumOption("csharp-version", "C# version", [
        ["5", 5],
        ["6", 6]
    ], "6", "secondary"),
    virtual: new BooleanOption("virtual", "Generate virtual properties", false),
    typeForAny: new EnumOption("any-type", 'Type to use for "any"', [
        ["object", "object"],
        ["dynamic", "dynamic"]
    ], "object", "secondary"),
    useDecimal: new EnumOption("number-type", "Type to use for numbers", [
        ["double", false],
        ["decimal", true]
    ], "double", "secondary"),
    features: new EnumOption("features", "Output features", [
        ["complete", { namespaces: true, helpers: true, attributes: true }],
        ["attributes-only", { namespaces: true, helpers: false, attributes: true }],
        ["just-types-and-namespace", { namespaces: true, helpers: false, attributes: false }],
        ["just-types", { namespaces: true, helpers: false, attributes: false }]
    ]),
    baseclass: new EnumOption("base-class", "Base class", [
        ["EntityData", "EntityData"],
        ["Object", undefined]
    ], "Object", "secondary"),
    checkRequired: new BooleanOption("check-required", "Fail if required properties are missing", false),
    keepPropertyName: new BooleanOption("keep-property-name", "Keep original field name generate", false)
};
class CSharpTargetLanguage extends TargetLanguage {
    constructor() {
        super("C#", ["cs", "csharp"], "cs");
    }
    getOptions() {
        return [
            cSharpOptions.framework,
            cSharpOptions.namespace,
            cSharpOptions.version,
            cSharpOptions.dense,
            cSharpOptions.useList,
            cSharpOptions.useDecimal,
            cSharpOptions.typeForAny,
            cSharpOptions.virtual,
            cSharpOptions.features,
            cSharpOptions.baseclass,
            cSharpOptions.checkRequired,
            cSharpOptions.keepPropertyName
        ];
    }
    get stringTypeMapping() {
        const mapping = new Map();
        mapping.set("date", "date-time");
        mapping.set("time", "date-time");
        mapping.set("date-time", "date-time");
        mapping.set("uuid", "uuid");
        mapping.set("uri", "uri");
        mapping.set("integer-string", "integer-string");
        mapping.set("bool-string", "bool-string");
        return mapping;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    needsTransformerForType(t) {
        const need = needTransformerForType(t);
        return need !== "none" && need !== "nullable";
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(cSharpOptions, untypedOptionValues);
        switch (options.framework) {
            case Framework$3.Newtonsoft:
                return new NewtonsoftCSharpRenderer(this, renderContext, getOptionValues(newtonsoftCSharpOptions, untypedOptionValues));
            case Framework$3.SystemTextJson:
                return new SystemTextJsonCSharpRenderer(this, renderContext, getOptionValues(systemTextJsonCSharpOptions, untypedOptionValues));
            default:
                return assertNever(options.framework);
        }
    }
}
const namingFunction$3 = funPrefixNamer("namer", csNameStyle);
const namingFunctionKeep = funPrefixNamer("namerKeep", csNameStyleKeep);
// FIXME: Make a Named?
const denseJsonPropertyName = "J";
const denseRequiredEnumName = "R";
const denseNullValueHandlingEnumName = "N";
function isStartCharacter$a(utf16Unit) {
    if ($747425b437e121da$export$2e2bcd8739ae039.isAlphabetic(utf16Unit)) {
        return true;
    }
    return utf16Unit === 0x5f; // underscore
}
function isPartCharacter$a(utf16Unit) {
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(utf16Unit);
    if (["Nd", "Pc", "Mn", "Mc"].includes(category)) {
        return true;
    }
    return isStartCharacter$a(utf16Unit);
}
const legalizeName$h = utf16LegalizeCharacters(isPartCharacter$a);
function csNameStyle(original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$h, firstUpperWordStyle, firstUpperWordStyle, firstUpperWordStyle, firstUpperWordStyle, "", isStartCharacter$a);
}
function csNameStyleKeep(original) {
    const keywords = [
        "abstract",
        "as",
        "base",
        "bool",
        "break",
        "byte",
        "case",
        "catch",
        "char",
        "checked",
        "class",
        "const",
        "continue",
        "decimal",
        "default",
        "delegate",
        "do",
        "double",
        "else",
        "enum",
        "event",
        "explicit",
        "extern",
        "false",
        "finally",
        "fixed",
        "float",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "int",
        "interface",
        "internal",
        "is",
        "lock",
        "long",
        "namespace",
        "new",
        "null",
        "object",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "ref",
        "return",
        "sbyte",
        "sealed",
        "short",
        "sizeof",
        "stackalloc",
        "static",
        "string",
        "struct",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "uint",
        "ulong",
        "unchecked",
        "unsafe",
        "ushort",
        "using",
        "virtual",
        "void",
        "volatile",
        "while"
    ];
    const words = [
        {
            word: original,
            isAcronym: false
        }
    ];
    const result = combineWords(words, legalizeName$h, x => x, x => x, x => x, x => x, "", isStartCharacter$a);
    return keywords.includes(result) ? "@" + result : result;
}
function isValueType$1(t) {
    if (t instanceof UnionType) {
        return nullableFromUnion(t) === null;
    }
    return ["integer", "double", "bool", "enum", "date-time", "uuid"].includes(t.kind);
}
class CSharpRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _csOptions) {
        super(targetLanguage, renderContext);
        this._csOptions = _csOptions;
    }
    forbiddenNamesForGlobalNamespace() {
        return ["QuickType", "Type", "System", "Console", "Exception", "DateTimeOffset", "Guid", "Uri"];
    }
    forbiddenForObjectProperties(_, classNamed) {
        return {
            names: [
                classNamed,
                "ToString",
                "GetHashCode",
                "Finalize",
                "Equals",
                "GetType",
                "MemberwiseClone",
                "ReferenceEquals"
            ],
            includeGlobalForbidden: false
        };
    }
    forbiddenForUnionMembers(_, unionNamed) {
        return { names: [unionNamed], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return namingFunction$3;
    }
    namerForObjectProperty() {
        return this._csOptions.keepPropertyName ? namingFunctionKeep : namingFunction$3;
    }
    makeUnionMemberNamer() {
        return namingFunction$3;
    }
    makeEnumCaseNamer() {
        return namingFunction$3;
    }
    unionNeedsName(u) {
        return nullableFromUnion(u) === null;
    }
    namedTypeToNameForTopLevel(type) {
        // If the top-level type doesn't contain any classes or unions
        // we have to define a class just for the `FromJson` method, in
        // emitFromJsonForTopLevel.
        return directlyReachableSingleNamedType(type);
    }
    emitBlock(f, semicolon = false) {
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}", semicolon ? ";" : "");
    }
    get doubleType() {
        return this._csOptions.useDecimal ? "decimal" : "double";
    }
    csType(t, follow = followTargetType, withIssues = false) {
        const actualType = follow(t);
        return matchType(actualType, _anyType => maybeAnnotated(withIssues, anyTypeIssueAnnotation, this._csOptions.typeForAny), _nullType => maybeAnnotated(withIssues, nullTypeIssueAnnotation, this._csOptions.typeForAny), _boolType => "bool", _integerType => "long", _doubleType => this.doubleType, _stringType => "string", arrayType => {
            const itemsType = this.csType(arrayType.items, follow, withIssues);
            if (this._csOptions.useList) {
                return ["List<", itemsType, ">"];
            }
            else {
                return [itemsType, "[]"];
            }
        }, classType => this.nameForNamedType(classType), mapType => ["Dictionary<string, ", this.csType(mapType.values, follow, withIssues), ">"], enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return this.nullableCSType(nullable, noFollow);
            return this.nameForNamedType(unionType);
        }, transformedStringType => csTypeForTransformedStringType(transformedStringType));
    }
    nullableCSType(t, follow = followTargetType, withIssues = false) {
        t = followTargetType(t);
        const csType = this.csType(t, follow, withIssues);
        if (isValueType$1(t)) {
            return [csType, "?"];
        }
        else {
            return csType;
        }
    }
    baseclassForType(_t) {
        return undefined;
    }
    emitType(description, accessModifier, declaration, name, baseclass, emitter) {
        switch (accessModifier) {
            case AccessModifier.Public:
                declaration = ["public ", declaration];
                break;
            case AccessModifier.Internal:
                declaration = ["internal ", declaration];
                break;
        }
        this.emitDescription(description);
        if (baseclass === undefined) {
            this.emitLine(declaration, " ", name);
        }
        else {
            this.emitLine(declaration, " ", name, " : ", baseclass);
        }
        this.emitBlock(emitter);
    }
    attributesForProperty(_property, _name, _c, _jsonName) {
        return undefined;
    }
    propertyDefinition(property, name, _c, _jsonName) {
        const t = property.type;
        const csType = property.isOptional
            ? this.nullableCSType(t, followTargetType, true)
            : this.csType(t, followTargetType, true);
        const propertyArray = ["public "];
        if (this._csOptions.virtual)
            propertyArray.push("virtual ");
        return [...propertyArray, csType, " ", name, " { get; set; }"];
    }
    emitDescriptionBlock(lines) {
        const start = "/// <summary>";
        if (this._csOptions.dense) {
            this.emitLine(start, lines.join("; "), "</summary>");
        }
        else {
            this.emitCommentLines(lines, { lineStart: "/// ", beforeComment: start, afterComment: "/// </summary>" });
        }
    }
    blankLinesBetweenAttributes() {
        return false;
    }
    emitClassDefinition(c, className) {
        this.emitType(this.descriptionForType(c), AccessModifier.Public, "partial class", className, this.baseclassForType(c), () => {
            if (c.getProperties().size === 0)
                return;
            const blankLines = this.blankLinesBetweenAttributes() ? "interposing" : "none";
            let columns = [];
            let isFirstProperty = true;
            let previousDescription = undefined;
            this.forEachClassProperty(c, blankLines, (name, jsonName, p) => {
                const attributes = this.attributesForProperty(p, name, c, jsonName);
                const description = this.descriptionForClassProperty(c, jsonName);
                const property = this.propertyDefinition(p, name, c, jsonName);
                if (attributes === undefined) {
                    if (
                    // Descriptions should be preceded by an empty line
                    (!isFirstProperty && description !== undefined) ||
                        // If the previous property has a description, leave an empty line
                        previousDescription !== undefined) {
                        this.ensureBlankLine();
                    }
                    this.emitDescription(description);
                    this.emitLine(property);
                }
                else if (this._csOptions.dense && attributes.length > 0) {
                    const comment = description === undefined ? "" : ` // ${description.join("; ")}`;
                    columns.push([attributes, " ", property, comment]);
                }
                else {
                    this.emitDescription(description);
                    for (const attribute of attributes) {
                        this.emitLine(attribute);
                    }
                    this.emitLine(property);
                }
                isFirstProperty = false;
                previousDescription = description;
            });
            if (columns.length > 0) {
                this.emitTable(columns);
            }
        });
    }
    emitUnionDefinition(u, unionName) {
        const nonNulls = removeNullFromUnion(u, true)[1];
        this.emitType(this.descriptionForType(u), AccessModifier.Public, "partial struct", unionName, this.baseclassForType(u), () => {
            this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
                const csType = this.nullableCSType(t);
                this.emitLine("public ", csType, " ", fieldName, ";");
            });
            this.ensureBlankLine();
            const nullTests = Array.from(nonNulls).map(t => [
                this.nameForUnionMember(u, t),
                " == null"
            ]);
            this.ensureBlankLine();
            this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
                const csType = this.csType(t);
                this.emitExpressionMember(["public static implicit operator ", unionName, "(", csType, " ", fieldName, ")"], ["new ", unionName, " { ", fieldName, " = ", fieldName, " }"]);
            });
            if (u.findMember("null") === undefined)
                return;
            this.emitExpressionMember("public bool IsNull", collectionUtils.arrayIntercalate(" && ", nullTests), true);
        });
    }
    emitEnumDefinition(e, enumName) {
        const caseNames = [];
        this.forEachEnumCase(e, "none", name => {
            if (caseNames.length > 0)
                caseNames.push(", ");
            caseNames.push(name);
        });
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("public enum ", enumName, " { ", caseNames, " };");
    }
    emitExpressionMember(declare, define, isProperty = false) {
        if (this._csOptions.version === 5) {
            this.emitLine(declare);
            this.emitBlock(() => {
                const stmt = ["return ", define, ";"];
                if (isProperty) {
                    this.emitLine("get");
                    this.emitBlock(() => this.emitLine(stmt));
                }
                else {
                    this.emitLine(stmt);
                }
            });
        }
        else {
            this.emitLine(declare, " => ", define, ";");
        }
    }
    emitTypeSwitch(types, condition, withBlock, withReturn, f) {
        assert(!withReturn || withBlock, "Can only have return with block");
        for (const t of types) {
            this.emitLine("if (", condition(t), ")");
            if (withBlock) {
                this.emitBlock(() => {
                    f(t);
                    if (withReturn) {
                        this.emitLine("return;");
                    }
                });
            }
            else {
                this.indent(() => f(t));
            }
        }
    }
    emitUsing(ns) {
        this.emitLine("using ", ns, ";");
    }
    emitUsings() {
        for (const ns of ["System", "System.Collections.Generic"]) {
            this.emitUsing(ns);
        }
    }
    emitRequiredHelpers() {
        return;
    }
    emitTypesAndSupport() {
        this.forEachObject("leading-and-interposing", (c, name) => this.emitClassDefinition(c, name));
        this.forEachEnum("leading-and-interposing", (e, name) => this.emitEnumDefinition(e, name));
        this.forEachUnion("leading-and-interposing", (u, name) => this.emitUnionDefinition(u, name));
        this.emitRequiredHelpers();
    }
    emitDefaultLeadingComments() {
        return;
    }
    emitDefaultFollowingComments() {
        return;
    }
    needNamespace() {
        return true;
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else {
            this.emitDefaultLeadingComments();
        }
        this.ensureBlankLine();
        if (this.needNamespace()) {
            this.emitLine("namespace ", this._csOptions.namespace);
            this.emitBlock(() => {
                this.emitUsings();
                this.emitTypesAndSupport();
            });
        }
        else {
            this.emitUsings();
            this.emitTypesAndSupport();
        }
        this.emitDefaultFollowingComments();
    }
}
const newtonsoftCSharpOptions = Object.assign({}, cSharpOptions, {});
class NewtonsoftCSharpRenderer extends CSharpRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext, _options);
        this._options = _options;
        this._enumExtensionsNames = new Map();
        this._needHelpers = _options.features.helpers;
        this._needAttributes = _options.features.attributes;
        this._needNamespaces = _options.features.namespaces;
    }
    forbiddenNamesForGlobalNamespace() {
        const forbidden = [
            "Converter",
            "JsonConverter",
            "JsonSerializer",
            "JsonWriter",
            "JsonToken",
            "Serialize",
            "Newtonsoft",
            "MetadataPropertyHandling",
            "DateParseHandling",
            "FromJson",
            "Required"
        ];
        if (this._options.dense) {
            forbidden.push("J", "R", "N");
        }
        if (this._options.baseclass !== undefined) {
            forbidden.push(this._options.baseclass);
        }
        return super.forbiddenNamesForGlobalNamespace().concat(forbidden);
    }
    forbiddenForObjectProperties(c, className) {
        const result = super.forbiddenForObjectProperties(c, className);
        result.names = result.names.concat(["ToJson", "FromJson", "Required"]);
        return result;
    }
    makeNameForTransformation(xf, typeName) {
        if (typeName === undefined) {
            let xfer = xf.transformer;
            if (xfer instanceof DecodingTransformer && xfer.consumer !== undefined) {
                xfer = xfer.consumer;
            }
            return new SimpleName([`${xfer.kind}_converter`], namingFunction$3, inferredNameOrder + 30);
        }
        return new DependencyName(namingFunction$3, typeName.order + 30, lookup => `${lookup(typeName)}_converter`);
    }
    makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof EnumType))
            return [];
        const extensionsName = new DependencyName(namingFunction$3, name.order + 30, lookup => `${lookup(name)}_extensions`);
        this._enumExtensionsNames.set(name, extensionsName);
        return [extensionsName];
    }
    emitUsings() {
        // FIXME: We need System.Collections.Generic whenever we have maps or use List.
        if (!this._needAttributes && !this._needHelpers)
            return;
        super.emitUsings();
        this.ensureBlankLine();
        for (const ns of ["System.Globalization", "Newtonsoft.Json", "Newtonsoft.Json.Converters"]) {
            this.emitUsing(ns);
        }
        if (this._options.dense) {
            this.emitUsing([denseJsonPropertyName, " = Newtonsoft.Json.JsonPropertyAttribute"]);
            this.emitUsing([denseRequiredEnumName, " = Newtonsoft.Json.Required"]);
            this.emitUsing([denseNullValueHandlingEnumName, " = Newtonsoft.Json.NullValueHandling"]);
        }
        if (this._options.baseclass === "EntityData") {
            this.emitUsing("Microsoft.Azure.Mobile.Server");
        }
    }
    baseclassForType(_t) {
        return this._options.baseclass;
    }
    emitDefaultLeadingComments() {
        if (!this._needHelpers)
            return;
        this.emitLine("// <auto-generated />");
        this.emitLine("//");
        this.emitLine("// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this._options.namespace, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
            let rhs;
            if (t instanceof EnumType) {
                rhs = ["JsonConvert.DeserializeObject<", topLevelName, ">(jsonString)"];
            }
            else {
                rhs = [topLevelName, ".FromJson(jsonString)"];
            }
            this.emitLine("//    var ", modifySource(camelCase, topLevelName), " = ", rhs, ";");
        });
    }
    converterForType(t) {
        let xf = transformationForType(t);
        if (xf === undefined && t instanceof UnionType) {
            const maybeNullable = nullableFromUnion(t);
            if (maybeNullable !== null) {
                t = maybeNullable;
                xf = transformationForType(t);
            }
        }
        if (xf === undefined)
            return undefined;
        if (alwaysApplyTransformation(xf))
            return undefined;
        return defined(this.nameForTransformation(t));
    }
    attributesForProperty(property, _name, _c, jsonName) {
        if (!this._needAttributes)
            return undefined;
        const attributes = [];
        const jsonProperty = this._options.dense ? denseJsonPropertyName : "JsonProperty";
        const escapedName = utf16StringEscape(jsonName);
        const isNullable = followTargetType(property.type).isNullable;
        const isOptional = property.isOptional;
        const requiredClass = this._options.dense ? "R" : "Required";
        const nullValueHandlingClass = this._options.dense ? "N" : "NullValueHandling";
        const nullValueHandling = isOptional && !isNullable ? [", NullValueHandling = ", nullValueHandlingClass, ".Ignore"] : [];
        let required;
        if (!this._options.checkRequired || (isOptional && isNullable)) {
            required = [nullValueHandling];
        }
        else if (isOptional && !isNullable) {
            required = [", Required = ", requiredClass, ".DisallowNull", nullValueHandling];
        }
        else if (!isOptional && isNullable) {
            required = [", Required = ", requiredClass, ".AllowNull"];
        }
        else {
            required = [", Required = ", requiredClass, ".Always", nullValueHandling];
        }
        attributes.push(["[", jsonProperty, '("', escapedName, '"', required, ")]"]);
        const converter = this.converterForType(property.type);
        if (converter !== undefined) {
            attributes.push(["[JsonConverter(typeof(", converter, "))]"]);
        }
        return attributes;
    }
    blankLinesBetweenAttributes() {
        return this._needAttributes && !this._options.dense;
    }
    // The "this" type can't be `dynamic`, so we have to force it to `object`.
    topLevelResultType(t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
    }
    emitFromJsonForTopLevel(t, name) {
        if (t instanceof EnumType)
            return;
        let partial;
        let typeKind;
        const definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== undefined) {
            partial = "partial ";
            typeKind = definedType instanceof ClassType ? "class" : "struct";
        }
        else {
            partial = "";
            typeKind = "class";
        }
        const csType = this.topLevelResultType(t);
        this.emitType(undefined, AccessModifier.Public, [partial, typeKind], name, this.baseclassForType(t), () => {
            // FIXME: Make FromJson a Named
            this.emitExpressionMember(["public static ", csType, " FromJson(string json)"], ["JsonConvert.DeserializeObject<", csType, ">(json, ", this._options.namespace, ".Converter.Settings)"]);
        });
    }
    emitDecoderSwitch(emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
    }
    emitTokenCase(tokenType) {
        this.emitLine("case JsonToken.", tokenType, ":");
    }
    emitThrow(message) {
        this.emitLine("throw new Exception(", message, ");");
    }
    deserializeTypeCode(typeName) {
        return ["serializer.Deserialize<", typeName, ">(reader)"];
    }
    serializeValueCode(value) {
        return ["serializer.Serialize(writer, ", value, ")"];
    }
    emitSerializeClass() {
        // FIXME: Make Serialize a Named
        this.emitType(undefined, AccessModifier.Public, "static class", "Serialize", undefined, () => {
            // Sometimes multiple top-levels will resolve to the same type, so we have to take care
            // not to emit more than one extension method for the same type.
            const seenTypes = new Set();
            this.forEachTopLevel("none", t => {
                // FIXME: Make ToJson a Named
                if (!seenTypes.has(t)) {
                    seenTypes.add(t);
                    this.emitExpressionMember(["public static string ToJson(this ", this.topLevelResultType(t), " self)"], ["JsonConvert.SerializeObject(self, ", this._options.namespace, ".Converter.Settings)"]);
                }
            });
        });
    }
    emitCanConvert(expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
    }
    emitReadJson(emitBody) {
        this.emitLine("public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)");
        this.emitBlock(emitBody);
    }
    emitWriteJson(variable, emitBody) {
        this.emitLine("public override void WriteJson(JsonWriter writer, object ", variable, ", JsonSerializer serializer)");
        this.emitBlock(emitBody);
    }
    converterObject(converterName) {
        // FIXME: Get a singleton
        return [converterName, ".Singleton"];
    }
    emitConverterClass() {
        // FIXME: Make Converter a Named
        const converterName = ["Converter"];
        this.emitType(undefined, AccessModifier.Internal, "static class", converterName, undefined, () => {
            this.emitLine("public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings");
            this.emitBlock(() => {
                this.emitLine("MetadataPropertyHandling = MetadataPropertyHandling.Ignore,");
                this.emitLine("DateParseHandling = DateParseHandling.None,");
                this.emitLine("Converters =");
                this.emitLine("{");
                this.indent(() => {
                    for (const [t, converter] of this.typesWithNamedTransformations) {
                        if (alwaysApplyTransformation(defined(transformationForType(t)))) {
                            this.emitLine(this.converterObject(converter), ",");
                        }
                    }
                    this.emitLine("new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }");
                });
                this.emitLine("},");
            }, true);
        });
    }
    emitDecoderTransformerCase(tokenCases, variableName, xfer, targetType, emitFinish) {
        if (xfer === undefined)
            return;
        for (const tokenCase of tokenCases) {
            this.emitTokenCase(tokenCase);
        }
        this.indent(() => {
            const allHandled = this.emitDecodeTransformer(xfer, targetType, emitFinish, variableName);
            if (!allHandled) {
                this.emitLine("break;");
            }
        });
    }
    emitConsume(value, consumer, targetType, emitFinish) {
        if (consumer === undefined) {
            emitFinish(value);
            return true;
        }
        else {
            return this.emitTransformer(value, consumer, targetType, emitFinish);
        }
    }
    emitDecodeTransformer(xfer, targetType, emitFinish, variableName = "value") {
        if (xfer instanceof DecodingTransformer) {
            const source = xfer.sourceType;
            const converter = this.converterForType(targetType);
            if (converter !== undefined) {
                const typeSource = this.csType(targetType);
                this.emitLine("var converter = ", this.converterObject(converter), ";");
                this.emitLine("var ", variableName, " = (", typeSource, ")converter.ReadJson(reader, typeof(", typeSource, "), null, serializer);");
            }
            else if (source.kind !== "null") {
                let output = targetType.kind === "double" ? targetType : source;
                this.emitLine("var ", variableName, " = ", this.deserializeTypeCode(this.csType(output)), ";");
            }
            return this.emitConsume(variableName, xfer.consumer, targetType, emitFinish);
        }
        else if (xfer instanceof ArrayDecodingTransformer) {
            // FIXME: Consume StartArray
            if (!(targetType instanceof ArrayType)) {
                return panic("Array decoding must produce an array type");
            }
            // FIXME: handle EOF
            this.emitLine("reader.Read();");
            this.emitLine("var ", variableName, " = new List<", this.csType(targetType.items), ">();");
            this.emitLine("while (reader.TokenType != JsonToken.EndArray)");
            this.emitBlock(() => {
                this.emitDecodeTransformer(xfer.itemTransformer, xfer.itemTargetType, v => this.emitLine(variableName, ".Add(", v, ");"), "arrayItem");
                // FIXME: handle EOF
                this.emitLine("reader.Read();");
            });
            let result = variableName;
            if (!this._options.useList) {
                result = [result, ".ToArray()"];
            }
            emitFinish(result);
            return true;
        }
        else if (xfer instanceof DecodingChoiceTransformer) {
            this.emitDecoderSwitch(() => {
                const nullTransformer = xfer.nullTransformer;
                if (nullTransformer !== undefined) {
                    this.emitTokenCase("Null");
                    this.indent(() => {
                        const allHandled = this.emitDecodeTransformer(nullTransformer, targetType, emitFinish, "null");
                        if (!allHandled) {
                            this.emitLine("break");
                        }
                    });
                }
                this.emitDecoderTransformerCase(["Integer"], "integerValue", xfer.integerTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(xfer.integerTransformer === undefined ? ["Integer", "Float"] : ["Float"], "doubleValue", xfer.doubleTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["Boolean"], "boolValue", xfer.boolTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["String", "Date"], "stringValue", xfer.stringTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["StartObject"], "objectValue", xfer.objectTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["StartArray"], "arrayValue", xfer.arrayTransformer, targetType, emitFinish);
            });
            return false;
        }
        else {
            return panic("Unknown transformer");
        }
    }
    stringCaseValue(t, stringCase) {
        if (t.kind === "string") {
            return ['"', utf16StringEscape(stringCase), '"'];
        }
        else if (t instanceof EnumType) {
            return [this.nameForNamedType(t), ".", this.nameForEnumCase(t, stringCase)];
        }
        return panic(`Type ${t.kind} does not have string cases`);
    }
    emitTransformer(variable, xfer, targetType, emitFinish) {
        function directTargetType(continuation) {
            if (continuation === undefined) {
                return targetType;
            }
            return followTargetType(continuation.sourceType);
        }
        if (xfer instanceof ChoiceTransformer) {
            const caseXfers = xfer.transformers;
            if (caseXfers.length > 1 && caseXfers.every(caseXfer => caseXfer instanceof StringMatchTransformer)) {
                this.emitLine("switch (", variable, ")");
                this.emitBlock(() => {
                    for (const caseXfer of caseXfers) {
                        const matchXfer = caseXfer;
                        const value = this.stringCaseValue(followTargetType(matchXfer.sourceType), matchXfer.stringCase);
                        this.emitLine("case ", value, ":");
                        this.indent(() => {
                            const allDone = this.emitTransformer(variable, matchXfer.transformer, targetType, emitFinish);
                            if (!allDone) {
                                this.emitLine("break;");
                            }
                        });
                    }
                });
                // FIXME: Can we check for exhaustiveness?  For enums it should be easy.
                return false;
            }
            else {
                for (const caseXfer of caseXfers) {
                    this.emitTransformer(variable, caseXfer, targetType, emitFinish);
                }
            }
        }
        else if (xfer instanceof UnionMemberMatchTransformer) {
            const memberType = xfer.memberType;
            const maybeNullable = nullableFromUnion(xfer.sourceType);
            let test;
            let member;
            if (maybeNullable !== null) {
                if (memberType.kind === "null") {
                    test = [variable, " == null"];
                    member = "null";
                }
                else {
                    test = [variable, " != null"];
                    member = variable;
                }
            }
            else if (memberType.kind === "null") {
                test = [variable, ".IsNull"];
                member = "null";
            }
            else {
                const memberName = this.nameForUnionMember(xfer.sourceType, memberType);
                member = [variable, ".", memberName];
                test = [member, " != null"];
            }
            if (memberType.kind !== "null" && isValueType$1(memberType)) {
                member = [member, ".Value"];
            }
            this.emitLine("if (", test, ")");
            this.emitBlock(() => this.emitTransformer(member, xfer.transformer, targetType, emitFinish));
        }
        else if (xfer instanceof StringMatchTransformer) {
            const value = this.stringCaseValue(followTargetType(xfer.sourceType), xfer.stringCase);
            this.emitLine("if (", variable, " == ", value, ")");
            this.emitBlock(() => this.emitTransformer(variable, xfer.transformer, targetType, emitFinish));
        }
        else if (xfer instanceof EncodingTransformer) {
            const converter = this.converterForType(xfer.sourceType);
            if (converter !== undefined) {
                this.emitLine("var converter = ", this.converterObject(converter), ";");
                this.emitLine("converter.WriteJson(writer, ", variable, ", serializer);");
            }
            else {
                this.emitLine(this.serializeValueCode(variable), ";");
            }
            emitFinish([]);
            return true;
        }
        else if (xfer instanceof ArrayEncodingTransformer) {
            this.emitLine("writer.WriteStartArray();");
            const itemVariable = "arrayItem";
            this.emitLine("foreach (var ", itemVariable, " in ", variable, ")");
            this.emitBlock(() => {
                this.emitTransformer(itemVariable, xfer.itemTransformer, xfer.itemTargetType, () => {
                    return;
                });
            });
            this.emitLine("writer.WriteEndArray();");
            emitFinish([]);
            return true;
        }
        else if (xfer instanceof ParseStringTransformer) {
            const immediateTargetType = xfer.consumer === undefined ? targetType : xfer.consumer.sourceType;
            switch (immediateTargetType.kind) {
                case "date-time":
                    this.emitLine("DateTimeOffset dt;");
                    this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
                    this.emitBlock(() => this.emitConsume("dt", xfer.consumer, targetType, emitFinish));
                    break;
                case "uuid":
                    this.emitLine("Guid guid;");
                    this.emitLine("if (Guid.TryParse(", variable, ", out guid))");
                    this.emitBlock(() => this.emitConsume("guid", xfer.consumer, targetType, emitFinish));
                    break;
                case "uri":
                    this.emitLine("try");
                    this.emitBlock(() => {
                        this.emitLine("var uri = new Uri(", variable, ");");
                        this.emitConsume("uri", xfer.consumer, targetType, emitFinish);
                    });
                    this.emitLine("catch (UriFormatException) {}");
                    break;
                case "integer":
                    this.emitLine("long l;");
                    this.emitLine("if (Int64.TryParse(", variable, ", out l))");
                    this.emitBlock(() => this.emitConsume("l", xfer.consumer, targetType, emitFinish));
                    break;
                case "bool":
                    this.emitLine("bool b;");
                    this.emitLine("if (Boolean.TryParse(", variable, ", out b))");
                    this.emitBlock(() => this.emitConsume("b", xfer.consumer, targetType, emitFinish));
                    break;
                default:
                    return panic(`Parsing string to ${immediateTargetType.kind} not supported`);
            }
        }
        else if (xfer instanceof StringifyTransformer) {
            switch (xfer.sourceType.kind) {
                case "date-time":
                    return this.emitConsume([variable, '.ToString("o", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
                case "uuid":
                    return this.emitConsume([variable, '.ToString("D", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
                case "integer":
                case "uri":
                    return this.emitConsume([variable, ".ToString()"], xfer.consumer, targetType, emitFinish);
                case "bool":
                    this.emitLine("var boolString = ", variable, ' ? "true" : "false";');
                    return this.emitConsume("boolString", xfer.consumer, targetType, emitFinish);
                default:
                    return panic(`Stringifying ${xfer.sourceType.kind} not supported`);
            }
        }
        else if (xfer instanceof StringProducerTransformer) {
            const value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
            return this.emitConsume(value, xfer.consumer, targetType, emitFinish);
        }
        else if (xfer instanceof MinMaxLengthCheckTransformer) {
            const min = xfer.minLength;
            const max = xfer.maxLength;
            const conditions = [];
            if (min !== undefined) {
                conditions.push([variable, ".Length >= ", min.toString()]);
            }
            if (max !== undefined) {
                conditions.push([variable, ".Length <= ", max.toString()]);
            }
            this.emitLine("if (", collectionUtils.arrayIntercalate([" && "], conditions), ")");
            this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
            return false;
        }
        else if (xfer instanceof MinMaxValueTransformer) {
            const min = xfer.minimum;
            const max = xfer.maximum;
            const conditions = [];
            if (min !== undefined) {
                conditions.push([variable, " >= ", min.toString()]);
            }
            if (max !== undefined) {
                conditions.push([variable, " <= ", max.toString()]);
            }
            this.emitLine("if (", collectionUtils.arrayIntercalate([" && "], conditions), ")");
            this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
            return false;
        }
        else if (xfer instanceof UnionInstantiationTransformer) {
            if (!(targetType instanceof UnionType)) {
                return panic("Union instantiation transformer must produce a union type");
            }
            const maybeNullable = nullableFromUnion(targetType);
            if (maybeNullable !== null) {
                emitFinish(variable);
            }
            else {
                const unionName = this.nameForNamedType(targetType);
                let initializer;
                if (xfer.sourceType.kind === "null") {
                    initializer = " ";
                }
                else {
                    const memberName = this.nameForUnionMember(targetType, xfer.sourceType);
                    initializer = [" ", memberName, " = ", variable, " "];
                }
                emitFinish(["new ", unionName, " {", initializer, "}"]);
            }
            return true;
        }
        else {
            return panic("Unknown transformer");
        }
        return false;
    }
    emitTransformation(converterName, t) {
        const xf = defined(transformationForType(t));
        const reverse = xf.reverse;
        const targetType = xf.targetType;
        const xfer = xf.transformer;
        this.emitType(undefined, AccessModifier.Internal, "class", converterName, "JsonConverter", () => {
            const csType = this.csType(targetType);
            let canConvertExpr = ["t == typeof(", csType, ")"];
            const haveNullable = isValueType$1(targetType);
            if (haveNullable) {
                canConvertExpr = [canConvertExpr, " || t == typeof(", csType, "?)"];
            }
            this.emitCanConvert(canConvertExpr);
            this.ensureBlankLine();
            this.emitReadJson(() => {
                // FIXME: It's unsatisfying that we need this.  The reason is that we not
                // only match T, but also T?.  If we didn't, then the T in T? would not be
                // deserialized with our converter but with the default one.  Can we check
                // whether the type is a nullable?
                // FIXME: This could duplicate one of the cases handled below in
                // `emitDecodeTransformer`.
                if (haveNullable && !(targetType instanceof UnionType)) {
                    this.emitLine("if (reader.TokenType == JsonToken.Null) return null;");
                }
                const allHandled = this.emitDecodeTransformer(xfer, targetType, v => this.emitLine("return ", v, ";"));
                if (!allHandled) {
                    this.emitThrow(['"Cannot unmarshal type ', csType, '"']);
                }
            });
            this.ensureBlankLine();
            this.emitWriteJson("untypedValue", () => {
                // FIXME: See above.
                if (haveNullable && !(targetType instanceof UnionType)) {
                    this.emitLine("if (untypedValue == null)");
                    this.emitBlock(() => {
                        this.emitLine("serializer.Serialize(writer, null);");
                        this.emitLine("return;");
                    });
                }
                this.emitLine("var value = (", csType, ")untypedValue;");
                const allHandled = this.emitTransformer("value", reverse.transformer, reverse.targetType, () => this.emitLine("return;"));
                if (!allHandled) {
                    this.emitThrow(['"Cannot marshal type ', csType, '"']);
                }
            });
            this.ensureBlankLine();
            this.emitLine("public static readonly ", converterName, " Singleton = new ", converterName, "();");
        });
    }
    emitRequiredHelpers() {
        if (this._needHelpers) {
            this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitFromJsonForTopLevel(t, n));
            this.ensureBlankLine();
            this.emitSerializeClass();
        }
        if (this._needHelpers || (this._needAttributes && (this.haveNamedUnions || this.haveEnums))) {
            this.ensureBlankLine();
            this.emitConverterClass();
            this.forEachTransformation("leading-and-interposing", (n, t) => this.emitTransformation(n, t));
        }
    }
    needNamespace() {
        return this._needNamespaces;
    }
}
const systemTextJsonCSharpOptions = Object.assign({}, cSharpOptions, {});
class SystemTextJsonCSharpRenderer extends CSharpRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext, _options);
        this._options = _options;
        this._enumExtensionsNames = new Map();
        this._needHelpers = _options.features.helpers;
        this._needAttributes = _options.features.attributes;
        this._needNamespaces = _options.features.namespaces;
    }
    forbiddenNamesForGlobalNamespace() {
        const forbidden = [
            "Converter",
            "JsonConverter",
            "JsonSerializer",
            "JsonWriter",
            "JsonToken",
            "Serialize",
            "JsonSerializerOptions",
            // "Newtonsoft",
            // "MetadataPropertyHandling",
            // "DateParseHandling",
            "FromJson",
            "Required"
        ];
        if (this._options.dense) {
            forbidden.push("J", "R", "N");
        }
        if (this._options.baseclass !== undefined) {
            forbidden.push(this._options.baseclass);
        }
        return super.forbiddenNamesForGlobalNamespace().concat(forbidden);
    }
    forbiddenForObjectProperties(c, className) {
        const result = super.forbiddenForObjectProperties(c, className);
        result.names = result.names.concat(["ToJson", "FromJson", "Required"]);
        return result;
    }
    makeNameForTransformation(xf, typeName) {
        if (typeName === undefined) {
            let xfer = xf.transformer;
            if (xfer instanceof DecodingTransformer && xfer.consumer !== undefined) {
                xfer = xfer.consumer;
            }
            return new SimpleName([`${xfer.kind}_converter`], namingFunction$3, inferredNameOrder + 30);
        }
        return new DependencyName(namingFunction$3, typeName.order + 30, lookup => `${lookup(typeName)}_converter`);
    }
    makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof EnumType))
            return [];
        const extensionsName = new DependencyName(namingFunction$3, name.order + 30, lookup => `${lookup(name)}_extensions`);
        this._enumExtensionsNames.set(name, extensionsName);
        return [extensionsName];
    }
    emitUsings() {
        // FIXME: We need System.Collections.Generic whenever we have maps or use List.
        if (!this._needAttributes && !this._needHelpers)
            return;
        super.emitUsings();
        this.ensureBlankLine();
        for (const ns of ["System.Text.Json", "System.Text.Json.Serialization", "System.Globalization"]) {
            this.emitUsing(ns);
        }
        if (this._options.dense) {
            this.emitUsing([denseJsonPropertyName, " = System.Text.Json.Serialization.JsonPropertyNameAttribute"]);
            // this.emitUsing([denseRequiredEnumName, " = Newtonsoft.Json.Required"]);
            this.emitUsing([denseNullValueHandlingEnumName, " = System.Text.Json.Serialization.JsonIgnoreCondition"]);
        }
        if (this._options.baseclass === "EntityData") {
            this.emitUsing("Microsoft.Azure.Mobile.Server");
        }
    }
    baseclassForType(_t) {
        return this._options.baseclass;
    }
    emitDefaultFollowingComments() {
        if (!this._needHelpers)
            return;
        this.emitLine("#pragma warning restore CS8618");
        this.emitLine("#pragma warning restore CS8601");
        this.emitLine("#pragma warning restore CS8603");
    }
    emitDefaultLeadingComments() {
        if (!this._needHelpers)
            return;
        this.emitLine("// <auto-generated />");
        this.emitLine("//");
        this.emitLine("// To parse this JSON data, add NuGet 'System.Text.Json' then do", this.topLevels.size === 1 ? "" : " one of these", ":");
        this.emitLine("//");
        this.emitLine("//    using ", this._options.namespace, ";");
        this.emitLine("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
            let rhs;
            if (t instanceof EnumType) {
                rhs = ["JsonSerializer.Deserialize<", topLevelName, ">(jsonString)"];
            }
            else {
                rhs = [topLevelName, ".FromJson(jsonString)"];
            }
            this.emitLine("//    var ", modifySource(camelCase, topLevelName), " = ", rhs, ";");
        });
        // fix: should this be an option? Or respond to an existing option?
        this.emitLine("#nullable enable");
        this.emitLine("#pragma warning disable CS8618");
        this.emitLine("#pragma warning disable CS8601");
        this.emitLine("#pragma warning disable CS8603");
    }
    converterForType(t) {
        let xf = transformationForType(t);
        if (xf === undefined && t instanceof UnionType) {
            const maybeNullable = nullableFromUnion(t);
            if (maybeNullable !== null) {
                t = maybeNullable;
                xf = transformationForType(t);
            }
        }
        if (xf === undefined)
            return undefined;
        if (alwaysApplyTransformation(xf))
            return undefined;
        return defined(this.nameForTransformation(t));
    }
    attributesForProperty(property, _name, _c, jsonName) {
        if (!this._needAttributes)
            return undefined;
        const attributes = [];
        const jsonPropertyName = this._options.dense ? denseJsonPropertyName : "JsonPropertyName";
        const escapedName = utf16StringEscape(jsonName);
        const isNullable = followTargetType(property.type).isNullable;
        const isOptional = property.isOptional;
        if (isOptional && !isNullable) {
            attributes.push(["[", "JsonIgnore", "(Condition = JsonIgnoreCondition.WhenWritingNull)]"]);
        }
        // const requiredClass = this._options.dense ? "R" : "Required";
        // const nullValueHandlingClass = this._options.dense ? "N" : "NullValueHandling";
        // const nullValueHandling = isOptional && !isNullable ? [", NullValueHandling = ", nullValueHandlingClass, ".Ignore"] : [];
        // let required: Sourcelike;
        // if (!this._options.checkRequired || (isOptional && isNullable)) {
        //     required = [nullValueHandling];
        // } else if (isOptional && !isNullable) {
        //     required = [", Required = ", requiredClass, ".DisallowNull", nullValueHandling];
        // } else if (!isOptional && isNullable) {
        //     required = [", Required = ", requiredClass, ".AllowNull"];
        // } else {
        //     required = [", Required = ", requiredClass, ".Always", nullValueHandling];
        // }
        attributes.push(["[", jsonPropertyName, '("', escapedName, '")]']);
        const converter = this.converterForType(property.type);
        if (converter !== undefined) {
            attributes.push(["[JsonConverter(typeof(", converter, "))]"]);
        }
        return attributes;
    }
    blankLinesBetweenAttributes() {
        return this._needAttributes && !this._options.dense;
    }
    // The "this" type can't be `dynamic`, so we have to force it to `object`.
    topLevelResultType(t) {
        return t.kind === "any" || t.kind === "none" ? "object" : this.csType(t);
    }
    emitFromJsonForTopLevel(t, name) {
        if (t instanceof EnumType)
            return;
        let partial;
        let typeKind;
        const definedType = this.namedTypeToNameForTopLevel(t);
        if (definedType !== undefined) {
            partial = "partial ";
            typeKind = definedType instanceof ClassType ? "class" : "struct";
        }
        else {
            partial = "";
            typeKind = "class";
        }
        const csType = this.topLevelResultType(t);
        this.emitType(undefined, AccessModifier.Public, [partial, typeKind], name, this.baseclassForType(t), () => {
            // FIXME: Make FromJson a Named
            this.emitExpressionMember(["public static ", csType, " FromJson(string json)"], ["JsonSerializer.Deserialize<", csType, ">(json, ", this._options.namespace, ".Converter.Settings)"]);
        });
    }
    emitDecoderSwitch(emitBody) {
        this.emitLine("switch (reader.TokenType)");
        this.emitBlock(emitBody);
    }
    emitTokenCase(tokenType) {
        this.emitLine("case JsonTokenType.", tokenType, ":");
    }
    emitThrow(message) {
        this.emitLine("throw new Exception(", message, ");");
    }
    deserializeTypeCode(typeName) {
        switch (typeName) {
            case "bool":
                return ["reader.GetBoolean()"];
            case "long":
                return ["reader.GetInt64()"];
            case "decimal":
                return ["reader.GetDecimal()"];
            case "double":
                return ["reader.GetDouble()"];
            case "string":
                return ["reader.GetString()"];
            default:
                return ["JsonSerializer.Deserialize<", typeName, ">(ref reader, options)"];
        }
    }
    serializeValueCode(value) {
        if (value !== "null")
            return ["JsonSerializer.Serialize(writer, ", value, ", options)"];
        else
            return ["writer.WriteNullValue()"];
    }
    emitSerializeClass() {
        // FIXME: Make Serialize a Named
        this.emitType(undefined, AccessModifier.Public, "static class", "Serialize", undefined, () => {
            // Sometimes multiple top-levels will resolve to the same type, so we have to take care
            // not to emit more than one extension method for the same type.
            const seenTypes = new Set();
            this.forEachTopLevel("none", t => {
                // FIXME: Make ToJson a Named
                if (!seenTypes.has(t)) {
                    seenTypes.add(t);
                    this.emitExpressionMember(["public static string ToJson(this ", this.topLevelResultType(t), " self)"], ["JsonSerializer.Serialize(self, ", this._options.namespace, ".Converter.Settings)"]);
                }
            });
        });
    }
    emitCanConvert(expr) {
        this.emitExpressionMember("public override bool CanConvert(Type t)", expr);
    }
    emitReadJson(emitBody, csType) {
        this.emitLine("public override ", csType, " Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)");
        this.emitBlock(emitBody);
    }
    emitWriteJson(variable, emitBody, csType) {
        this.emitLine("public override void Write(Utf8JsonWriter writer, ", csType, " ", variable, ", JsonSerializerOptions options)");
        this.emitBlock(emitBody);
    }
    converterObject(converterName) {
        // FIXME: Get a singleton
        return [converterName, ".Singleton"];
    }
    emitConverterClass() {
        // FIXME: Make Converter a Named
        const converterName = ["Converter"];
        this.emitType(undefined, AccessModifier.Internal, "static class", converterName, undefined, () => {
            // Do not use .Web as defaults. That turns on caseInsensitive property names and will fail the keywords test.
            this.emitLine("public static readonly JsonSerializerOptions Settings = new(JsonSerializerDefaults.General)");
            this.emitBlock(() => {
                // this.emitLine("MetadataPropertyHandling = MetadataPropertyHandling.Ignore,");
                // this.emitLine("DateParseHandling = DateParseHandling.None,");
                this.emitLine("Converters =");
                this.emitLine("{");
                this.indent(() => {
                    for (const [t, converter] of this.typesWithNamedTransformations) {
                        if (alwaysApplyTransformation(defined(transformationForType(t)))) {
                            this.emitLine(this.converterObject(converter), ",");
                        }
                    }
                    this.emitLine("new DateOnlyConverter(),");
                    this.emitLine("new TimeOnlyConverter(),");
                    this.emitLine("IsoDateTimeOffsetConverter.Singleton");
                    // this.emitLine("new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }");
                });
                this.emitLine("},");
            }, true);
        });
    }
    emitDecoderTransformerCase(tokenCases, variableName, xfer, targetType, emitFinish) {
        if (xfer === undefined)
            return;
        for (const tokenCase of tokenCases) {
            this.emitTokenCase(tokenCase);
        }
        this.indent(() => {
            const allHandled = this.emitDecodeTransformer(xfer, targetType, emitFinish, variableName);
            if (!allHandled) {
                this.emitLine("break;");
            }
        });
    }
    emitConsume(value, consumer, targetType, emitFinish) {
        if (consumer === undefined) {
            emitFinish(value);
            return true;
        }
        else {
            return this.emitTransformer(value, consumer, targetType, emitFinish);
        }
    }
    emitDecodeTransformer(xfer, targetType, emitFinish, variableName = "value") {
        if (xfer instanceof DecodingTransformer) {
            const source = xfer.sourceType;
            const converter = this.converterForType(targetType);
            if (converter !== undefined) {
                const typeSource = this.csType(targetType);
                this.emitLine("var converter = ", this.converterObject(converter), ";");
                this.emitLine("var ", variableName, " = (", typeSource, ")converter.ReadJson(reader, typeof(", typeSource, "), null, serializer);");
            }
            else if (source.kind !== "null") {
                let output = targetType.kind === "double" ? targetType : source;
                this.emitLine("var ", variableName, " = ", this.deserializeTypeCode(this.csType(output)), ";");
            }
            return this.emitConsume(variableName, xfer.consumer, targetType, emitFinish);
        }
        else if (xfer instanceof ArrayDecodingTransformer) {
            // FIXME: Consume StartArray
            if (!(targetType instanceof ArrayType)) {
                return panic("Array decoding must produce an array type");
            }
            // FIXME: handle EOF
            this.emitLine("reader.Read();");
            this.emitLine("var ", variableName, " = new List<", this.csType(targetType.items), ">();");
            this.emitLine("while (reader.TokenType != JsonToken.EndArray)");
            this.emitBlock(() => {
                this.emitDecodeTransformer(xfer.itemTransformer, xfer.itemTargetType, v => this.emitLine(variableName, ".Add(", v, ");"), "arrayItem");
                // FIXME: handle EOF
                this.emitLine("reader.Read();");
            });
            let result = variableName;
            if (!this._options.useList) {
                result = [result, ".ToArray()"];
            }
            emitFinish(result);
            return true;
        }
        else if (xfer instanceof DecodingChoiceTransformer) {
            this.emitDecoderSwitch(() => {
                const nullTransformer = xfer.nullTransformer;
                if (nullTransformer !== undefined) {
                    this.emitTokenCase("Null");
                    this.indent(() => {
                        const allHandled = this.emitDecodeTransformer(nullTransformer, targetType, emitFinish, "null");
                        if (!allHandled) {
                            this.emitLine("break");
                        }
                    });
                }
                this.emitDecoderTransformerCase(["Number"], "integerValue", xfer.integerTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["Number"], 
                // xfer.integerTransformer === undefined ? ["Integer", "Float"] : ["Float"],
                "doubleValue", xfer.doubleTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["True", "False"], "boolValue", xfer.boolTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(
                // ["String", "Date"],
                ["String"], "stringValue", xfer.stringTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["StartObject"], "objectValue", xfer.objectTransformer, targetType, emitFinish);
                this.emitDecoderTransformerCase(["StartArray"], "arrayValue", xfer.arrayTransformer, targetType, emitFinish);
            });
            return false;
        }
        else {
            return panic("Unknown transformer");
        }
    }
    stringCaseValue(t, stringCase) {
        if (t.kind === "string") {
            return ['"', utf16StringEscape(stringCase), '"'];
        }
        else if (t instanceof EnumType) {
            return [this.nameForNamedType(t), ".", this.nameForEnumCase(t, stringCase)];
        }
        return panic(`Type ${t.kind} does not have string cases`);
    }
    emitTransformer(variable, xfer, targetType, emitFinish) {
        function directTargetType(continuation) {
            if (continuation === undefined) {
                return targetType;
            }
            return followTargetType(continuation.sourceType);
        }
        if (xfer instanceof ChoiceTransformer) {
            const caseXfers = xfer.transformers;
            if (caseXfers.length > 1 && caseXfers.every(caseXfer => caseXfer instanceof StringMatchTransformer)) {
                this.emitLine("switch (", variable, ")");
                this.emitBlock(() => {
                    for (const caseXfer of caseXfers) {
                        const matchXfer = caseXfer;
                        const value = this.stringCaseValue(followTargetType(matchXfer.sourceType), matchXfer.stringCase);
                        this.emitLine("case ", value, ":");
                        this.indent(() => {
                            const allDone = this.emitTransformer(variable, matchXfer.transformer, targetType, emitFinish);
                            if (!allDone) {
                                this.emitLine("break;");
                            }
                        });
                    }
                });
                // FIXME: Can we check for exhaustiveness?  For enums it should be easy.
                return false;
            }
            else {
                for (const caseXfer of caseXfers) {
                    this.emitTransformer(variable, caseXfer, targetType, emitFinish);
                }
            }
        }
        else if (xfer instanceof UnionMemberMatchTransformer) {
            const memberType = xfer.memberType;
            const maybeNullable = nullableFromUnion(xfer.sourceType);
            let test;
            let member;
            if (maybeNullable !== null) {
                if (memberType.kind === "null") {
                    test = [variable, " == null"];
                    member = "null";
                }
                else {
                    test = [variable, " != null"];
                    member = variable;
                }
            }
            else if (memberType.kind === "null") {
                test = [variable, ".IsNull"];
                member = "null";
            }
            else {
                const memberName = this.nameForUnionMember(xfer.sourceType, memberType);
                member = [variable, ".", memberName];
                test = [member, " != null"];
            }
            if (memberType.kind !== "null" && isValueType$1(memberType)) {
                member = [member, ".Value"];
            }
            this.emitLine("if (", test, ")");
            this.emitBlock(() => this.emitTransformer(member, xfer.transformer, targetType, emitFinish));
        }
        else if (xfer instanceof StringMatchTransformer) {
            const value = this.stringCaseValue(followTargetType(xfer.sourceType), xfer.stringCase);
            this.emitLine("if (", variable, " == ", value, ")");
            this.emitBlock(() => this.emitTransformer(variable, xfer.transformer, targetType, emitFinish));
        }
        else if (xfer instanceof EncodingTransformer) {
            const converter = this.converterForType(xfer.sourceType);
            if (converter !== undefined) {
                this.emitLine("var converter = ", this.converterObject(converter), ";");
                this.emitLine("converter.WriteJson(writer, ", variable, ", serializer);");
            }
            else {
                this.emitLine(this.serializeValueCode(variable), ";");
            }
            emitFinish([]);
            return true;
        }
        else if (xfer instanceof ArrayEncodingTransformer) {
            this.emitLine("writer.WriteStartArray();");
            const itemVariable = "arrayItem";
            this.emitLine("foreach (var ", itemVariable, " in ", variable, ")");
            this.emitBlock(() => {
                this.emitTransformer(itemVariable, xfer.itemTransformer, xfer.itemTargetType, () => {
                    return;
                });
            });
            this.emitLine("writer.WriteEndArray();");
            emitFinish([]);
            return true;
        }
        else if (xfer instanceof ParseStringTransformer) {
            const immediateTargetType = xfer.consumer === undefined ? targetType : xfer.consumer.sourceType;
            switch (immediateTargetType.kind) {
                case "date-time":
                    this.emitLine("DateTimeOffset dt;");
                    this.emitLine("if (DateTimeOffset.TryParse(", variable, ", out dt))");
                    this.emitBlock(() => this.emitConsume("dt", xfer.consumer, targetType, emitFinish));
                    break;
                case "uuid":
                    this.emitLine("Guid guid;");
                    this.emitLine("if (Guid.TryParse(", variable, ", out guid))");
                    this.emitBlock(() => this.emitConsume("guid", xfer.consumer, targetType, emitFinish));
                    break;
                case "uri":
                    this.emitLine("try");
                    this.emitBlock(() => {
                        // this.emitLine("var uri = new Uri(", variable, ");");
                        // The default value about:blank should never happen, but this way we avoid a null reference warning.
                        this.emitLine('var uri = new Uri("about:blank");');
                        this.emitLine("if (!string.IsNullOrEmpty(stringValue))");
                        this.emitBlock(() => {
                            this.emitLine("uri = new Uri(", variable, ");");
                        });
                        this.emitConsume("uri", xfer.consumer, targetType, emitFinish);
                    });
                    this.emitLine("catch (UriFormatException) {}");
                    break;
                case "integer":
                    this.emitLine("long l;");
                    this.emitLine("if (Int64.TryParse(", variable, ", out l))");
                    this.emitBlock(() => this.emitConsume("l", xfer.consumer, targetType, emitFinish));
                    break;
                case "bool":
                    this.emitLine("bool b;");
                    this.emitLine("if (Boolean.TryParse(", variable, ", out b))");
                    this.emitBlock(() => this.emitConsume("b", xfer.consumer, targetType, emitFinish));
                    break;
                default:
                    return panic(`Parsing string to ${immediateTargetType.kind} not supported`);
            }
        }
        else if (xfer instanceof StringifyTransformer) {
            switch (xfer.sourceType.kind) {
                case "date-time":
                    return this.emitConsume([variable, '.ToString("o", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
                case "uuid":
                    return this.emitConsume([variable, '.ToString("D", System.Globalization.CultureInfo.InvariantCulture)'], xfer.consumer, targetType, emitFinish);
                case "integer":
                case "uri":
                    return this.emitConsume([variable, ".ToString()"], xfer.consumer, targetType, emitFinish);
                case "bool":
                    this.emitLine("var boolString = ", variable, ' ? "true" : "false";');
                    return this.emitConsume("boolString", xfer.consumer, targetType, emitFinish);
                default:
                    return panic(`Stringifying ${xfer.sourceType.kind} not supported`);
            }
        }
        else if (xfer instanceof StringProducerTransformer) {
            const value = this.stringCaseValue(directTargetType(xfer.consumer), xfer.result);
            return this.emitConsume(value, xfer.consumer, targetType, emitFinish);
        }
        else if (xfer instanceof MinMaxLengthCheckTransformer) {
            const min = xfer.minLength;
            const max = xfer.maxLength;
            const conditions = [];
            if (min !== undefined) {
                conditions.push([variable, ".Length >= ", min.toString()]);
            }
            if (max !== undefined) {
                conditions.push([variable, ".Length <= ", max.toString()]);
            }
            this.emitLine("if (", collectionUtils.arrayIntercalate([" && "], conditions), ")");
            this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
            return false;
        }
        else if (xfer instanceof MinMaxValueTransformer) {
            const min = xfer.minimum;
            const max = xfer.maximum;
            const conditions = [];
            if (min !== undefined) {
                conditions.push([variable, " >= ", min.toString()]);
            }
            if (max !== undefined) {
                conditions.push([variable, " <= ", max.toString()]);
            }
            this.emitLine("if (", collectionUtils.arrayIntercalate([" && "], conditions), ")");
            this.emitBlock(() => this.emitConsume(variable, xfer.consumer, targetType, emitFinish));
            return false;
        }
        else if (xfer instanceof UnionInstantiationTransformer) {
            if (!(targetType instanceof UnionType)) {
                return panic("Union instantiation transformer must produce a union type");
            }
            const maybeNullable = nullableFromUnion(targetType);
            if (maybeNullable !== null) {
                emitFinish(variable);
            }
            else {
                const unionName = this.nameForNamedType(targetType);
                let initializer;
                if (xfer.sourceType.kind === "null") {
                    initializer = " ";
                }
                else {
                    const memberName = this.nameForUnionMember(targetType, xfer.sourceType);
                    initializer = [" ", memberName, " = ", variable, " "];
                }
                emitFinish(["new ", unionName, " {", initializer, "}"]);
            }
            return true;
        }
        else {
            return panic("Unknown transformer");
        }
        return false;
    }
    emitTransformation(converterName, t) {
        const xf = defined(transformationForType(t));
        const reverse = xf.reverse;
        const targetType = xf.targetType;
        const xfer = xf.transformer;
        const csType = this.csType(targetType);
        // const haveNullable = isValueType(targetType);
        // if (haveNullable) {
        //     converterName = ['Nullable', converterName];
        //     csType = [csType, "?"];
        // }
        this.emitType(undefined, AccessModifier.Internal, "class", converterName, ["JsonConverter<", csType, ">"], () => {
            let canConvertExpr = ["t == typeof(", csType, ")"];
            this.emitCanConvert(canConvertExpr);
            this.ensureBlankLine();
            this.emitReadJson(() => {
                // FIXME: It's unsatisfying that we need this.  The reason is that we not
                // only match T, but also T?.  If we didn't, then the T in T? would not be
                // deserialized with our converter but with the default one.  Can we check
                // whether the type is a nullable?
                // FIXME: This could duplicate one of the cases handled below in
                // `emitDecodeTransformer`.
                // if (haveNullable && !(targetType instanceof UnionType)) {
                //     this.emitLine("if (reader.TokenType == JsonTokenType.Null) return null;");
                // }
                const allHandled = this.emitDecodeTransformer(xfer, targetType, v => this.emitLine("return ", v, ";"));
                if (!allHandled) {
                    this.emitThrow(['"Cannot unmarshal type ', csType, '"']);
                }
            }, csType);
            this.ensureBlankLine();
            this.emitWriteJson("value", () => {
                // FIXME: See above.
                // if (haveNullable && !(targetType instanceof UnionType)) {
                //     this.emitLine("if (value == null)");
                //     this.emitBlock(() => {
                //         this.emitLine("writer.WriteNullValue();");
                //         this.emitLine("return;");
                //     });
                // }
                const allHandled = this.emitTransformer("value", reverse.transformer, reverse.targetType, () => this.emitLine("return;"));
                if (!allHandled) {
                    this.emitThrow(['"Cannot marshal type ', csType, '"']);
                }
            }, csType);
            this.ensureBlankLine();
            this.emitLine("public static readonly ", converterName, " Singleton = new ", converterName, "();");
        });
    }
    emitRequiredHelpers() {
        if (this._needHelpers) {
            this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitFromJsonForTopLevel(t, n));
            this.ensureBlankLine();
            this.emitSerializeClass();
        }
        if (this._needHelpers || (this._needAttributes && (this.haveNamedUnions || this.haveEnums))) {
            this.ensureBlankLine();
            this.emitConverterClass();
            this.forEachTransformation("leading-and-interposing", (n, t) => this.emitTransformation(n, t));
            this.emitMultiline(`
public class DateOnlyConverter : JsonConverter<DateOnly>
{
    private readonly string serializationFormat;
    public DateOnlyConverter() : this(null) { }

    public DateOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "yyyy-MM-dd";
    }

    public override DateOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return DateOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, DateOnly value, JsonSerializerOptions options)
        => writer.WriteStringValue(value.ToString(serializationFormat));
}

public class TimeOnlyConverter : JsonConverter<TimeOnly>
{
    private readonly string serializationFormat;

    public TimeOnlyConverter() : this(null) { }

    public TimeOnlyConverter(string? serializationFormat)
    {
        this.serializationFormat = serializationFormat ?? "HH:mm:ss.fff";
    }

    public override TimeOnly Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        var value = reader.GetString();
        return TimeOnly.Parse(value!);
    }

    public override void Write(Utf8JsonWriter writer, TimeOnly value, JsonSerializerOptions options)
        => writer.WriteStringValue(value.ToString(serializationFormat));
}

internal class IsoDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
{
    public override bool CanConvert(Type t) => t == typeof(DateTimeOffset);

    private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

    private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
    private string? _dateTimeFormat;
    private CultureInfo? _culture;

    public DateTimeStyles DateTimeStyles
    {
        get => _dateTimeStyles;
        set => _dateTimeStyles = value;
    }

    public string? DateTimeFormat
    {
        get => _dateTimeFormat ?? string.Empty;
        set => _dateTimeFormat = (string.IsNullOrEmpty(value)) ? null : value;
    }

    public CultureInfo Culture
    {
        get => _culture ?? CultureInfo.CurrentCulture;
        set => _culture = value;
    }

    public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
    {
        string text;


        if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal
            || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
        {
            value = value.ToUniversalTime();
        }

        text = value.ToString(_dateTimeFormat ?? DefaultDateTimeFormat, Culture);

        writer.WriteStringValue(text);
    }

    public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        string? dateText = reader.GetString();
        
        if (string.IsNullOrEmpty(dateText) == false)
        {
            if (!string.IsNullOrEmpty(_dateTimeFormat))
            {
                return DateTimeOffset.ParseExact(dateText, _dateTimeFormat, Culture, _dateTimeStyles);
            }
            else
            {
                return DateTimeOffset.Parse(dateText, Culture, _dateTimeStyles);
            }
        }
        else
        {
            return default(DateTimeOffset);
        }
    }


    public static readonly IsoDateTimeOffsetConverter Singleton = new IsoDateTimeOffsetConverter();
}`);
        }
    }
    needNamespace() {
        return this._needNamespaces;
    }
}

const dartOptions = {
    nullSafety: new BooleanOption("null-safety", "Null Safety", true),
    justTypes: new BooleanOption("just-types", "Types only", false),
    codersInClass: new BooleanOption("coders-in-class", "Put encoder & decoder in Class", false),
    methodNamesWithMap: new BooleanOption("from-map", "Use method names fromMap() & toMap()", false, "secondary"),
    requiredProperties: new BooleanOption("required-props", "Make all properties required", false),
    finalProperties: new BooleanOption("final-props", "Make all properties final", false),
    generateCopyWith: new BooleanOption("copy-with", "Generate CopyWith method", false),
    useFreezed: new BooleanOption("use-freezed", "Generate class definitions with @freezed compatibility", false, "secondary"),
    useHive: new BooleanOption("use-hive", "Generate annotations for Hive type adapters", false, "secondary"),
    useJsonAnnotation: new BooleanOption("use-json-annotation", "Generate annotations for json_serializable", false, "secondary"),
    partName: new StringOption("part-name", "Use this name in `part` directive", "NAME", "", "secondary")
};
class DartTargetLanguage extends TargetLanguage {
    constructor() {
        super("Dart", ["dart"], "dart");
    }
    getOptions() {
        return [
            dartOptions.nullSafety,
            dartOptions.justTypes,
            dartOptions.codersInClass,
            dartOptions.methodNamesWithMap,
            dartOptions.requiredProperties,
            dartOptions.finalProperties,
            dartOptions.generateCopyWith,
            dartOptions.useFreezed,
            dartOptions.useHive,
            dartOptions.useJsonAnnotation,
            dartOptions.partName
        ];
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    get stringTypeMapping() {
        const mapping = new Map();
        mapping.set("date", "date");
        mapping.set("date-time", "date-time");
        return mapping;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(dartOptions, untypedOptionValues);
        return new DartRenderer(this, renderContext, options);
    }
}
const keywords$8 = [
    "abstract",
    "do",
    "import",
    "super",
    "as",
    "dynamic",
    "in",
    "switch",
    "assert",
    "else",
    "interface",
    "sync*",
    "async",
    "enum",
    "is",
    "this",
    "async*",
    "export",
    "library",
    "throw",
    "await",
    "external",
    "mixin",
    "true",
    "break",
    "extends",
    "new",
    "try",
    "case",
    "factory",
    "null",
    "typedef",
    "catch",
    "false",
    "operator",
    "var",
    "class",
    "final",
    "part",
    "void",
    "const",
    "finally",
    "rethrow",
    "while",
    "continue",
    "for",
    "return",
    "with",
    "covariant",
    "get",
    "set",
    "yield",
    "default",
    "if",
    "static",
    "yield*",
    "deferred",
    "implements",
    "int",
    "double",
    "bool",
    "Map",
    "List",
    "String",
    "File",
    "fromJson",
    "toJson",
    "fromMap",
    "toMap"
];
const typeNamingFunction = funPrefixNamer("types", n => dartNameStyle(true, false, n));
const propertyNamingFunction = funPrefixNamer("properties", n => dartNameStyle(false, false, n));
const enumCaseNamingFunction = funPrefixNamer("enum-cases", n => dartNameStyle(true, true, n));
// Escape the dollar sign, which is used in string interpolation
const stringEscape$6 = utf16ConcatMap(escapeNonPrintableMapper(cp => isPrintable(cp) && cp !== 0x24, standardUnicodeHexEscape));
function isStartCharacter$9(codePoint) {
    if (codePoint === 0x5f)
        return false; // underscore
    return isAscii(codePoint) && isLetter(codePoint);
}
function isPartCharacter$9(codePoint) {
    return isStartCharacter$9(codePoint) || (isAscii(codePoint) && isDigit(codePoint));
}
const legalizeName$g = utf16LegalizeCharacters(isPartCharacter$9);
// FIXME: Handle acronyms consistently.  In particular, that means that
// we have to use namers to produce the getter and setter names - we can't
// just capitalize and concatenate.
// https://stackoverflow.com/questions/8277355/naming-convention-for-upper-case-abbreviations
function dartNameStyle(startWithUpper, upperUnderscore, original) {
    const words = splitIntoWords(original);
    const firstWordStyle = upperUnderscore
        ? allUpperWordStyle
        : startWithUpper
            ? firstUpperWordStyle
            : allLowerWordStyle;
    const restWordStyle = upperUnderscore ? allUpperWordStyle : firstUpperWordStyle;
    return combineWords(words, legalizeName$g, firstWordStyle, restWordStyle, firstWordStyle, restWordStyle, upperUnderscore ? "_" : "", isStartCharacter$9);
}
class DartRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = new Map();
        this._needEnumValues = false;
        this.classCounter = 0;
        this.classPropertyCounter = 0;
        this._topLevelDependents = new Map();
        this._enumValues = new Map();
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$8;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return typeNamingFunction;
    }
    namerForObjectProperty() {
        return propertyNamingFunction;
    }
    makeUnionMemberNamer() {
        return propertyNamingFunction;
    }
    makeEnumCaseNamer() {
        return enumCaseNamingFunction;
    }
    unionNeedsName(u) {
        return nullableFromUnion(u) === null;
    }
    namedTypeToNameForTopLevel(type) {
        // If the top-level type doesn't contain any classes or unions
        // we have to define a class just for the `FromJson` method, in
        // emitFromJsonForTopLevel.
        return directlyReachableSingleNamedType(type);
    }
    get toJson() {
        return `to${this._options.methodNamesWithMap ? "Map" : "Json"}`;
    }
    get fromJson() {
        return `from${this._options.methodNamesWithMap ? "Map" : "Json"}`;
    }
    makeTopLevelDependencyNames(_t, name) {
        const encoder = new DependencyName(propertyNamingFunction, name.order, lookup => `${lookup(name)}_${this.toJson}`);
        const decoder = new DependencyName(propertyNamingFunction, name.order, lookup => `${lookup(name)}_${this.fromJson}`);
        this._topLevelDependents.set(name, { encoder, decoder });
        return [encoder, decoder];
    }
    makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new DependencyName(propertyNamingFunction, name.order, lookup => `get_${lookup(name)}`);
        const setterName = new DependencyName(propertyNamingFunction, name.order, lookup => `set_${lookup(name)}`);
        return [getterName, setterName];
    }
    makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
    }
    makeNamedTypeDependencyNames(t, name) {
        if (!(t instanceof EnumType))
            return [];
        const enumValue = new DependencyName(propertyNamingFunction, name.order, lookup => `${lookup(name)}_values`);
        this._enumValues.set(t, enumValue);
        return [enumValue];
    }
    emitFileHeader() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        if (this._options.justTypes)
            return;
        if (!this._options.codersInClass) {
            this.emitLine("// To parse this JSON data, do");
            this.emitLine("//");
            this.forEachTopLevel("none", (_t, name) => {
                const { decoder } = defined(this._topLevelDependents.get(name));
                this.emitLine("//     final ", modifySource(decapitalize, name), " = ", decoder, "(jsonString);");
            });
        }
        this.ensureBlankLine();
        if (this._options.requiredProperties) {
            this.emitLine("import 'package:meta/meta.dart';");
        }
        if (this._options.useFreezed) {
            this.emitLine("import 'package:freezed_annotation/freezed_annotation.dart';");
        }
        if (this._options.useHive) {
            this.emitLine("import 'package:hive/hive.dart';");
        }
        if (this._options.useJsonAnnotation && !this._options.useFreezed) {
            // The freezed annotatation import already provides the import for json_annotation
            this.emitLine("import 'package:json_annotation/json_annotation.dart';");
        }
        this.emitLine("import 'dart:convert';");
        if (this._options.useFreezed || this._options.useHive || this._options.useJsonAnnotation) {
            this.ensureBlankLine();
            const optionNameIsEmpty = this._options.partName.length === 0;
            // FIXME: This should use a `Name`, not `modifySource`
            const name = modifySource(snakeCase, optionNameIsEmpty ? [...this.topLevels.keys()][0] : this._options.partName);
            if (this._options.useFreezed) {
                this.emitLine("part '", name, ".freezed.dart';");
            }
            if (!this._options.justTypes) {
                this.emitLine("part '", name, ".g.dart';");
            }
        }
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: "///", beforeComment: "" });
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    dartType(t, withIssues = false, forceNullable = false) {
        const nullable = forceNullable || (this._options.nullSafety && t.isNullable && !this._options.requiredProperties);
        const withNullable = (s) => (nullable ? [s, "?"] : s);
        return matchType(t, _anyType => maybeAnnotated(withIssues, anyTypeIssueAnnotation, "dynamic"), _nullType => maybeAnnotated(withIssues, nullTypeIssueAnnotation, "dynamic"), _boolType => withNullable("bool"), _integerType => withNullable("int"), _doubleType => withNullable("double"), _stringType => withNullable("String"), arrayType => withNullable(["List<", this.dartType(arrayType.items, withIssues), ">"]), classType => withNullable(this.nameForNamedType(classType)), mapType => withNullable(["Map<String, ", this.dartType(mapType.values, withIssues), ">"]), enumType => withNullable(this.nameForNamedType(enumType)), unionType => {
            const maybeNullable = nullableFromUnion(unionType);
            if (maybeNullable === null) {
                return "dynamic";
            }
            return withNullable(this.dartType(maybeNullable, withIssues));
        }, transformedStringType => {
            switch (transformedStringType.kind) {
                case "date-time":
                case "date":
                    return withNullable("DateTime");
                default:
                    return withNullable("String");
            }
        });
    }
    mapList(isNullable, itemType, list, mapper) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
            return [list, " == null ? [] : ", "List<", itemType, ">.from(", list, "!.map((x) => ", mapper, "))"];
        }
        return ["List<", itemType, ">.from(", list, ".map((x) => ", mapper, "))"];
    }
    mapMap(isNullable, valueType, map, valueMapper) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
            return ["Map.from(", map, "!).map((k, v) => MapEntry<String, ", valueType, ">(k, ", valueMapper, "))"];
        }
        return ["Map.from(", map, ").map((k, v) => MapEntry<String, ", valueType, ">(k, ", valueMapper, "))"];
    }
    mapClass(isNullable, classType, dynamic) {
        if (this._options.nullSafety && isNullable && !this._options.requiredProperties) {
            return [
                dynamic,
                " == null ? null : ",
                this.nameForNamedType(classType),
                ".",
                this.fromJson,
                "(",
                dynamic,
                ")"
            ];
        }
        return [this.nameForNamedType(classType), ".", this.fromJson, "(", dynamic, ")"];
    }
    // FIXME: refactor this
    // If the first time is the unionType type, after nullableFromUnion conversion,
    // the isNullable property will become false, which is obviously wrong,
    // so add isNullable property
    // eslint-disable-next-line @typescript-eslint/default-param-last
    fromDynamicExpression(isNullable = false, t, ...dynamic) {
        return matchType(t, _anyType => dynamic, _nullType => dynamic, // FIXME: check null
        // FIXME: check null
        _boolType => dynamic, _integerType => dynamic, _doubleType => [dynamic, this._options.nullSafety ? "?.toDouble()" : ".toDouble()"], _stringType => dynamic, arrayType => this.mapList(isNullable || arrayType.isNullable, this.dartType(arrayType.items), dynamic, this.fromDynamicExpression(arrayType.items.isNullable, arrayType.items, "x")), classType => this.mapClass(isNullable || classType.isNullable, classType, dynamic), mapType => this.mapMap(mapType.isNullable || isNullable, this.dartType(mapType.values), dynamic, this.fromDynamicExpression(mapType.values.isNullable, mapType.values, "v")), enumType => {
            return [
                defined(this._enumValues.get(enumType)),
                ".map[",
                dynamic,
                this._options.nullSafety ? "]!" : "]"
            ];
        }, unionType => {
            const maybeNullable = nullableFromUnion(unionType);
            if (maybeNullable === null) {
                return dynamic;
            }
            return this.fromDynamicExpression(unionType.isNullable, maybeNullable, dynamic);
        }, transformedStringType => {
            switch (transformedStringType.kind) {
                case "date-time":
                case "date":
                    if ((transformedStringType.isNullable || isNullable) &&
                        !this._options.requiredProperties &&
                        this._options.nullSafety) {
                        return [dynamic, " == null ? null : ", "DateTime.parse(", dynamic, ")"];
                    }
                    return ["DateTime.parse(", dynamic, ")"];
                default:
                    return dynamic;
            }
        });
    }
    // FIXME: refactor this
    // If the first time is the unionType type, after nullableFromUnion conversion,
    // the isNullable property will become false, which is obviously wrong,
    // so add isNullable property
    // eslint-disable-next-line @typescript-eslint/default-param-last
    toDynamicExpression(isNullable = false, t, ...dynamic) {
        return matchType(t, _anyType => dynamic, _nullType => dynamic, _boolType => dynamic, _integerType => dynamic, _doubleType => dynamic, _stringType => dynamic, arrayType => this.mapList(arrayType.isNullable || isNullable, "dynamic", dynamic, this.toDynamicExpression(arrayType.items.isNullable, arrayType.items, "x")), _classType => {
            if (this._options.nullSafety &&
                (_classType.isNullable || isNullable) &&
                !this._options.requiredProperties) {
                return [dynamic, "?.", this.toJson, "()"];
            }
            return [dynamic, ".", this.toJson, "()"];
        }, mapType => this.mapMap(mapType.isNullable || isNullable, "dynamic", dynamic, this.toDynamicExpression(mapType.values.isNullable, mapType.values, "v")), enumType => {
            return [defined(this._enumValues.get(enumType)), ".reverse[", dynamic, "]"];
        }, unionType => {
            const maybeNullable = nullableFromUnion(unionType);
            if (maybeNullable === null) {
                return dynamic;
            }
            return this.toDynamicExpression(unionType.isNullable, maybeNullable, dynamic);
        }, transformedStringType => {
            switch (transformedStringType.kind) {
                case "date-time":
                    if (this._options.nullSafety &&
                        !this._options.requiredProperties &&
                        (transformedStringType.isNullable || isNullable)) {
                        return [dynamic, "?.toIso8601String()"];
                    }
                    return [dynamic, ".toIso8601String()"];
                case "date":
                    if (this._options.nullSafety &&
                        !this._options.requiredProperties &&
                        (transformedStringType.isNullable || isNullable)) {
                        return [
                            '"${',
                            dynamic,
                            "!.year.toString().padLeft(4, '0')",
                            "}-${",
                            dynamic,
                            "!.month.toString().padLeft(2, '0')}-${",
                            dynamic,
                            "!.day.toString().padLeft(2, '0')}\""
                        ];
                    }
                    return [
                        '"${',
                        dynamic,
                        ".year.toString().padLeft(4, '0')",
                        "}-${",
                        dynamic,
                        ".month.toString().padLeft(2, '0')}-${",
                        dynamic,
                        ".day.toString().padLeft(2, '0')}\""
                    ];
                default:
                    return dynamic;
            }
        });
    }
    _emitEmptyConstructor(className) {
        this.emitLine(className, "();");
    }
    _emitConstructor(c, className) {
        this.emitLine(className, "({");
        this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, prop) => {
                const required = this._options.requiredProperties ||
                    (this._options.nullSafety && (!prop.type.isNullable || !prop.isOptional));
                this.emitLine(required ? "required " : "", "this.", name, ",");
            });
        });
        this.emitLine("});");
        this.ensureBlankLine();
    }
    _emitVariables(c) {
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const description = this.descriptionForClassProperty(c, jsonName);
            if (description !== undefined) {
                this.emitDescription(description);
            }
            if (this._options.useHive) {
                this.classPropertyCounter++;
                this.emitLine(`@HiveField(${this.classPropertyCounter})`);
            }
            if (this._options.useJsonAnnotation) {
                this.classPropertyCounter++;
                this.emitLine(`@JsonKey(name: "${jsonName}")`);
            }
            this.emitLine(this._options.finalProperties ? "final " : "", this.dartType(p.type, true), " ", name, ";");
        });
    }
    _emitCopyConstructor(c, className) {
        this.ensureBlankLine();
        this.emitLine(className, " copyWith({");
        this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, _p) => {
                this.emitLine(this.dartType(_p.type, true, true), " ", name, ",");
            });
        });
        this.emitLine("}) => ");
        this.indent(() => {
            this.emitLine(className, "(");
            this.indent(() => {
                this.forEachClassProperty(c, "none", (name, _, _p) => {
                    this.emitLine(name, ": ", name, " ?? ", "this.", name, ",");
                });
            });
            this.emitLine(");");
        });
    }
    _emitStringJsonEncoderDecoder(className) {
        this.ensureBlankLine();
        this.emitLine("factory ", className, ".from", this._options.methodNamesWithMap ? "Json" : "RawJson", "(String str) => ", className, ".", this.fromJson, "(json.decode(str));");
        this.ensureBlankLine();
        this.emitLine("String ", this._options.methodNamesWithMap ? "toJson() => " : "toRawJson() => ", "json.encode(", this.toJson, "());");
    }
    _emitMapEncoderDecoder(c, className) {
        this.ensureBlankLine();
        this.emitLine("factory ", className, ".", this.fromJson, "(Map<String, dynamic> json) => ", className, "(");
        this.indent(() => {
            this.forEachClassProperty(c, "none", (name, jsonName, property) => {
                this.emitLine(name, ": ", this.fromDynamicExpression(property.type.isNullable, property.type, 'json["', stringEscape$6(jsonName), '"]'), ",");
            });
        });
        this.emitLine(");");
        this.ensureBlankLine();
        this.emitLine("Map<String, dynamic> ", this.toJson, "() => {");
        this.indent(() => {
            this.forEachClassProperty(c, "none", (name, jsonName, property) => {
                this.emitLine('"', stringEscape$6(jsonName), '": ', this.toDynamicExpression(property.type.isNullable, property.type, name), ",");
            });
        });
        this.emitLine("};");
    }
    emitClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        if (this._options.useHive) {
            this.classCounter++;
            this.emitLine(`@HiveType(typeId: ${this.classCounter})`);
            this.classPropertyCounter = 0;
        }
        if (this._options.useJsonAnnotation) {
            this.emitLine("@JsonSerializable()");
        }
        this.emitBlock(["class ", className], () => {
            if (c.getProperties().size === 0) {
                this._emitEmptyConstructor(className);
            }
            else {
                this._emitVariables(c);
                this.ensureBlankLine();
                this._emitConstructor(c, className);
            }
            if (this._options.generateCopyWith) {
                this._emitCopyConstructor(c, className);
            }
            if (this._options.useJsonAnnotation) {
                this.ensureBlankLine();
                this.emitLine(
                // factory PublicAnswer.fromJson(Map<String, dynamic> json) => _$PublicAnswerFromJson(json);
                "factory ", className, ".fromJson(Map<String, dynamic> json) => ", "_$", className, "FromJson(json);");
                this.ensureBlankLine();
                this.emitLine(
                // Map<String, dynamic> toJson() => _$PublicAnswerToJson(this);
                "Map<String, dynamic> toJson() => ", "_$", className, "ToJson(this);");
            }
            else {
                if (this._options.justTypes)
                    return;
                if (this._options.codersInClass) {
                    this._emitStringJsonEncoderDecoder(className);
                }
                this._emitMapEncoderDecoder(c, className);
            }
        });
    }
    emitFreezedClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("@freezed");
        this.emitBlock(["class ", className, " with _$", className], () => {
            if (c.getProperties().size === 0) {
                this.emitLine("const factory ", className, "() = _", className, ";");
            }
            else {
                this.emitLine("const factory ", className, "({");
                this.indent(() => {
                    this.forEachClassProperty(c, "none", (name, jsonName, prop) => {
                        const description = this.descriptionForClassProperty(c, jsonName);
                        if (description !== undefined) {
                            this.emitDescription(description);
                        }
                        const required = this._options.requiredProperties ||
                            (this._options.nullSafety && (!prop.type.isNullable || !prop.isOptional));
                        if (this._options.useJsonAnnotation) {
                            this.classPropertyCounter++;
                            this.emitLine(`@JsonKey(name: "${jsonName}")`);
                        }
                        this.emitLine(required ? "required " : "", this.dartType(prop.type, true), " ", name, ",");
                    });
                });
                this.emitLine("}) = _", className, ";");
            }
            if (this._options.justTypes)
                return;
            this.ensureBlankLine();
            this.emitLine(
            // factory PublicAnswer.fromJson(Map<String, dynamic> json) => _$PublicAnswerFromJson(json);
            "factory ", className, ".fromJson(Map<String, dynamic> json) => ", "_$", className, "FromJson(json);");
        });
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("enum ", enumName, " {");
        this.indent(() => {
            this.forEachEnumCase(e, "none", (name, jsonName, pos) => {
                const comma = pos === "first" || pos === "middle" ? "," : [];
                if (this._options.useJsonAnnotation) {
                    this.emitLine('@JsonValue("', stringEscape$6(jsonName), '")');
                }
                this.emitLine(name, comma);
            });
        });
        this.emitLine("}");
        if (this._options.justTypes)
            return;
        this.ensureBlankLine();
        this.emitLine("final ", defined(this._enumValues.get(e)), " = EnumValues({");
        this.indent(() => {
            this.forEachEnumCase(e, "none", (name, jsonName, pos) => {
                const comma = pos === "first" || pos === "middle" ? "," : [];
                this.emitLine('"', stringEscape$6(jsonName), '": ', enumName, ".", name, comma);
            });
        });
        this.emitLine("});");
        this._needEnumValues = true;
    }
    emitEnumValues() {
        this.ensureBlankLine();
        this.emitMultiline(`class EnumValues<T> {
    Map<String, T> map;
    late Map<T, String> reverseMap;

    EnumValues(this.map);

    Map<T, String> get reverse {
        reverseMap = map.map((k, v) => MapEntry(v, k));
        return reverseMap;
    }
}`);
    }
    _emitTopLvlEncoderDecoder() {
        this.forEachTopLevel("leading-and-interposing", (t, name) => {
            const { encoder, decoder } = defined(this._topLevelDependents.get(name));
            this.emitLine(this.dartType(t), " ", decoder, "(String str) => ", this.fromDynamicExpression(t.isNullable, t, "json.decode(str)"), ";");
            this.ensureBlankLine();
            this.emitLine("String ", encoder, "(", this.dartType(t), " data) => json.encode(", this.toDynamicExpression(t.isNullable, t, "data"), ");");
            // this.emitBlock(["String ", encoder, "(", this.dartType(t), " data)"], () => {
            //     this.emitJsonEncoderBlock(t);
            // });
        });
    }
    emitSourceStructure() {
        this.emitFileHeader();
        if (!this._options.justTypes && !this._options.codersInClass) {
            this._emitTopLvlEncoderDecoder();
        }
        this.forEachNamedType("leading-and-interposing", (c, n) => this._options.useFreezed ? this.emitFreezedClassDefinition(c, n) : this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (_e, _n) => {
            // We don't support this yet.
        });
        if (this._needEnumValues) {
            this.emitEnumValues();
        }
    }
}

const forbiddenModuleNames = [
    "Access",
    "Agent",
    "Any",
    "Application",
    "ArgumentError",
    "ArithmeticError",
    "Atom",
    "BadArityError",
    "BadBooleanError",
    "BadFunctionError",
    "BadMapError",
    "BadStructError",
    "Base",
    "Behaviour",
    "Bitwise",
    "Calendar",
    "CaseClauseError",
    "Code",
    "Collectable",
    "CondClauseError",
    "Config",
    "Date",
    "DateTime",
    "Dict",
    "DynamicSupervisor",
    "Enum",
    "ErlangError",
    "Exception",
    "File",
    "Float",
    "Function",
    "FunctionClauseError",
    "GenEvent",
    "GenServer",
    "HashDict",
    "HashSet",
    "IO",
    "Inspect",
    "Integer",
    "Kernel",
    "KeyError",
    "Keyword",
    "List",
    "Macro",
    "Map",
    "MapSet",
    "MatchError",
    "Module",
    "Node",
    "OptionParser",
    "Path",
    "Port",
    "Process",
    "Protocol",
    "Range",
    "Record",
    "Regex",
    "Registry",
    "RuntimeError",
    "Set",
    "Stream",
    "String",
    "StringIO",
    "Supervisor",
    "SyntaxError",
    "System",
    "SystemLimitError",
    "Task",
    "Time",
    "TokenMissingError",
    "Tuple",
    "URI",
    "UndefinedFunctionError",
    "UnicodeConversionError",
    "Version",
    "WithClauseError"
];
const reservedWords = [
    "def",
    "defmodule",
    "use",
    "import",
    "alias",
    "true",
    "false",
    "nil",
    "when",
    "and",
    "or",
    "not",
    "in",
    "fn",
    "do",
    "end",
    "catch",
    "rescue",
    "after",
    "else"
];
function unicodeEscape$3(codePoint) {
    return `\\u{${intToHex(codePoint, 0)}}`;
}
function capitalizeFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
const stringEscape$5 = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, unicodeEscape$3));
function escapeDoubleQuotes(str) {
    return str.replace(/"/g, '\\"');
}
function escapeNewLines(str) {
    return str.replace(/\n/g, "\\n");
}
const elixirOptions = {
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    namespace: new StringOption("namespace", "Specify a module namespace", "NAME", "")
};
class ElixirTargetLanguage extends TargetLanguage {
    constructor() {
        super("Elixir", ["elixir"], "ex");
    }
    getOptions() {
        return [elixirOptions.justTypes, elixirOptions.namespace];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get defaultIndentation() {
        return "  ";
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new ElixirRenderer(this, renderContext, getOptionValues(elixirOptions, untypedOptionValues));
    }
}
const isStartCharacter$8 = isLetterOrUnderscore;
function isPartCharacter$8(utf16Unit) {
    const category = $747425b437e121da$export$410364bbb673ddbc(utf16Unit);
    return ["Nd", "Pc", "Mn", "Mc"].includes(category) || isStartCharacter$8(utf16Unit);
}
const legalizeName$f = legalizeCharacters(isPartCharacter$8);
function simpleNameStyle$1(original, uppercase) {
    if (/^[0-9]+$/.test(original)) {
        original = `${original}N`;
    }
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$f, firstUpperWordStyle , firstUpperWordStyle , allUpperWordStyle, allUpperWordStyle, "", isStartCharacter$8);
}
function memberNameStyle$1(original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$f, allLowerWordStyle, allLowerWordStyle, allLowerWordStyle, allLowerWordStyle, "_", isStartCharacter$8);
}
class ElixirRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
    }
    get commentLineStart() {
        return "# ";
    }
    get needsTypeDeclarationBeforeUse() {
        return true;
    }
    canBeForwardDeclared(t) {
        return "class" === t.kind;
    }
    forbiddenNamesForGlobalNamespace() {
        return [...forbiddenModuleNames, ...reservedWords.map(word => capitalizeFirstLetter(word))];
    }
    forbiddenForObjectProperties(_c, _classNamed) {
        return { names: reservedWords, includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return new Namer("types", n => simpleNameStyle$1(n), []);
    }
    namerForObjectProperty() {
        return new Namer("properties", memberNameStyle$1, []);
    }
    makeUnionMemberNamer() {
        return new Namer("properties", memberNameStyle$1, []);
    }
    makeEnumCaseNamer() {
        return new Namer("enum-cases", n => simpleNameStyle$1(n), []);
    }
    nameForNamedTypeWithNamespace(t) {
        if (this._options.namespace) {
            return [this._options.namespace, ".", this.nameForNamedType(t)];
        }
        else {
            return [this.nameForNamedType(t)];
        }
    }
    nameWithNamespace(n) {
        if (this._options.namespace) {
            return [this._options.namespace, ".", n];
        }
        else {
            return [n];
        }
    }
    elixirType(t, isOptional = false) {
        const optional = isOptional ? " | nil" : "";
        return matchType(t, _anyType => ["any()", optional], _nullType => ["nil"], _boolType => ["boolean()", optional], _integerType => ["integer()", optional], _doubleType => ["float()", optional], _stringType => ["String.t()", optional], arrayType => ["[", this.elixirType(arrayType.items), "]", optional], classType => [this.nameForNamedTypeWithNamespace(classType), ".t()", optional], mapType => ["%{String.t() => ", this.elixirType(mapType.values), "}", optional], enumType => [this.nameForNamedTypeWithNamespace(enumType), ".t()", optional], unionType => {
            const children = [...unionType.getChildren()].map(ut => this.elixirType(ut));
            return [
                children.flatMap((element, index) => (index === children.length - 1 ? element : [element, " | "])),
                optional
            ];
        });
    }
    patternMatchClauseDecode(t, attributeName, suffix = "") {
        return matchType(t, _anyType => [], _nullType => ["def decode_", attributeName, suffix, "(value) when is_nil(value), do: value"], _boolType => ["def decode_", attributeName, suffix, "(value) when is_boolean(value), do: value"], _integerType => ["def decode_", attributeName, suffix, "(value) when is_integer(value), do: value"], _doubleType => [
            "def decode_",
            attributeName,
            suffix,
            "(value) when is_float(value), do: value\n",
            "def decode_",
            attributeName,
            suffix,
            "(value) when is_integer(value), do: value"
        ], _stringType => ["def decode_", attributeName, suffix, "(value) when is_binary(value), do: value"], _arrayType => ["def decode_", attributeName, suffix, "(value) when is_list(value), do: value"], classType => {
            const requiredAttributeArgs = [];
            this.forEachClassProperty(classType, "none", (_name, jsonName, p) => {
                if (!p.isOptional) {
                    requiredAttributeArgs.push(['"', jsonName, '" => _,']);
                }
            });
            return [
                "def decode_",
                attributeName,
                suffix,
                "(%{",
                requiredAttributeArgs,
                "} = value), do: ",
                this.nameForNamedTypeWithNamespace(classType),
                ".from_map(value)"
            ];
        }, _mapType => ["def decode_", attributeName, suffix, "(value) when is_map(value), do: value"], enumType => [
            "def decode_",
            attributeName,
            suffix,
            "(value) when is_binary(value)",
            ", do: ",
            this.nameForNamedTypeWithNamespace(enumType),
            ".decode(value)"
        ], _unionType => []);
    }
    patternMatchClauseEncode(t, attributeName, suffix = "") {
        return matchType(t, _anyType => [], _nullType => ["def encode_", attributeName, suffix, "(value) when is_nil(value), do: value"], _boolType => ["def encode_", attributeName, suffix, "(value) when is_boolean(value), do: value"], _integerType => ["def encode_", attributeName, suffix, "(value) when is_integer(value), do: value"], _doubleType => [
            "def encode_",
            attributeName,
            suffix,
            "(value) when is_float(value), do: value\n",
            "def encode_",
            attributeName,
            suffix,
            "(value) when is_integer(value), do: value"
        ], _stringType => ["def encode_", attributeName, suffix, "(value) when is_binary(value), do: value"], _arrayType => ["def encode_", attributeName, suffix, "(value) when is_list(value), do: value"], classType => {
            this.forEachClassProperty(classType, "none", (_name, jsonName, p) => {
                if (!p.isOptional) ;
            });
            return [
                "def encode_",
                attributeName,
                suffix,
                "(%",
                this.nameForNamedTypeWithNamespace(classType),
                "{} = value), do: ",
                this.nameForNamedTypeWithNamespace(classType),
                ".to_map(value)"
            ];
        }, _mapType => ["def encode_", attributeName, suffix, "(value) when is_map(value), do: value"], enumType => [
            "def encode_",
            attributeName,
            suffix,
            "(value) when is_atom(value)",
            ", do: ",
            this.nameForNamedTypeWithNamespace(enumType),
            ".encode(value)"
        ], _unionType => []);
    }
    sortAndFilterPatternMatchTypes(types) {
        return types
            .filter(type => !(type instanceof UnionType))
            .sort((a, b) => {
            if (a instanceof ClassType && !(b instanceof ClassType)) {
                return -1;
            }
            else if (b instanceof ClassType && !(a instanceof ClassType)) {
                return 1;
            }
            else if (a.kind === "bool" && b.kind !== "bool") {
                return -1;
            }
            else if (b.kind === "bool" && a.kind !== "bool") {
                return 1;
            }
            else if (a instanceof EnumType && !(b instanceof EnumType)) {
                return -1;
            }
            else if (b instanceof EnumType && !(a instanceof EnumType)) {
                return 1;
            }
            else if (a.isPrimitive() && !b.isPrimitive()) {
                return -1;
            }
            else if (b.isPrimitive() && !a.isPrimitive()) {
                return 1;
            }
            else {
                return 0;
            }
        });
    }
    emitPatternMatches(types, name, parentName, suffix = "", optional = false) {
        this.ensureBlankLine();
        let typesToMatch = this.sortAndFilterPatternMatchTypes(types);
        if (typesToMatch.length < 2) {
            return;
        }
        if (typesToMatch.find(type => type.kind === "double")) {
            typesToMatch = typesToMatch.filter(type => type.kind !== "integer");
        }
        typesToMatch.forEach(type => {
            this.emitLine(this.patternMatchClauseDecode(type, name, suffix));
        });
        if (optional && !typesToMatch.find(type => type.kind === "null")) {
            this.emitLine("def decode_", name, suffix, "(value) when is_nil(value), do: value");
        }
        this.emitLine("def decode_", name, suffix, '(_), do: {:error, "Unexpected type when decoding ', parentName, ".", name, '"}');
        this.ensureBlankLine();
        typesToMatch.forEach(type => {
            this.emitLine(this.patternMatchClauseEncode(type, name, suffix));
        });
        if (optional && !typesToMatch.find(type => type.kind === "null")) {
            this.emitLine("def encode_", name, suffix, "(value) when is_nil(value), do: value");
        }
        this.emitLine("def encode_", name, suffix, '(_), do: {:error, "Unexpected type when encoding ', parentName, ".", name, '"}');
        this.ensureBlankLine();
    }
    nameOfTransformFunction(t, name, encode = false, prefix = "") {
        let mode = "decode";
        if (encode) {
            mode = "encode";
        }
        return matchType(t, _anyType => [], _nullType => [], _boolType => [], _integerType => [], _doubleType => [], _stringType => [], _arrayType => [], classType => [this.nameForNamedTypeWithNamespace(classType), `.${encode ? "to" : "from"}_map`], _mapType => [], enumType => {
            return [this.nameForNamedTypeWithNamespace(enumType), `.${mode}`];
        }, _unionType => {
            return [`${mode}_`, name, prefix];
        });
    }
    fromDynamic(t, jsonName, name, optional = false) {
        const primitive = ['m["', jsonName, '"]'];
        return matchType(t, _anyType => primitive, _nullType => primitive, _boolType => primitive, _integerType => primitive, _doubleType => primitive, _stringType => primitive, arrayType => {
            const arrayElement = arrayType.items;
            if (arrayElement instanceof ArrayType) {
                return primitive;
            }
            else if (arrayElement.isPrimitive()) {
                return primitive;
            }
            else if (arrayElement instanceof MapType) {
                return primitive;
            }
            else {
                if (optional) {
                    return [
                        "m",
                        '["',
                        jsonName,
                        '"] && Enum.map(m["',
                        jsonName,
                        '"], &',
                        this.nameOfTransformFunction(arrayElement, name, false, "_element"),
                        "/1)"
                    ];
                }
                else {
                    return [
                        'Enum.map(m["',
                        jsonName,
                        '"], &',
                        this.nameOfTransformFunction(arrayElement, name, false, "_element"),
                        "/1)"
                    ];
                }
            }
        }, classType => [
            optional ? [primitive, " && "] : "",
            this.nameForNamedTypeWithNamespace(classType),
            ".from_map(",
            primitive,
            ")"
        ], mapType => {
            const mapValueTypes = [...mapType.values.getChildren()];
            const mapValueTypesNotPrimitive = mapValueTypes.filter(type => !(type instanceof PrimitiveType));
            if (mapValueTypesNotPrimitive.length === 0) {
                return [primitive];
            }
            else {
                if (mapType.values.kind === "union") {
                    return [
                        'm["',
                        jsonName,
                        '"]\n|> Map.new(fn {key, value} -> {key, ',
                        this.nameOfTransformFunction(mapType.values, jsonName, false),
                        "_value(value)} end)"
                    ];
                }
                else if (mapType.values instanceof EnumType || mapType.values instanceof ClassType) {
                    return [
                        'm["',
                        jsonName,
                        '"]\n|> Map.new(fn {key, value} -> {key, ',
                        this.nameOfTransformFunction(mapType.values, jsonName, false),
                        "(value)} end)"
                    ];
                }
                return [primitive];
            }
        }, enumType => {
            return [
                optional ? [primitive, " && "] : "",
                this.nameOfTransformFunction(enumType, name),
                "(",
                primitive,
                ")"
            ];
        }, unionType => {
            const unionTypes = [...unionType.getChildren()];
            const unionPrimitiveTypes = unionTypes.filter(type => type.isPrimitive());
            if (unionTypes.length === unionPrimitiveTypes.length) {
                return ['m["', jsonName, '"]'];
            }
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                if (nullable instanceof ClassType) {
                    return this.fromDynamic(nullable, jsonName, name, true);
                }
                const nullableTypes = [...nullable.getChildren()];
                if (nullableTypes.length < 2) {
                    return this.fromDynamic(nullable, jsonName, name, true);
                }
                return ['m["', jsonName, '"] && decode_', name, '(m["', jsonName, '"])'];
            }
            return ["decode_", name, '(m["', jsonName, '"])'];
        });
    }
    toDynamic(t, e, optional = false) {
        const expression = ["struct.", e];
        return matchType(t, _anyType => expression, _nullType => expression, _boolType => expression, _integerType => expression, _doubleType => expression, _stringType => expression, arrayType => {
            const arrayElement = arrayType.items;
            if (arrayElement instanceof ArrayType) {
                return expression;
            }
            if (arrayElement.isPrimitive()) {
                return expression;
            }
            else if (arrayElement instanceof MapType) {
                return expression;
            }
            else {
                if (arrayElement.kind === "array") {
                    return expression;
                }
                else {
                    if (optional) {
                        return [
                            "struct.",
                            e,
                            " && Enum.map(struct.",
                            e,
                            ", &",
                            this.nameOfTransformFunction(arrayElement, e, true, "_element"),
                            "/1)"
                        ];
                    }
                    else {
                        return [
                            "struct.",
                            e,
                            " && Enum.map(struct.",
                            e,
                            ", &",
                            this.nameOfTransformFunction(arrayElement, e, true, "_element"),
                            "/1)"
                        ];
                    }
                }
            }
        }, classType => [
            optional ? ["struct.", e, " && "] : "",
            this.nameForNamedTypeWithNamespace(classType),
            ".to_map(",
            "struct.",
            e,
            ")"
        ], mapType => {
            const mapValueTypes = [...mapType.values.getChildren()];
            const mapValueTypesNotPrimitive = mapValueTypes.filter(type => !(type instanceof PrimitiveType));
            if (mapValueTypesNotPrimitive.length === 0) {
                return [expression];
            }
            else {
                if (mapType.values.kind === "union") {
                    return [
                        "struct.",
                        e,
                        "\n|> Map.new(fn {key, value} -> {key, ",
                        this.nameOfTransformFunction(mapType.values, e, true),
                        "_value(value)} end)"
                    ];
                }
                else if (mapType.values instanceof EnumType || mapType.values instanceof ClassType) {
                    return [
                        "struct.",
                        e,
                        "\n|> Map.new(fn {key, value} -> {key, ",
                        this.nameOfTransformFunction(mapType.values, e, true),
                        "(value)} end)"
                    ];
                }
                return [expression];
            }
        }, enumType => {
            return [
                optional ? ["struct.", e, " && "] : "",
                this.nameForNamedTypeWithNamespace(enumType),
                ".encode(struct.",
                e,
                ")"
            ];
        }, unionType => {
            const unionTypes = [...unionType.getChildren()];
            const unionPrimitiveTypes = unionTypes.filter(type => type.isPrimitive());
            if (unionTypes.length === unionPrimitiveTypes.length) {
                return ["struct.", e];
            }
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                if (nullable instanceof ClassType) {
                    return this.toDynamic(nullable, e, true);
                }
                const nullableTypes = [...nullable.getChildren()];
                if (nullableTypes.length < 2) {
                    return this.toDynamic(nullable, e, true);
                }
                return ["struct.", e, " && encode_", e, "(struct.", e, ")"];
            }
            return ["encode_", e, "(struct.", e, ")"];
        });
    }
    emitBlock(source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, {
            firstLineStart: '@moduledoc """\n',
            lineStart: "",
            afterComment: '"""'
        });
    }
    emitModule(c, moduleName) {
        this.emitBlock(["defmodule ", this.nameWithNamespace(moduleName), " do"], () => {
            var _a;
            const structDescription = (_a = this.descriptionForType(c)) !== null && _a !== void 0 ? _a : [];
            const attributeDescriptions = [];
            this.forEachClassProperty(c, "none", (name, jsonName, _p) => {
                const attributeDescription = this.descriptionForClassProperty(c, jsonName);
                if (attributeDescription) {
                    attributeDescriptions.push(["- `:", name, "` - ", attributeDescription]);
                }
            });
            if (structDescription.length || attributeDescriptions.length) {
                this.emitDescription([...structDescription, ...attributeDescriptions]);
                this.ensureBlankLine();
            }
            const requiredAttributes = [];
            this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
                if (!p.isOptional) {
                    if (requiredAttributes.length === 0) {
                        requiredAttributes.push([":", name]);
                    }
                    else {
                        requiredAttributes.push([", :", name]);
                    }
                }
            });
            if (requiredAttributes.length) {
                this.emitLine(["@enforce_keys [", requiredAttributes, "]"]);
            }
            const attributeNames = [];
            this.forEachClassProperty(c, "none", (name, _jsonName, _p) => {
                if (attributeNames.length === 0) {
                    attributeNames.push([":", name]);
                }
                else {
                    attributeNames.push([", :", name]);
                }
            });
            this.emitLine(["defstruct [", attributeNames, "]"]);
            this.ensureBlankLine();
            const typeDefinitionTable = [[["@type "], ["t :: %__MODULE__{"]]];
            let count = c.getProperties().size;
            this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
                const last = --count === 0;
                const attributeRow = [
                    [],
                    ["  ", name, ": ", this.elixirType(p.type), p.isOptional ? " | nil" : "", last ? "" : ","]
                ];
                typeDefinitionTable.push(attributeRow);
            });
            typeDefinitionTable.push([[], ["}"]]);
            this.emitTable(typeDefinitionTable);
            if (this._options.justTypes) {
                return;
            }
            this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
                if (p.type.kind === "union") {
                    const unionTypes = [...p.type.getChildren()];
                    const unionPrimitiveTypes = unionTypes.filter(type => type.isPrimitive());
                    if (unionTypes.length === unionPrimitiveTypes.length) {
                        return;
                    }
                    const unionTypesNonNull = unionTypes.filter(type => type.kind !== "null");
                    if (unionTypesNonNull.length === 1) {
                        let suffix = "";
                        let itemTypes = [];
                        if (unionTypesNonNull[0] instanceof ArrayType) {
                            suffix = "_element";
                            itemTypes = [...unionTypesNonNull[0].getChildren()];
                        }
                        else if (unionTypesNonNull[0] instanceof MapType) {
                            suffix = "_value";
                            itemTypes = [...unionTypesNonNull[0].getChildren()];
                        }
                        if (itemTypes.length === 1 && itemTypes[0] instanceof UnionType) {
                            itemTypes = [...itemTypes[0].getChildren()];
                        }
                        this.emitPatternMatches(itemTypes, name, this.nameForNamedTypeWithNamespace(c), suffix, p.isOptional);
                    }
                    else {
                        this.emitPatternMatches(unionTypes, name, this.nameForNamedTypeWithNamespace(c), "", p.isOptional);
                    }
                }
                else if (p.type.kind === "array") {
                    const arrayType = p.type;
                    if (arrayType.items instanceof UnionType) {
                        const unionType = arrayType.items;
                        const typesInUnion = [...unionType.getChildren()];
                        this.emitPatternMatches(typesInUnion, name, this.nameForNamedTypeWithNamespace(c), "_element");
                    }
                }
                else if (p.type.kind === "map") {
                    const mapType = p.type;
                    if (mapType.values instanceof UnionType) {
                        const unionType = mapType.values;
                        const typesInUnion = [...unionType.getChildren()];
                        this.emitPatternMatches(typesInUnion, name, this.nameForNamedTypeWithNamespace(c), "_value");
                    }
                }
            });
            let propCount = 0;
            this.forEachClassProperty(c, "none", (_name, _jsonName, _p) => {
                propCount++;
            });
            const isEmpty = propCount ? false : true;
            this.ensureBlankLine();
            this.emitBlock([`def from_map(${isEmpty ? "_" : ""}m) do`], () => {
                this.emitLine("%", this.nameWithNamespace(moduleName), "{");
                this.indent(() => {
                    this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                        jsonName = escapeDoubleQuotes(jsonName);
                        jsonName = escapeNewLines(jsonName);
                        const expression = this.fromDynamic(p.type, jsonName, name, p.isOptional);
                        this.emitLine(name, ": ", expression, ",");
                    });
                });
                this.emitLine("}");
            });
            this.ensureBlankLine();
            this.emitBlock("def from_json(json) do", () => {
                this.emitMultiline(`json
        |> Jason.decode!()
        |> from_map()`);
            });
            this.ensureBlankLine();
            this.emitBlock([`def to_map(${isEmpty ? "_" : ""}struct) do`], () => {
                this.emitLine("%{");
                this.indent(() => {
                    this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                        const expression = this.toDynamic(p.type, name, p.isOptional);
                        this.emitLine([[`"${stringEscape$5(jsonName)}"`], [" => ", expression, ","]]);
                    });
                });
                this.emitLine("}");
            });
            this.ensureBlankLine();
            this.emitBlock("def to_json(struct) do", () => {
                this.emitMultiline(`struct
        |> to_map()
        |> Jason.encode!()`);
            });
        });
    }
    isValidAtom(str) {
        function isLetter(char) {
            return /^[A-Za-z_]$/.test(char);
        }
        function isLetterOrDigit(char) {
            return /^[A-Za-z0-9_]$/.test(char);
        }
        if (str.length === 0) {
            return false;
        }
        const firstChar = str[0];
        if (!isLetter(firstChar)) {
            return false;
        }
        for (let i = 1; i < str.length; i++) {
            const char = str[i];
            if (!isLetterOrDigit(char) && char !== "@" && !(i === str.length - 1 && (char === "!" || char === "?"))) {
                return false;
            }
        }
        return true;
    }
    emitEnum(e, enumName) {
        this.emitBlock(["defmodule ", this.nameWithNamespace(enumName), " do"], () => {
            this.emitDescription(this.descriptionForType(e));
            this.emitLine("@valid_enum_members [");
            this.indent(() => {
                this.forEachEnumCase(e, "none", (_name, json) => {
                    if (this.isValidAtom(json)) {
                        this.emitLine(":", json, ",");
                    }
                    else {
                        this.emitLine(":", `"${json}"`, ",");
                    }
                });
            });
            this.emitLine("]");
            this.ensureBlankLine();
            this.emitMultiline(`def valid_atom?(value), do: value in @valid_enum_members

def valid_atom_string?(value) do
    try do
        atom = String.to_existing_atom(value)
        atom in @valid_enum_members
    rescue
        ArgumentError -> false
    end
end

def encode(value) do
    if valid_atom?(value) do
        Atom.to_string(value)
    else
        {:error, "Unexpected value when encoding atom: #{inspect(value)}"}
    end
end

def decode(value) do
    if valid_atom_string?(value) do
        String.to_existing_atom(value)
    else
        {:error, "Unexpected value when decoding atom: #{inspect(value)}"}
    end
end

def from_json(json) do
    json
    |> Jason.decode!()
    |> decode()
end

def to_json(data) do
    data
    |> encode()
    |> Jason.encode!()
end`);
        });
    }
    emitUnion(_u, _unionName) {
        return;
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else if (!this._options.justTypes) {
            this.emitMultiline(`# This file was autogenerated using quicktype https://github.com/quicktype/quicktype
#
# Add Jason to your mix.exs`);
            this.forEachTopLevel("none", (_topLevel, name) => {
                this.emitLine("#");
                this.emitLine("# Decode a JSON string: ", this.nameWithNamespace(name), ".from_json(data)");
                this.emitLine("# Encode into a JSON string: ", this.nameWithNamespace(name), ".to_json(struct)");
            });
        }
        this.ensureBlankLine();
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitModule(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
        if (!this._options.justTypes) {
            this.forEachTopLevel("leading-and-interposing", (topLevel, name) => {
                const isTopLevelArray = "array" === topLevel.kind;
                this.emitBlock(["defmodule ", this.nameWithNamespace(name), " do"], () => {
                    var _a;
                    const description = (_a = this.descriptionForType(topLevel)) !== null && _a !== void 0 ? _a : [];
                    if (description.length) {
                        this.emitDescription([...description]);
                        this.ensureBlankLine();
                    }
                    if (isTopLevelArray) {
                        const arrayElement = topLevel.items;
                        let isUnion = false;
                        if (arrayElement instanceof UnionType) {
                            this.emitPatternMatches([...arrayElement.getChildren()], "element", name);
                            isUnion = true;
                        }
                        this.emitBlock("def from_json(json) do", () => {
                            this.emitLine("json");
                            this.emitLine("|> Jason.decode!()");
                            this.emitLine("|> Enum.map(&", isUnion
                                ? ["decode_element/1)"]
                                : [this.nameWithNamespace(name), "Element.from_map/1)"]);
                        });
                        this.ensureBlankLine();
                        this.emitBlock("def to_json(list) do", () => {
                            this.emitLine("Enum.map(list, &", isUnion
                                ? ["encode_element/1)"]
                                : [this.nameWithNamespace(name), "Element.to_map/1)"]);
                            this.emitLine("|> Jason.encode!()");
                        });
                    }
                    else {
                        this.emitBlock("def from_json(json) do", () => {
                            this.emitLine("Jason.decode!(json)");
                        });
                        this.ensureBlankLine();
                        this.emitBlock("def to_json(data) do", () => {
                            this.emitLine("Jason.encode!(data)");
                        });
                    }
                });
            }, t => this.namedTypeToNameForTopLevel(t) === undefined);
        }
    }
}

const elmOptions = {
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    useList: new EnumOption("array-type", "Use Array or List", [
        ["array", false],
        ["list", true]
    ]),
    // FIXME: Do this via a configurable named eventually.
    moduleName: new StringOption("module", "Generated module name", "NAME", "QuickType")
};
class ElmTargetLanguage extends TargetLanguage {
    constructor() {
        super("Elm", ["elm"], "elm");
    }
    getOptions() {
        return [elmOptions.justTypes, elmOptions.moduleName, elmOptions.useList];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new ElmRenderer(this, renderContext, getOptionValues(elmOptions, untypedOptionValues));
    }
}
const forbiddenNames$1 = [
    "if",
    "then",
    "else",
    "case",
    "of",
    "let",
    "in",
    "infix",
    "type",
    "module",
    "where",
    "import",
    "exposing",
    "as",
    "port",
    "int",
    "float",
    "bool",
    "string",
    "Jenc",
    "Jdec",
    "Jpipe",
    "always",
    "identity",
    "Array",
    "List",
    "Dict",
    "Maybe",
    "map",
    "toList",
    "makeArrayEncoder",
    "makeDictEncoder",
    "makeNullableEncoder",
    "Int",
    "True",
    "False",
    "String",
    "Float"
];
const legalizeName$e = legalizeCharacters(cp => isAscii(cp) && isLetterOrUnderscoreOrDigit(cp));
function elmNameStyle(original, upper) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$e, upper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, upper ? allUpperWordStyle : allLowerWordStyle, allUpperWordStyle, "", isLetterOrUnderscore);
}
const upperNamingFunction$3 = funPrefixNamer("upper", n => elmNameStyle(n, true));
const lowerNamingFunction$3 = funPrefixNamer("lower", n => elmNameStyle(n, false));
function requiredOrOptional(p) {
    function optional(fallback) {
        return { reqOrOpt: "Jpipe.optional", fallback };
    }
    const t = p.type;
    if (p.isOptional || (t instanceof UnionType && nullableFromUnion(t) !== null)) {
        return optional(" Nothing");
    }
    if (t.kind === "null") {
        return optional(" ()");
    }
    return { reqOrOpt: "Jpipe.required", fallback: "" };
}
class ElmRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._topLevelDependents = new Map();
        this._namedTypeDependents = new Map();
    }
    forbiddenNamesForGlobalNamespace() {
        return forbiddenNames$1;
    }
    makeTopLevelDependencyNames(t, topLevelName) {
        const encoder = new DependencyName(lowerNamingFunction$3, topLevelName.order, lookup => `${lookup(topLevelName)}_to_string`);
        let decoder = undefined;
        if (this.namedTypeToNameForTopLevel(t) === undefined) {
            decoder = new DependencyName(lowerNamingFunction$3, topLevelName.order, lookup => lookup(topLevelName));
        }
        this._topLevelDependents.set(topLevelName, { encoder, decoder });
        if (decoder !== undefined) {
            return [encoder, decoder];
        }
        return [encoder];
    }
    makeNamedTypeNamer() {
        return upperNamingFunction$3;
    }
    makeNamedTypeDependencyNames(_, typeName) {
        const encoder = new DependencyName(lowerNamingFunction$3, typeName.order, lookup => `encode_${lookup(typeName)}`);
        const decoder = new DependencyName(lowerNamingFunction$3, typeName.order, lookup => lookup(typeName));
        this._namedTypeDependents.set(typeName, { encoder, decoder });
        return [encoder, decoder];
    }
    namerForObjectProperty() {
        return lowerNamingFunction$3;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeUnionMemberNamer() {
        return upperNamingFunction$3;
    }
    get unionMembersInGlobalNamespace() {
        return true;
    }
    makeEnumCaseNamer() {
        return upperNamingFunction$3;
    }
    get enumCasesInGlobalNamespace() {
        return true;
    }
    proposeUnionMemberName(u, unionName, fieldType, lookup) {
        const fieldName = super.proposeUnionMemberName(u, unionName, fieldType, lookup);
        return `${fieldName}_in_${lookup(unionName)}`;
    }
    get commentLineStart() {
        return "-- ";
    }
    emitDescriptionBlock(lines) {
        if (lines.length === 1) {
            this.emitComments([{ customLines: lines, lineStart: "{-| ", lineEnd: " -}" }]);
        }
        else {
            this.emitCommentLines(lines, { firstLineStart: "{-| ", lineStart: "", afterComment: "-}" });
        }
    }
    get arrayType() {
        return this._options.useList ? "List" : "Array";
    }
    elmType(t, noOptional = false) {
        return matchType(t, _anyType => singleWord(annotated(anyTypeIssueAnnotation, "Jdec.Value")), _nullType => singleWord(annotated(nullTypeIssueAnnotation, "()")), _boolType => singleWord("Bool"), _integerType => singleWord("Int"), _doubleType => singleWord("Float"), _stringType => singleWord("String"), arrayType => multiWord(" ", this.arrayType, parenIfNeeded(this.elmType(arrayType.items))), classType => singleWord(this.nameForNamedType(classType)), mapType => multiWord(" ", "Dict String", parenIfNeeded(this.elmType(mapType.values))), enumType => singleWord(this.nameForNamedType(enumType)), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                const nullableType = this.elmType(nullable);
                if (noOptional)
                    return nullableType;
                return multiWord(" ", "Maybe", parenIfNeeded(nullableType));
            }
            return singleWord(this.nameForNamedType(unionType));
        });
    }
    elmProperty(p) {
        if (p.isOptional) {
            return multiWord(" ", "Maybe", parenIfNeeded(this.elmType(p.type, true))).source;
        }
        else {
            return this.elmType(p.type).source;
        }
    }
    decoderNameForNamedType(t) {
        const name = this.nameForNamedType(t);
        return defined(this._namedTypeDependents.get(name)).decoder;
    }
    decoderNameForType(t, noOptional = false) {
        return matchType(t, _anyType => singleWord("Jdec.value"), _nullType => multiWord(" ", "Jdec.null", "()"), _boolType => singleWord("Jdec.bool"), _integerType => singleWord("Jdec.int"), _doubleType => singleWord("Jdec.float"), _stringType => singleWord("Jdec.string"), arrayType => multiWord(" ", ["Jdec.", decapitalize(this.arrayType)], parenIfNeeded(this.decoderNameForType(arrayType.items))), classType => singleWord(this.decoderNameForNamedType(classType)), mapType => multiWord(" ", "Jdec.dict", parenIfNeeded(this.decoderNameForType(mapType.values))), enumType => singleWord(this.decoderNameForNamedType(enumType)), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                const nullableDecoder = this.decoderNameForType(nullable);
                if (noOptional)
                    return nullableDecoder;
                return multiWord(" ", "Jdec.nullable", parenIfNeeded(nullableDecoder));
            }
            return singleWord(this.decoderNameForNamedType(unionType));
        });
    }
    decoderNameForProperty(p) {
        if (p.isOptional) {
            return multiWord(" ", "Jdec.nullable", parenIfNeeded(this.decoderNameForType(p.type, true)));
        }
        else {
            return this.decoderNameForType(p.type);
        }
    }
    encoderNameForNamedType(t) {
        const name = this.nameForNamedType(t);
        return defined(this._namedTypeDependents.get(name)).encoder;
    }
    encoderNameForType(t, noOptional = false) {
        return matchType(t, _anyType => singleWord("identity"), _nullType => multiWord(" ", "always", "Jenc.null"), _boolType => singleWord("Jenc.bool"), _integerType => singleWord("Jenc.int"), _doubleType => singleWord("Jenc.float"), _stringType => singleWord("Jenc.string"), arrayType => multiWord(" ", ["make", this.arrayType, "Encoder"], parenIfNeeded(this.encoderNameForType(arrayType.items))), classType => singleWord(this.encoderNameForNamedType(classType)), mapType => multiWord(" ", "makeDictEncoder", parenIfNeeded(this.encoderNameForType(mapType.values))), enumType => singleWord(this.encoderNameForNamedType(enumType)), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                const nullableEncoder = this.encoderNameForType(nullable);
                if (noOptional)
                    return nullableEncoder;
                return multiWord(" ", "makeNullableEncoder", parenIfNeeded(nullableEncoder));
            }
            return singleWord(this.encoderNameForNamedType(unionType));
        });
    }
    encoderNameForProperty(p) {
        if (p.isOptional) {
            return multiWord(" ", "makeNullableEncoder", parenIfNeeded(this.encoderNameForType(p.type, true)));
        }
        else {
            return this.encoderNameForType(p.type);
        }
    }
    emitTopLevelDefinition(t, topLevelName) {
        this.emitLine("type alias ", topLevelName, " = ", this.elmType(t).source);
    }
    emitClassDefinition(c, className) {
        let description = this.descriptionForType(c);
        this.forEachClassProperty(c, "none", (name, jsonName) => {
            const propertyDescription = this.descriptionForClassProperty(c, jsonName);
            if (propertyDescription === undefined)
                return;
            if (description === undefined) {
                description = [];
            }
            else {
                description.push("");
            }
            description.push(`${this.sourcelikeToString(name)}:`);
            description.push(...propertyDescription);
        });
        this.emitDescription(description);
        this.emitLine("type alias ", className, " =");
        this.indent(() => {
            let onFirst = true;
            this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
                this.emitLine(onFirst ? "{" : ",", " ", name, " : ", this.elmProperty(p));
                onFirst = false;
            });
            if (onFirst) {
                this.emitLine("{");
            }
            this.emitLine("}");
        });
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("type ", enumName);
        this.indent(() => {
            let onFirst = true;
            this.forEachEnumCase(e, "none", name => {
                const equalsOrPipe = onFirst ? "=" : "|";
                this.emitLine(equalsOrPipe, " ", name);
                onFirst = false;
            });
        });
    }
    emitUnionDefinition(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("type ", unionName);
        this.indent(() => {
            let onFirst = true;
            this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
                const equalsOrPipe = onFirst ? "=" : "|";
                if (t.kind === "null") {
                    this.emitLine(equalsOrPipe, " ", constructor);
                }
                else {
                    this.emitLine(equalsOrPipe, " ", constructor, " ", parenIfNeeded(this.elmType(t)));
                }
                onFirst = false;
            });
        });
    }
    emitTopLevelFunctions(t, topLevelName) {
        const { encoder, decoder } = defined(this._topLevelDependents.get(topLevelName));
        if (this.namedTypeToNameForTopLevel(t) === undefined) {
            this.emitLine(defined(decoder), " : Jdec.Decoder ", topLevelName);
            this.emitLine(defined(decoder), " = ", this.decoderNameForType(t).source);
            this.ensureBlankLine();
        }
        this.emitLine(encoder, " : ", topLevelName, " -> String");
        this.emitLine(encoder, " r = Jenc.encode 0 (", this.encoderNameForType(t).source, " r)");
    }
    emitClassFunctions(c, className) {
        const decoderName = this.decoderNameForNamedType(c);
        this.emitLine(decoderName, " : Jdec.Decoder ", className);
        this.emitLine(decoderName, " =");
        this.indent(() => {
            this.emitLine("Jpipe.decode ", className);
            this.indent(() => {
                this.forEachClassProperty(c, "none", (_, jsonName, p) => {
                    const propDecoder = parenIfNeeded(this.decoderNameForProperty(p));
                    const { reqOrOpt, fallback } = requiredOrOptional(p);
                    this.emitLine("|> ", reqOrOpt, ' "', stringEscape$7(jsonName), '" ', propDecoder, fallback);
                });
            });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(c);
        this.emitLine(encoderName, " : ", className, " -> Jenc.Value");
        this.emitLine(encoderName, " x =");
        this.indent(() => {
            this.emitLine("Jenc.object");
            this.indent(() => {
                let onFirst = true;
                this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                    const bracketOrComma = onFirst ? "[" : ",";
                    const propEncoder = this.encoderNameForProperty(p).source;
                    this.emitLine(bracketOrComma, ' ("', stringEscape$7(jsonName), '", ', propEncoder, " x.", name, ")");
                    onFirst = false;
                });
                if (onFirst) {
                    this.emitLine("[");
                }
                this.emitLine("]");
            });
        });
    }
    emitEnumFunctions(e, enumName) {
        const decoderName = this.decoderNameForNamedType(e);
        this.emitLine(decoderName, " : Jdec.Decoder ", enumName);
        this.emitLine(decoderName, " =");
        this.indent(() => {
            this.emitLine("Jdec.string");
            this.indent(() => {
                this.emitLine("|> Jdec.andThen (\\str ->");
                this.indent(() => {
                    this.emitLine("case str of");
                    this.indent(() => {
                        this.forEachEnumCase(e, "none", (name, jsonName) => {
                            this.emitLine('"', stringEscape$7(jsonName), '" -> Jdec.succeed ', name);
                        });
                        this.emitLine('somethingElse -> Jdec.fail <| "Invalid ', enumName, ': " ++ somethingElse');
                    });
                });
                this.emitLine(")");
            });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(e);
        this.emitLine(encoderName, " : ", enumName, " -> Jenc.Value");
        this.emitLine(encoderName, " x = case x of");
        this.indent(() => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine(name, ' -> Jenc.string "', stringEscape$7(jsonName), '"');
            });
        });
    }
    emitUnionFunctions(u, unionName) {
        // We need arrays first, then strings, and integers before doubles.
        function sortOrder(_, t) {
            if (t.kind === "array") {
                return "  array";
            }
            else if (t.kind === "double") {
                return " xdouble";
            }
            else if (t.isPrimitive()) {
                return " " + t.kind;
            }
            return t.kind;
        }
        const decoderName = this.decoderNameForNamedType(u);
        this.emitLine(decoderName, " : Jdec.Decoder ", unionName);
        this.emitLine(decoderName, " =");
        this.indent(() => {
            this.emitLine("Jdec.oneOf");
            this.indent(() => {
                let onFirst = true;
                this.forEachUnionMember(u, null, "none", sortOrder, (constructor, t) => {
                    const bracketOrComma = onFirst ? "[" : ",";
                    if (t.kind === "null") {
                        this.emitLine(bracketOrComma, " Jdec.null ", constructor);
                    }
                    else {
                        const decoder = parenIfNeeded(this.decoderNameForType(t));
                        this.emitLine(bracketOrComma, " Jdec.map ", constructor, " ", decoder);
                    }
                    onFirst = false;
                });
                this.emitLine("]");
            });
        });
        this.ensureBlankLine();
        const encoderName = this.encoderNameForNamedType(u);
        this.emitLine(encoderName, " : ", unionName, " -> Jenc.Value");
        this.emitLine(encoderName, " x = case x of");
        this.indent(() => {
            this.forEachUnionMember(u, null, "none", sortOrder, (constructor, t) => {
                if (t.kind === "null") {
                    this.emitLine(constructor, " -> Jenc.null");
                }
                else {
                    const encoder = this.encoderNameForType(t).source;
                    this.emitLine(constructor, " y -> ", encoder, " y");
                }
            });
        });
    }
    emitSourceStructure() {
        const exports = [];
        const topLevelDecoders = [];
        this.forEachTopLevel("none", (_, name) => {
            let { encoder, decoder } = defined(this._topLevelDependents.get(name));
            if (decoder === undefined) {
                decoder = defined(this._namedTypeDependents.get(name)).decoder;
            }
            topLevelDecoders.push(decoder);
            exports.push(name, encoder, decoder);
        });
        this.forEachObject("none", (t, name) => {
            if (!collectionUtils.mapContains(this.topLevels, t))
                exports.push(name);
        });
        this.forEachEnum("none", (t, name) => {
            if (!collectionUtils.mapContains(this.topLevels, t))
                exports.push([name, "(..)"]);
        });
        this.forEachUnion("none", (t, name) => {
            if (!collectionUtils.mapContains(this.topLevels, t))
                exports.push([name, "(..)"]);
        });
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else if (!this._options.justTypes) {
            this.emitCommentLines([
                "To decode the JSON data, add this file to your project, run",
                "",
                "    elm-package install NoRedInk/elm-decode-pipeline",
                "",
                "add these imports",
                "",
                "    import Json.Decode exposing (decodeString)`);"
            ]);
            this.emitLine("--     import ", this._options.moduleName, " exposing (", collectionUtils.arrayIntercalate(", ", topLevelDecoders), ")");
            this.emitMultiline(`--
-- and you're off to the races with
--`);
            this.forEachTopLevel("none", (_, name) => {
                let { decoder } = defined(this._topLevelDependents.get(name));
                if (decoder === undefined) {
                    decoder = defined(this._namedTypeDependents.get(name)).decoder;
                }
                this.emitLine("--     decodeString ", decoder, " myJsonString");
            });
        }
        if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitLine("module ", this._options.moduleName, " exposing");
            this.indent(() => {
                for (let i = 0; i < exports.length; i++) {
                    this.emitLine(i === 0 ? "(" : ",", " ", exports[i]);
                }
                this.emitLine(")");
            });
            this.ensureBlankLine();
            this.emitMultiline(`import Json.Decode as Jdec
import Json.Decode.Pipeline as Jpipe
import Json.Encode as Jenc
import Dict exposing (Dict, map, toList)`);
            if (this._options.useList) {
                this.emitLine("import List exposing (map)");
            }
            else {
                this.emitLine("import Array exposing (Array, map)");
            }
        }
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelDefinition(t, topLevelName), t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, enumName) => this.emitEnumDefinition(e, enumName), (u, unionName) => this.emitUnionDefinition(u, unionName));
        if (this._options.justTypes)
            return;
        this.ensureBlankLine();
        this.emitLine("-- decoders and encoders");
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelFunctions(t, topLevelName));
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className), (e, enumName) => this.emitEnumFunctions(e, enumName), (u, unionName) => this.emitUnionFunctions(u, unionName));
        this.ensureBlankLine();
        this.emitLine("--- encoder helpers");
        this.ensureBlankLine();
        this.emitLine("make", this.arrayType, "Encoder : (a -> Jenc.Value) -> ", this.arrayType, " a -> Jenc.Value");
        this.emitLine("make", this.arrayType, "Encoder f arr =");
        this.indent(() => {
            this.emitLine("Jenc.", decapitalize(this.arrayType), " (", this.arrayType, ".map f arr)");
        });
        this.ensureBlankLine();
        this.emitMultiline(`makeDictEncoder : (a -> Jenc.Value) -> Dict String a -> Jenc.Value
makeDictEncoder f dict =
    Jenc.object (toList (Dict.map (\\k -> f) dict))

makeNullableEncoder : (a -> Jenc.Value) -> Maybe a -> Jenc.Value
makeNullableEncoder f m =
    case m of
    Just x -> f x
    Nothing -> Jenc.null`);
    }
}

const goOptions = {
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    justTypesAndPackage: new BooleanOption("just-types-and-package", "Plain types with package only", false),
    packageName: new StringOption("package", "Generated package name", "NAME", "main"),
    multiFileOutput: new BooleanOption("multi-file-output", "Renders each top-level object in its own Go file", false),
    fieldTags: new StringOption("field-tags", "list of tags which should be generated for fields", "TAGS", "json"),
    omitEmpty: new BooleanOption("omit-empty", 'If set, all non-required objects will be tagged with ",omitempty"', false)
};
class GoTargetLanguage extends TargetLanguage {
    constructor() {
        super("Go", ["go", "golang"], "go");
    }
    getOptions() {
        return [
            goOptions.justTypes,
            goOptions.justTypesAndPackage,
            goOptions.packageName,
            goOptions.multiFileOutput,
            goOptions.fieldTags,
            goOptions.omitEmpty
        ];
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    get stringTypeMapping() {
        const mapping = new Map();
        mapping.set("date-time", "date-time");
        return mapping;
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new GoRenderer(this, renderContext, getOptionValues(goOptions, untypedOptionValues));
    }
    get defaultIndentation() {
        return "\t";
    }
}
const namingFunction$2 = funPrefixNamer("namer", goNameStyle);
const legalizeName$d = legalizeCharacters(isLetterOrUnderscoreOrDigit);
function goNameStyle(original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$d, firstUpperWordStyle, firstUpperWordStyle, allUpperWordStyle, allUpperWordStyle, "", isLetterOrUnderscore);
}
const primitiveValueTypeKinds = ["integer", "double", "bool", "string"];
const compoundTypeKinds = ["array", "class", "map", "enum"];
function isValueType(t) {
    const kind = t.kind;
    return primitiveValueTypeKinds.includes(kind) || kind === "class" || kind === "enum" || kind === "date-time";
}
function canOmitEmpty(cp, omitEmptyOption) {
    if (!cp.isOptional)
        return false;
    if (omitEmptyOption)
        return true;
    const t = cp.type;
    return !["union", "null", "any"].includes(t.kind);
}
class GoRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._topLevelUnmarshalNames = new Map();
    }
    makeNamedTypeNamer() {
        return namingFunction$2;
    }
    namerForObjectProperty() {
        return namingFunction$2;
    }
    makeUnionMemberNamer() {
        return namingFunction$2;
    }
    makeEnumCaseNamer() {
        return namingFunction$2;
    }
    get enumCasesInGlobalNamespace() {
        return true;
    }
    makeTopLevelDependencyNames(_, topLevelName) {
        const unmarshalName = new DependencyName(namingFunction$2, topLevelName.order, lookup => `unmarshal_${lookup(topLevelName)}`);
        this._topLevelUnmarshalNames.set(topLevelName, unmarshalName);
        return [unmarshalName];
    }
    /// startFile takes a file name, lowercases it, appends ".go" to it, and sets it as the current filename.
    startFile(basename) {
        if (this._options.multiFileOutput === false) {
            return;
        }
        assert(this._currentFilename === undefined, "Previous file wasn't finished: " + this._currentFilename);
        this._currentFilename = `${this.sourcelikeToString(basename)}.go`;
        this.initializeEmitContextForFilename(this._currentFilename);
    }
    /// endFile pushes the current file name onto the collection of finished files and then resets the current file name. These finished files are used in index.ts to write the output.
    endFile() {
        if (this._options.multiFileOutput === false) {
            return;
        }
        this.finishFile(defined(this._currentFilename));
        this._currentFilename = undefined;
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    emitFunc(decl, f) {
        this.emitBlock(["func ", decl], f);
    }
    emitStruct(name, table) {
        this.emitBlock(["type ", name, " struct"], () => this.emitTable(table));
    }
    nullableGoType(t, withIssues) {
        const goType = this.goType(t, withIssues);
        if (isValueType(t)) {
            return ["*", goType];
        }
        else {
            return goType;
        }
    }
    propertyGoType(cp) {
        const t = cp.type;
        if (t instanceof UnionType && nullableFromUnion(t) === null) {
            return ["*", this.goType(t, true)];
        }
        if (cp.isOptional) {
            return this.nullableGoType(t, true);
        }
        return this.goType(t, true);
    }
    goType(t, withIssues = false) {
        return matchType(t, _anyType => maybeAnnotated(withIssues, anyTypeIssueAnnotation, "interface{}"), _nullType => maybeAnnotated(withIssues, nullTypeIssueAnnotation, "interface{}"), _boolType => "bool", _integerType => "int64", _doubleType => "float64", _stringType => "string", arrayType => ["[]", this.goType(arrayType.items, withIssues)], classType => this.nameForNamedType(classType), mapType => {
            let valueSource;
            const v = mapType.values;
            if (v instanceof UnionType && nullableFromUnion(v) === null) {
                valueSource = ["*", this.nameForNamedType(v)];
            }
            else {
                valueSource = this.goType(v, withIssues);
            }
            return ["map[string]", valueSource];
        }, enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return this.nullableGoType(nullable, withIssues);
            return this.nameForNamedType(unionType);
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return "time.Time";
            }
            return "string";
        });
    }
    emitTopLevel(t, name) {
        this.startFile(name);
        if (this._options.multiFileOutput &&
            this._options.justTypes === false &&
            this._options.justTypesAndPackage === false &&
            this.leadingComments === undefined) {
            this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
            this.emitLineOnce("// To parse and unparse this JSON data, add this code to your project and do:");
            this.emitLineOnce("//");
            const ref = modifySource(camelCase, name);
            this.emitLineOnce("//    ", ref, ", err := ", defined(this._topLevelUnmarshalNames.get(name)), "(bytes)");
            this.emitLineOnce("//    bytes, err = ", ref, ".Marshal()");
        }
        this.emitPackageDefinitons(true);
        const unmarshalName = defined(this._topLevelUnmarshalNames.get(name));
        if (this.namedTypeToNameForTopLevel(t) === undefined) {
            this.emitLine("type ", name, " ", this.goType(t));
        }
        if (this._options.justTypes || this._options.justTypesAndPackage)
            return;
        this.ensureBlankLine();
        this.emitFunc([unmarshalName, "(data []byte) (", name, ", error)"], () => {
            this.emitLine("var r ", name);
            this.emitLine("err := json.Unmarshal(data, &r)");
            this.emitLine("return r, err");
        });
        this.ensureBlankLine();
        this.emitFunc(["(r *", name, ") Marshal() ([]byte, error)"], () => {
            this.emitLine("return json.Marshal(r)");
        });
        this.endFile();
    }
    emitClass(c, className) {
        this.startFile(className);
        let columns = [];
        const usedTypes = new Set();
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const description = this.descriptionForClassProperty(c, jsonName);
            const docStrings = description !== undefined && description.length > 0 ? description.map(d => "// " + d) : [];
            const goType = this.propertyGoType(p);
            const omitEmpty = canOmitEmpty(p, this._options.omitEmpty) ? ",omitempty" : [];
            docStrings.forEach(doc => columns.push([doc]));
            const tags = this._options.fieldTags
                .split(",")
                .map(tag => tag + ':"' + stringEscape$7(jsonName) + omitEmpty + '"')
                .join(" ");
            columns.push([
                [name, " "],
                [goType, " "],
                ["`", tags, "`"]
            ]);
            usedTypes.add(goType.toString());
        });
        this.emitPackageDefinitons(false, usedTypes.has("time.Time") || usedTypes.has("*,time.Time") || usedTypes.has("[],time.Time")
            ? new Set(["time"])
            : undefined);
        this.emitDescription(this.descriptionForType(c));
        this.emitStruct(className, columns);
        this.endFile();
    }
    emitEnum(e, enumName) {
        this.startFile(enumName);
        this.emitPackageDefinitons(false);
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("type ", enumName, " string");
        this.ensureBlankLine();
        this.emitLine("const (");
        let columns = [];
        this.forEachEnumCase(e, "none", (name, jsonName) => {
            columns.push([
                [name, " "],
                [enumName, ' = "', stringEscape$7(jsonName), '"']
            ]);
        });
        this.indent(() => this.emitTable(columns));
        this.emitLine(")");
        this.endFile();
    }
    emitUnion(u, unionName) {
        this.startFile(unionName);
        this.emitPackageDefinitons(false);
        const [hasNull, nonNulls] = removeNullFromUnion(u);
        const isNullableArg = hasNull !== null ? "true" : "false";
        const ifMember = (kind, ifNotMember, f) => {
            const maybeType = u.findMember(kind);
            if (maybeType === undefined)
                return ifNotMember;
            return f(maybeType, this.nameForUnionMember(u, maybeType), this.goType(maybeType));
        };
        const maybeAssignNil = (kind) => {
            ifMember(kind, undefined, (_1, fieldName, _2) => {
                this.emitLine("x.", fieldName, " = nil");
            });
        };
        const makeArgs = (primitiveArg, compoundArg) => {
            const args = [];
            for (const kind of primitiveValueTypeKinds) {
                args.push(ifMember(kind, "nil", (_1, fieldName, _2) => primitiveArg(fieldName)), ", ");
            }
            for (const kind of compoundTypeKinds) {
                args.push(ifMember(kind, "false, nil", (t, fieldName, _) => compoundArg(t.kind === "class", fieldName)), ", ");
            }
            args.push(isNullableArg);
            return args;
        };
        let columns = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (fieldName, t) => {
            const goType = this.nullableGoType(t, true);
            columns.push([[fieldName, " "], goType]);
        });
        this.emitDescription(this.descriptionForType(u));
        this.emitStruct(unionName, columns);
        if (this._options.justTypes || this._options.justTypesAndPackage)
            return;
        this.ensureBlankLine();
        this.emitFunc(["(x *", unionName, ") UnmarshalJSON(data []byte) error"], () => {
            for (const kind of compoundTypeKinds) {
                maybeAssignNil(kind);
            }
            ifMember("class", undefined, (_1, _2, goType) => {
                this.emitLine("var c ", goType);
            });
            const args = makeArgs(fn => ["&x.", fn], (isClass, fn) => {
                if (isClass) {
                    return "true, &c";
                }
                else {
                    return ["true, &x.", fn];
                }
            });
            this.emitLine("object, err := unmarshalUnion(data, ", args, ")");
            this.emitBlock("if err != nil", () => {
                this.emitLine("return err");
            });
            this.emitBlock("if object", () => {
                ifMember("class", undefined, (_1, fieldName, _2) => {
                    this.emitLine("x.", fieldName, " = &c");
                });
            });
            this.emitLine("return nil");
        });
        this.ensureBlankLine();
        this.emitFunc(["(x *", unionName, ") MarshalJSON() ([]byte, error)"], () => {
            const args = makeArgs(fn => ["x.", fn], (_, fn) => ["x.", fn, " != nil, x.", fn]);
            this.emitLine("return marshalUnion(", args, ")");
        });
        this.endFile();
    }
    emitSingleFileHeaderComments() {
        this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
        this.emitLineOnce("// To parse and unparse this JSON data, add this code to your project and do:");
        this.forEachTopLevel("none", (_, name) => {
            this.emitLine("//");
            const ref = modifySource(camelCase, name);
            this.emitLine("//    ", ref, ", err := ", defined(this._topLevelUnmarshalNames.get(name)), "(bytes)");
            this.emitLine("//    bytes, err = ", ref, ".Marshal()");
        });
    }
    emitPackageDefinitons(includeJSONEncodingImport, imports = new Set()) {
        if (!this._options.justTypes || this._options.justTypesAndPackage) {
            this.ensureBlankLine();
            const packageDeclaration = "package " + this._options.packageName;
            this.emitLineOnce(packageDeclaration);
            this.ensureBlankLine();
        }
        if (!this._options.justTypes && !this._options.justTypesAndPackage) {
            if (this.haveNamedUnions && this._options.multiFileOutput === false) {
                imports.add("bytes");
                imports.add("errors");
            }
            if (includeJSONEncodingImport) {
                imports.add("encoding/json");
            }
        }
        this.emitImports(imports);
    }
    emitImports(imports) {
        const sortedImports = Array.from(imports).sort((a, b) => a.localeCompare(b));
        if (sortedImports.length === 0) {
            return;
        }
        sortedImports.forEach(packageName => {
            this.emitLineOnce(`import "${packageName}"`);
        });
        this.ensureBlankLine();
    }
    emitHelperFunctions() {
        if (this.haveNamedUnions) {
            this.startFile("JSONSchemaSupport");
            const imports = new Set();
            if (this._options.multiFileOutput) {
                imports.add("bytes");
                imports.add("errors");
            }
            this.emitPackageDefinitons(true, imports);
            this.ensureBlankLine();
            this
                .emitMultiline(`func unmarshalUnion(data []byte, pi **int64, pf **float64, pb **bool, ps **string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) (bool, error) {
    if pi != nil {
        *pi = nil
    }
    if pf != nil {
        *pf = nil
    }
    if pb != nil {
        *pb = nil
    }
    if ps != nil {
        *ps = nil
    }

    dec := json.NewDecoder(bytes.NewReader(data))
    dec.UseNumber()
    tok, err := dec.Token()
    if err != nil {
        return false, err
    }

    switch v := tok.(type) {
    case json.Number:
        if pi != nil {
            i, err := v.Int64()
            if err == nil {
                *pi = &i
                return false, nil
            }
        }
        if pf != nil {
            f, err := v.Float64()
            if err == nil {
                *pf = &f
                return false, nil
            }
            return false, errors.New("Unparsable number")
        }
        return false, errors.New("Union does not contain number")
    case float64:
        return false, errors.New("Decoder should not return float64")
    case bool:
        if pb != nil {
            *pb = &v
            return false, nil
        }
        return false, errors.New("Union does not contain bool")
    case string:
        if haveEnum {
            return false, json.Unmarshal(data, pe)
        }
        if ps != nil {
            *ps = &v
            return false, nil
        }
        return false, errors.New("Union does not contain string")
    case nil:
        if nullable {
            return false, nil
        }
        return false, errors.New("Union does not contain null")
    case json.Delim:
        if v == '{' {
            if haveObject {
                return true, json.Unmarshal(data, pc)
            }
            if haveMap {
                return false, json.Unmarshal(data, pm)
            }
            return false, errors.New("Union does not contain object")
        }
        if v == '[' {
            if haveArray {
                return false, json.Unmarshal(data, pa)
            }
            return false, errors.New("Union does not contain array")
        }
        return false, errors.New("Cannot handle delimiter")
    }
    return false, errors.New("Cannot unmarshal union")

}

func marshalUnion(pi *int64, pf *float64, pb *bool, ps *string, haveArray bool, pa interface{}, haveObject bool, pc interface{}, haveMap bool, pm interface{}, haveEnum bool, pe interface{}, nullable bool) ([]byte, error) {
    if pi != nil {
        return json.Marshal(*pi)
    }
    if pf != nil {
        return json.Marshal(*pf)
    }
    if pb != nil {
        return json.Marshal(*pb)
    }
    if ps != nil {
        return json.Marshal(*ps)
    }
    if haveArray {
        return json.Marshal(pa)
    }
    if haveObject {
        return json.Marshal(pc)
    }
    if haveMap {
        return json.Marshal(pm)
    }
    if haveEnum {
        return json.Marshal(pe)
    }
    if nullable {
        return json.Marshal(nil)
    }
    return nil, errors.New("Union must not be null")
}`);
            this.endFile();
        }
    }
    emitSourceStructure() {
        if (this._options.multiFileOutput === false &&
            this._options.justTypes === false &&
            this._options.justTypesAndPackage === false &&
            this.leadingComments === undefined) {
            this.emitSingleFileHeaderComments();
            this.emitPackageDefinitons(false, this.collectAllImports());
        }
        this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevel(t, name), t => !(this._options.justTypes || this._options.justTypesAndPackage) ||
            this.namedTypeToNameForTopLevel(t) === undefined);
        this.forEachObject("leading-and-interposing", (c, className) => this.emitClass(c, className));
        this.forEachEnum("leading-and-interposing", (u, enumName) => this.emitEnum(u, enumName));
        this.forEachUnion("leading-and-interposing", (u, unionName) => this.emitUnion(u, unionName));
        if (this._options.justTypes || this._options.justTypesAndPackage) {
            return;
        }
        this.emitHelperFunctions();
    }
    collectAllImports() {
        let imports = new Set();
        this.forEachObject("leading-and-interposing", (c, _className) => {
            const classImports = this.collectClassImports(c);
            imports = new Set([...imports, ...classImports]);
        });
        this.forEachUnion("leading-and-interposing", (u, _unionName) => {
            const unionImports = this.collectUnionImports(u);
            imports = new Set([...imports, ...unionImports]);
        });
        return imports;
    }
    collectClassImports(c) {
        const usedTypes = new Set();
        const mapping = new Map();
        mapping.set("time.Time", "time");
        mapping.set("*,time.Time", "time");
        mapping.set("[],time.Time", "time");
        this.forEachClassProperty(c, "none", (_name, _jsonName, p) => {
            const goType = this.propertyGoType(p);
            usedTypes.add(goType.toString());
        });
        const imports = new Set();
        usedTypes.forEach(k => {
            const typeImport = mapping.get(k);
            if (typeImport) {
                imports.add(typeImport);
            }
        });
        return imports;
    }
    collectUnionImports(u) {
        const usedTypes = new Set();
        const mapping = new Map();
        mapping.set("time.Time", "time");
        mapping.set("*,time.Time", "time");
        this.forEachUnionMember(u, null, "none", null, (_fieldName, t) => {
            const goType = this.nullableGoType(t, true);
            usedTypes.add(goType.toString());
        });
        const imports = new Set();
        usedTypes.forEach(k => {
            const typeImport = mapping.get(k);
            if (!typeImport) {
                return;
            }
            imports.add(typeImport);
        });
        return imports;
    }
}

const haskellOptions = {
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    useList: new EnumOption("array-type", "Use Array or List", [
        ["array", false],
        ["list", true]
    ]),
    moduleName: new StringOption("module", "Generated module name", "NAME", "QuickType")
};
class HaskellTargetLanguage extends TargetLanguage {
    constructor() {
        super("Haskell", ["haskell"], "haskell");
    }
    getOptions() {
        return [haskellOptions.justTypes, haskellOptions.moduleName, haskellOptions.useList];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new HaskellRenderer(this, renderContext, getOptionValues(haskellOptions, untypedOptionValues));
    }
}
const forbiddenNames = [
    // reserved keywords
    "as",
    "case",
    "class",
    "data",
    "default",
    "deriving",
    "do",
    "else",
    "family",
    "forall",
    "foreign",
    "hiding",
    "if",
    "import",
    "in",
    "infix",
    "infixl",
    "infixr",
    "instance",
    "let",
    "of",
    "mdo",
    "module",
    "newtype",
    "proc",
    "qualified",
    "rec",
    "then",
    "type",
    "where",
    // in Prelude keywords ...
    "id",
    "Array",
    "HashMap",
    "Map",
    "Maybe",
    "Bool",
    "Int",
    "True",
    "False",
    "Enum",
    // Aeson types
    "encode",
    "decode",
    "text",
    "Text",
    "Value",
    "Object",
    "Result",
    "Series",
    "Error"
];
const legalizeName$c = legalizeCharacters(cp => isAscii(cp) && isLetterOrUnderscoreOrDigit(cp));
function haskellNameStyle(original, upper) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$c, upper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, upper ? allUpperWordStyle : allLowerWordStyle, allUpperWordStyle, "", isLetterOrUnderscore);
}
const upperNamingFunction$2 = funPrefixNamer("upper", n => haskellNameStyle(n, true));
const lowerNamingFunction$2 = funPrefixNamer("lower", n => haskellNameStyle(n, false));
class HaskellRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
    }
    forbiddenNamesForGlobalNamespace() {
        return forbiddenNames;
    }
    makeNamedTypeNamer() {
        return upperNamingFunction$2;
    }
    namerForObjectProperty() {
        return lowerNamingFunction$2;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeUnionMemberNamer() {
        return upperNamingFunction$2;
    }
    get unionMembersInGlobalNamespace() {
        return true;
    }
    makeEnumCaseNamer() {
        return upperNamingFunction$2;
    }
    get enumCasesInGlobalNamespace() {
        return true;
    }
    proposeUnionMemberName(u, unionName, fieldType, lookup) {
        const fieldName = super.proposeUnionMemberName(u, unionName, fieldType, lookup);
        return `${fieldName}_in_${lookup(unionName)}`;
    }
    get commentLineStart() {
        return "-- ";
    }
    emitDescriptionBlock(lines) {
        if (lines.length === 1) {
            this.emitComments([{ customLines: lines, lineStart: "{-| ", lineEnd: " -}" }]);
        }
        else {
            this.emitCommentLines(lines, {
                firstLineStart: "{-| ",
                lineStart: "",
                afterComment: "-}"
            });
        }
    }
    haskellType(t, noOptional = false) {
        return matchType(t, _anyType => multiWord(" ", "Maybe", "Text"), _nullType => multiWord(" ", "Maybe", "Text"), _boolType => singleWord("Bool"), _integerType => singleWord("Int"), _doubleType => singleWord("Float"), _stringType => singleWord("Text"), arrayType => {
            if (this._options.useList) {
                return multiWord("", "[", parenIfNeeded(this.haskellType(arrayType.items)), "]");
            }
            return multiWord(" ", "Vector", parenIfNeeded(this.haskellType(arrayType.items)));
        }, classType => singleWord(this.nameForNamedType(classType)), mapType => multiWord(" ", "HashMap Text", parenIfNeeded(this.haskellType(mapType.values))), enumType => singleWord(this.nameForNamedType(enumType)), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                const nullableType = this.haskellType(nullable);
                if (noOptional)
                    return nullableType;
                return multiWord(" ", "Maybe", parenIfNeeded(nullableType));
            }
            return singleWord(this.nameForNamedType(unionType));
        });
    }
    haskellProperty(p) {
        if (p.isOptional) {
            return multiWord(" ", "Maybe", parenIfNeeded(this.haskellType(p.type, true))).source;
        }
        else {
            return this.haskellType(p.type).source;
        }
    }
    encoderNameForType(t) {
        return matchType(t, _anyType => singleWord("String"), _nullType => singleWord("Null"), _boolType => singleWord("Bool"), _integerType => singleWord("Number"), _doubleType => singleWord("Number"), _stringType => singleWord("String"), _arrayType => singleWord("Array"), _classType => singleWord("Object"), _mapType => singleWord("Object"), _enumType => singleWord("Object"), _unionType => singleWord("Object"));
    }
    emitTopLevelDefinition(t, topLevelName) {
        this.emitLine("type ", topLevelName, " = ", this.haskellType(t).source);
    }
    emitClassDefinition(c, className) {
        let description = this.descriptionForType(c);
        this.forEachClassProperty(c, "none", (name, jsonName) => {
            const propertyDescription = this.descriptionForClassProperty(c, jsonName);
            if (propertyDescription === undefined)
                return;
            if (description === undefined) {
                description = [];
            }
            else {
                description.push("");
            }
            description.push(`${this.sourcelikeToString(name)}:`);
            description.push(...propertyDescription);
        });
        this.emitDescription(description);
        this.emitLine("data ", className, " = ", className);
        this.indent(() => {
            let onFirst = true;
            this.forEachClassProperty(c, "none", (name, _jsonName, p) => {
                this.emitLine(onFirst ? "{ " : ", ", name, className, " :: ", this.haskellProperty(p));
                onFirst = false;
            });
            if (onFirst) {
                this.emitLine("{");
            }
            this.emitLine("} deriving (Show)");
        });
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("data ", enumName);
        this.indent(() => {
            let onFirst = true;
            this.forEachEnumCase(e, "none", name => {
                const equalsOrPipe = onFirst ? "=" : "|";
                this.emitLine(equalsOrPipe, " ", name, enumName);
                onFirst = false;
            });
            this.emitLine("deriving (Show)");
        });
    }
    emitUnionDefinition(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("data ", unionName);
        this.indent(() => {
            let onFirst = true;
            this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
                const equalsOrPipe = onFirst ? "=" : "|";
                if (t.kind === "null") {
                    this.emitLine(equalsOrPipe, " ", constructor);
                }
                else {
                    this.emitLine(equalsOrPipe, " ", constructor, " ", parenIfNeeded(this.haskellType(t)));
                }
                onFirst = false;
            });
            this.emitLine("deriving (Show)");
        });
    }
    emitTopLevelFunctions(topLevelName) {
        this.emitLine("decodeTopLevel :: ByteString -> Maybe ", topLevelName);
        this.emitLine("decodeTopLevel = decode");
    }
    classPropertyLength(c) {
        let counter = 0;
        this.forEachClassProperty(c, "none", () => {
            counter += 1;
        });
        return counter;
    }
    emitClassEncoderInstance(c, className) {
        let classProperties = [];
        this.forEachClassProperty(c, "none", name => {
            classProperties.push(" ");
            classProperties.push(name);
            classProperties.push(className);
        });
        this.emitLine("instance ToJSON ", className, " where");
        this.indent(() => {
            if (classProperties.length === 0) {
                this.emitLine("toJSON = \\_ -> emptyObject");
            }
            else {
                this.emitLine("toJSON (", className, ...classProperties, ") =");
                this.indent(() => {
                    this.emitLine("object");
                    let onFirst = true;
                    this.forEachClassProperty(c, "none", (name, jsonName) => {
                        this.emitLine(onFirst ? "[ " : ", ", '"', stringEscape$7(jsonName), '" .= ', name, className);
                        onFirst = false;
                    });
                    if (onFirst) {
                        this.emitLine("[");
                    }
                    this.emitLine("]");
                });
            }
        });
    }
    emitClassDecoderInstance(c, className) {
        this.emitLine("instance FromJSON ", className, " where");
        this.indent(() => {
            if (this.classPropertyLength(c) === 0) {
                this.emitLine("parseJSON emptyObject = return ", className);
            }
            else {
                this.emitLine("parseJSON (Object v) = ", className);
                this.indent(() => {
                    let onFirst = true;
                    this.forEachClassProperty(c, "none", (_, jsonName, p) => {
                        const operator = p.isOptional ? ".:?" : ".:";
                        this.emitLine(onFirst ? "<$> " : "<*> ", "v ", operator, ' "', stringEscape$7(jsonName), '"');
                        onFirst = false;
                    });
                });
            }
        });
    }
    emitClassFunctions(c, className) {
        this.emitClassEncoderInstance(c, className);
        this.ensureBlankLine();
        this.emitClassDecoderInstance(c, className);
    }
    emitEnumEncoderInstance(e, enumName) {
        this.emitLine("instance ToJSON ", enumName, " where");
        this.indent(() => {
            this.forEachEnumCase(e, "none", (name, jsonName) => {
                this.emitLine("toJSON ", name, enumName, ' = "', stringEscape$7(jsonName), '"');
            });
        });
    }
    emitEnumDecoderInstance(e, enumName) {
        this.emitLine("instance FromJSON ", enumName, " where");
        this.indent(() => {
            this.emitLine('parseJSON = withText "', enumName, '" parseText');
            this.indent(() => {
                this.emitLine("where");
                this.indent(() => {
                    this.forEachEnumCase(e, "none", (name, jsonName) => {
                        this.emitLine('parseText "', stringEscape$7(jsonName), '" = return ', name, enumName);
                    });
                });
            });
        });
    }
    emitEnumFunctions(e, enumName) {
        this.emitEnumEncoderInstance(e, enumName);
        this.ensureBlankLine();
        this.emitEnumDecoderInstance(e, enumName);
    }
    emitUnionEncoderInstance(u, unionName) {
        this.emitLine("instance ToJSON ", unionName, " where");
        this.indent(() => {
            this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
                if (t.kind === "null") {
                    this.emitLine("toJSON ", constructor, " = Null");
                }
                else {
                    this.emitLine("toJSON (", constructor, " x) = toJSON x");
                }
            });
        });
    }
    emitUnionDecoderInstance(u, unionName) {
        this.emitLine("instance FromJSON ", unionName, " where");
        this.indent(() => {
            this.forEachUnionMember(u, null, "none", null, (constructor, t) => {
                if (t.kind === "null") {
                    this.emitLine("parseJSON Null = return ", constructor);
                }
                else {
                    this.emitLine("parseJSON xs@(", this.encoderNameForType(t).source, " _) = (fmap ", constructor, " . parseJSON) xs");
                }
            });
        });
    }
    emitUnionFunctions(u, unionName) {
        this.emitUnionEncoderInstance(u, unionName);
        this.ensureBlankLine();
        this.emitUnionDecoderInstance(u, unionName);
    }
    emitLanguageExtensions(ext) {
        this.emitLine(`{-# LANGUAGE ${ext} #-}`);
    }
    emitSourceStructure() {
        const exports = [];
        this.forEachTopLevel("none", (_, name) => {
            exports.push([name, " (..)"]);
        });
        this.forEachObject("none", (t, name) => {
            if (!collectionUtils.mapContains(this.topLevels, t))
                exports.push([name, " (..)"]);
        });
        this.forEachEnum("none", (t, name) => {
            if (!collectionUtils.mapContains(this.topLevels, t))
                exports.push([name, " (..)"]);
        });
        this.forEachUnion("none", (t, name) => {
            if (!collectionUtils.mapContains(this.topLevels, t))
                exports.push([name, " (..)"]);
        });
        this.emitLanguageExtensions("StrictData");
        this.emitLanguageExtensions("OverloadedStrings");
        if (!this._options.justTypes) {
            this.ensureBlankLine();
            this.emitLine("module ", this._options.moduleName);
            this.indent(() => {
                for (let i = 0; i < exports.length; i++) {
                    this.emitLine(i === 0 ? "(" : ",", " ", exports[i]);
                }
                this.emitLine(", decodeTopLevel");
                this.emitLine(") where");
            });
            this.ensureBlankLine();
            this.emitMultiline(`import Data.Aeson
import Data.Aeson.Types (emptyObject)
import Data.ByteString.Lazy (ByteString)
import Data.HashMap.Strict (HashMap)
import Data.Text (Text)`);
            if (this._options.useList) ;
            else {
                this.emitLine("import Data.Vector (Vector)");
            }
        }
        this.forEachTopLevel("leading-and-interposing", (t, topLevelName) => this.emitTopLevelDefinition(t, topLevelName), t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, enumName) => this.emitEnumDefinition(e, enumName), (u, unionName) => this.emitUnionDefinition(u, unionName));
        this.forEachTopLevel("leading-and-interposing", (_, topLevelName) => this.emitTopLevelFunctions(topLevelName));
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassFunctions(c, className), (e, enumName) => this.emitEnumFunctions(e, enumName), (u, unionName) => this.emitUnionFunctions(u, unionName));
        if (this._options.justTypes)
            return;
        this.ensureBlankLine();
    }
}

const javaOptions = {
    useList: new EnumOption("array-type", "Use T[] or List<T>", [
        ["array", false],
        ["list", true]
    ], "array"),
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    dateTimeProvider: new EnumOption("datetime-provider", "Date time provider type", [
        ["java8", "java8"],
        ["legacy", "legacy"]
    ], "java8"),
    acronymStyle: acronymOption(AcronymStyleOptions.Pascal),
    // FIXME: Do this via a configurable named eventually.
    packageName: new StringOption("package", "Generated package name", "NAME", "io.quicktype"),
    lombok: new BooleanOption("lombok", "Use lombok", false, "primary"),
    lombokCopyAnnotations: new BooleanOption("lombok-copy-annotations", "Copy accessor annotations", true, "secondary")
};
class JavaTargetLanguage extends TargetLanguage {
    constructor() {
        super("Java", ["java"], "java");
    }
    getOptions() {
        return [
            javaOptions.useList,
            javaOptions.justTypes,
            javaOptions.dateTimeProvider,
            javaOptions.acronymStyle,
            javaOptions.packageName,
            javaOptions.lombok,
            javaOptions.lombokCopyAnnotations
        ];
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(javaOptions, untypedOptionValues);
        if (options.justTypes) {
            return new JavaRenderer(this, renderContext, options);
        }
        return new JacksonRenderer(this, renderContext, options);
    }
    get stringTypeMapping() {
        const mapping = new Map();
        mapping.set("date", "date");
        mapping.set("time", "time");
        mapping.set("date-time", "date-time");
        mapping.set("uuid", "uuid");
        return mapping;
    }
}
const javaKeywords = [
    "_",
    "Object",
    "Class",
    "System",
    "Long",
    "Double",
    "Boolean",
    "String",
    "List",
    "Map",
    "UUID",
    "Exception",
    "IOException",
    "Override",
    "abstract",
    "continue",
    "for",
    "new",
    "switch",
    "assert",
    "default",
    "goto",
    "package",
    "synchronized",
    "boolean",
    "do",
    "if",
    "private",
    "this",
    "break",
    "double",
    "implements",
    "protected",
    "throw",
    "byte",
    "else",
    "import",
    "public",
    "throws",
    "case",
    "enum",
    "instanceof",
    "return",
    "transient",
    "catch",
    "extends",
    "int",
    "short",
    "try",
    "char",
    "final",
    "interface",
    "static",
    "void",
    "class",
    "finally",
    "long",
    "strictfp",
    "volatile",
    "const",
    "float",
    "native",
    "super",
    "while",
    "null",
    "false",
    "true"
];
const stringEscape$4 = utf16ConcatMap(escapeNonPrintableMapper(isAscii, standardUnicodeHexEscape));
function isStartCharacter$7(codePoint) {
    if (codePoint === 0x5f)
        return true; // underscore
    return isAscii(codePoint) && isLetter(codePoint);
}
function isPartCharacter$7(codePoint) {
    return isStartCharacter$7(codePoint) || (isAscii(codePoint) && isDigit(codePoint));
}
const legalizeName$b = utf16LegalizeCharacters(isPartCharacter$7);
function javaNameStyle(startWithUpper, upperUnderscore, original, acronymsStyle = allUpperWordStyle) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$b, upperUnderscore ? allUpperWordStyle : startWithUpper ? firstUpperWordStyle : allLowerWordStyle, upperUnderscore ? allUpperWordStyle : firstUpperWordStyle, upperUnderscore || startWithUpper ? allUpperWordStyle : allLowerWordStyle, acronymsStyle, upperUnderscore ? "_" : "", isStartCharacter$7);
}
class JavaDateTimeProvider {
    constructor(_renderer, _className) {
        this._renderer = _renderer;
        this._className = _className;
        this.shouldEmitDateTimeConverter = true;
        this.shouldEmitTimeConverter = true;
        this.shouldEmitDateConverter = true;
    }
}
class Java8DateTimeProvider extends JavaDateTimeProvider {
    constructor() {
        super(...arguments);
        this.keywords = [
            "LocalDate",
            "OffsetDateTime",
            "OffsetTime",
            "ZoneOffset",
            "ZonedDateTime",
            "DateTimeFormatter",
            "DateTimeFormatterBuilder",
            "ChronoField"
        ];
        this.dateTimeImports = ["java.time.OffsetDateTime"];
        this.dateImports = ["java.time.LocalDate"];
        this.timeImports = ["java.time.OffsetTime"];
        this.converterImports = [
            "java.time.LocalDate",
            "java.time.OffsetDateTime",
            "java.time.OffsetTime",
            "java.time.ZoneOffset",
            "java.time.ZonedDateTime",
            "java.time.format.DateTimeFormatter",
            "java.time.format.DateTimeFormatterBuilder",
            "java.time.temporal.ChronoField"
        ];
        this.dateTimeType = "OffsetDateTime";
        this.dateType = "LocalDate";
        this.timeType = "OffsetTime";
        this.dateTimeJacksonAnnotations = [];
        this.dateJacksonAnnotations = [];
        this.timeJacksonAnnotations = [];
    }
    emitDateTimeConverters() {
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final DateTimeFormatter DATE_TIME_FORMATTER = new DateTimeFormatterBuilder()");
        this._renderer.indent(() => this._renderer.indent(() => {
            this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_DATE_TIME)");
            this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_OFFSET_DATE_TIME)");
            this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_INSTANT)");
            this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SX"))');
            this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssX"))');
            this._renderer.emitLine('.appendOptional(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))');
            this._renderer.emitLine(".toFormatter()");
            this._renderer.emitLine(".withZone(ZoneOffset.UTC);");
        }));
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static OffsetDateTime parseDateTimeString(String str)", () => {
            this._renderer.emitLine("return ZonedDateTime.from(Converter.DATE_TIME_FORMATTER.parse(str)).toOffsetDateTime();");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final DateTimeFormatter TIME_FORMATTER = new DateTimeFormatterBuilder()");
        this._renderer.indent(() => this._renderer.indent(() => {
            this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_TIME)");
            this._renderer.emitLine(".appendOptional(DateTimeFormatter.ISO_OFFSET_TIME)");
            this._renderer.emitLine(".parseDefaulting(ChronoField.YEAR, 2020)");
            this._renderer.emitLine(".parseDefaulting(ChronoField.MONTH_OF_YEAR, 1)");
            this._renderer.emitLine(".parseDefaulting(ChronoField.DAY_OF_MONTH, 1)");
            this._renderer.emitLine(".toFormatter()");
            this._renderer.emitLine(".withZone(ZoneOffset.UTC);");
        }));
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static OffsetTime parseTimeString(String str)", () => {
            this._renderer.emitLine("return ZonedDateTime.from(Converter.TIME_FORMATTER.parse(str)).toOffsetDateTime().toOffsetTime();");
        });
    }
    convertStringToDateTime(variable) {
        return [this._className, ".parseDateTimeString(", variable, ")"];
    }
    convertStringToTime(variable) {
        return [this._className, ".parseTimeString(", variable, ")"];
    }
    convertStringToDate(variable) {
        return ["LocalDate.parse(", variable, ")"];
    }
    convertDateTimeToString(variable) {
        return [variable, ".format(java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME)"];
    }
    convertTimeToString(variable) {
        return [variable, ".format(java.time.format.DateTimeFormatter.ISO_OFFSET_TIME)"];
    }
    convertDateToString(variable) {
        return [variable, ".format(java.time.format.DateTimeFormatter.ISO_DATE)"];
    }
}
class JavaLegacyDateTimeProvider extends JavaDateTimeProvider {
    constructor() {
        super(...arguments);
        this.keywords = ["SimpleDateFormat", "Date"];
        this.dateTimeImports = ["java.util.Date"];
        this.dateImports = ["java.util.Date"];
        this.timeImports = ["java.util.Date"];
        this.converterImports = ["java.util.Date", "java.text.SimpleDateFormat"];
        this.dateTimeType = "Date";
        this.dateType = "Date";
        this.timeType = "Date";
        this.dateTimeJacksonAnnotations = [
            '@JsonFormat(pattern = "yyyy-MM-dd\'T\'HH:mm:ssX", timezone = "UTC")'
        ];
        this.dateJacksonAnnotations = ['@JsonFormat(pattern = "yyyy-MM-dd")'];
        this.timeJacksonAnnotations = ['@JsonFormat(pattern = "HH:mm:ssX", timezone = "UTC")'];
        this.shouldEmitTimeConverter = false;
        this.shouldEmitDateConverter = false;
    }
    emitDateTimeConverters() {
        this._renderer.ensureBlankLine();
        this._renderer.emitLine("private static final String[] DATE_TIME_FORMATS = {");
        this._renderer.indent(() => this._renderer.indent(() => {
            this._renderer.emitLine("\"yyyy-MM-dd'T'HH:mm:ss.SX\",");
            this._renderer.emitLine("\"yyyy-MM-dd'T'HH:mm:ss.S\",");
            this._renderer.emitLine("\"yyyy-MM-dd'T'HH:mm:ssX\",");
            this._renderer.emitLine("\"yyyy-MM-dd'T'HH:mm:ss\",");
            this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss.SX",');
            this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss.S",');
            this._renderer.emitLine('"yyyy-MM-dd HH:mm:ssX",');
            this._renderer.emitLine('"yyyy-MM-dd HH:mm:ss",');
            this._renderer.emitLine('"HH:mm:ss.SZ",');
            this._renderer.emitLine('"HH:mm:ss.S",');
            this._renderer.emitLine('"HH:mm:ssZ",');
            this._renderer.emitLine('"HH:mm:ss",');
            this._renderer.emitLine('"yyyy-MM-dd",');
        }));
        this._renderer.emitLine("};");
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static Date parseAllDateTimeString(String str)", () => {
            this._renderer.emitBlock("for (String format : DATE_TIME_FORMATS)", () => {
                this._renderer.emitIgnoredTryCatchBlock(() => {
                    this._renderer.emitLine("return new SimpleDateFormat(format).parse(str);");
                });
            });
            this._renderer.emitLine("return null;");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeDateTime(Date datetime)", () => {
            this._renderer.emitLine("return new SimpleDateFormat(\"yyyy-MM-dd'T'hh:mm:ssZ\").format(datetime);");
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeDate(Date datetime)", () => {
            this._renderer.emitLine('return new SimpleDateFormat("yyyy-MM-dd").format(datetime);');
        });
        this._renderer.ensureBlankLine();
        this._renderer.emitBlock("public static String serializeTime(Date datetime)", () => {
            this._renderer.emitLine('return new SimpleDateFormat("hh:mm:ssZ").format(datetime);');
        });
    }
    convertStringToDateTime(variable) {
        return [this._className, ".parseAllDateTimeString(", variable, ")"];
    }
    convertStringToTime(variable) {
        return [this._className, ".parseAllDateTimeString(", variable, ")"];
    }
    convertStringToDate(variable) {
        return [this._className, ".parseAllDateTimeString(", variable, ")"];
    }
    convertDateTimeToString(variable) {
        return [this._className, ".serializeDateTime(", variable, ")"];
    }
    convertTimeToString(variable) {
        return [this._className, ".serializeTime(", variable, ")"];
    }
    convertDateToString(variable) {
        return [this._className, ".serializeDate(", variable, ")"];
    }
}
class JavaRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = new Map();
        this._haveEmittedLeadingComments = false;
        this._converterClassname = "Converter";
        this._converterKeywords = [];
        switch (_options.dateTimeProvider) {
            default:
            case "java8":
                this._dateTimeProvider = new Java8DateTimeProvider(this, this._converterClassname);
                break;
            case "legacy":
                this._dateTimeProvider = new JavaLegacyDateTimeProvider(this, this._converterClassname);
                break;
        }
    }
    forbiddenNamesForGlobalNamespace() {
        const keywords = [
            ...javaKeywords,
            ...this._converterKeywords,
            this._converterClassname,
            ...this._dateTimeProvider.keywords
        ];
        return keywords;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return this.getNameStyling("typeNamingFunction");
    }
    namerForObjectProperty() {
        return this.getNameStyling("propertyNamingFunction");
    }
    makeUnionMemberNamer() {
        return this.getNameStyling("propertyNamingFunction");
    }
    makeEnumCaseNamer() {
        return this.getNameStyling("enumCaseNamingFunction");
    }
    unionNeedsName(u) {
        return nullableFromUnion(u) === null;
    }
    namedTypeToNameForTopLevel(type) {
        // If the top-level type doesn't contain any classes or unions
        // we have to define a class just for the `FromJson` method, in
        // emitFromJsonForTopLevel.
        return directlyReachableSingleNamedType(type);
    }
    makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `get_${lookup(name)}`);
        const setterName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `set_${lookup(name)}`);
        return [getterName, setterName];
    }
    makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return getterAndSetterNames;
    }
    getNameStyling(convention) {
        const styling = {
            typeNamingFunction: funPrefixNamer("types", n => javaNameStyle(true, false, n, acronymStyle(this._options.acronymStyle))),
            propertyNamingFunction: funPrefixNamer("properties", n => javaNameStyle(false, false, n, acronymStyle(this._options.acronymStyle))),
            enumCaseNamingFunction: funPrefixNamer("enum-cases", n => javaNameStyle(true, true, n, acronymStyle(this._options.acronymStyle)))
        };
        return styling[convention];
    }
    fieldOrMethodName(methodName, topLevelName) {
        if (this.topLevels.size === 1) {
            return methodName;
        }
        return [topLevelName, capitalize(methodName)];
    }
    methodName(prefix, suffix, topLevelName) {
        if (this.topLevels.size === 1) {
            return [prefix, suffix];
        }
        return [prefix, topLevelName, suffix];
    }
    decoderName(topLevelName) {
        return this.fieldOrMethodName("fromJsonString", topLevelName);
    }
    encoderName(topLevelName) {
        return this.fieldOrMethodName("toJsonString", topLevelName);
    }
    readerGetterName(topLevelName) {
        return this.methodName("get", "ObjectReader", topLevelName);
    }
    writerGetterName(topLevelName) {
        return this.methodName("get", "ObjectWriter", topLevelName);
    }
    startFile(basename) {
        assert(this._currentFilename === undefined, "Previous file wasn't finished");
        // FIXME: The filenames should actually be Sourcelikes, too
        this._currentFilename = `${this.sourcelikeToString(basename)}.java`;
        // FIXME: Why is this necessary?
        this.ensureBlankLine();
        if (!this._haveEmittedLeadingComments && this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
            this.ensureBlankLine();
            this._haveEmittedLeadingComments = true;
        }
    }
    finishFile() {
        super.finishFile(defined(this._currentFilename));
        this._currentFilename = undefined;
    }
    emitPackageAndImports(imports) {
        this.emitLine("package ", this._options.packageName, ";");
        this.ensureBlankLine();
        for (const pkg of imports) {
            this.emitLine("import ", pkg, ";");
        }
    }
    emitFileHeader(fileName, imports) {
        this.startFile(fileName);
        this.emitPackageAndImports(imports);
        this.ensureBlankLine();
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    emitTryCatch(main, handler, exception = "Exception") {
        this.emitLine("try {");
        this.indent(main);
        this.emitLine("} catch (", exception, " ex) {");
        this.indent(handler);
        this.emitLine("}");
    }
    emitIgnoredTryCatchBlock(f) {
        this.emitTryCatch(f, () => this.emitLine("// Ignored"));
    }
    javaType(reference, t, withIssues = false) {
        return matchType(t, _anyType => maybeAnnotated(withIssues, anyTypeIssueAnnotation, "Object"), _nullType => maybeAnnotated(withIssues, nullTypeIssueAnnotation, "Object"), _boolType => (reference ? "Boolean" : "boolean"), _integerType => (reference ? "Long" : "long"), _doubleType => (reference ? "Double" : "double"), _stringType => "String", arrayType => {
            if (this._options.useList) {
                return ["List<", this.javaType(true, arrayType.items, withIssues), ">"];
            }
            else {
                return [this.javaType(false, arrayType.items, withIssues), "[]"];
            }
        }, classType => this.nameForNamedType(classType), mapType => ["Map<String, ", this.javaType(true, mapType.values, withIssues), ">"], enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return this.javaType(true, nullable, withIssues);
            return this.nameForNamedType(unionType);
        }, transformedStringType => {
            if (transformedStringType.kind === "time") {
                return this._dateTimeProvider.timeType;
            }
            if (transformedStringType.kind === "date") {
                return this._dateTimeProvider.dateType;
            }
            if (transformedStringType.kind === "date-time") {
                return this._dateTimeProvider.dateTimeType;
            }
            if (transformedStringType.kind === "uuid") {
                return "UUID";
            }
            return "String";
        });
    }
    javaImport(t) {
        return matchType(t, _anyType => [], _nullType => [], _boolType => [], _integerType => [], _doubleType => [], _stringType => [], arrayType => {
            if (this._options.useList) {
                return [...this.javaImport(arrayType.items), "java.util.List"];
            }
            else {
                return [...this.javaImport(arrayType.items)];
            }
        }, _classType => [], mapType => [...this.javaImport(mapType.values), "java.util.Map"], _enumType => [], unionType => {
            const imports = [];
            unionType.members.forEach(type => this.javaImport(type).forEach(imp => imports.push(imp)));
            return imports;
        }, transformedStringType => {
            if (transformedStringType.kind === "time") {
                return this._dateTimeProvider.timeImports;
            }
            if (transformedStringType.kind === "date") {
                return this._dateTimeProvider.dateImports;
            }
            if (transformedStringType.kind === "date-time") {
                return this._dateTimeProvider.dateTimeImports;
            }
            if (transformedStringType.kind === "uuid") {
                return ["java.util.UUID"];
            }
            return [];
        });
    }
    javaTypeWithoutGenerics(reference, t) {
        if (t instanceof ArrayType) {
            if (this._options.useList) {
                return ["List"];
            }
            else {
                return [this.javaTypeWithoutGenerics(false, t.items), "[]"];
            }
        }
        else if (t instanceof MapType) {
            return "Map";
        }
        else if (t instanceof UnionType) {
            const nullable = nullableFromUnion(t);
            if (nullable !== null)
                return this.javaTypeWithoutGenerics(true, nullable);
            return this.nameForNamedType(t);
        }
        else {
            return this.javaType(reference, t);
        }
    }
    emitClassAttributes(_c, _className) {
        if (this._options.lombok) {
            this.emitLine("@lombok.Data");
        }
    }
    annotationsForAccessor(_c, _className, _propertyName, _jsonName, _p, _isSetter) {
        return [];
    }
    importsForType(t) {
        if (t instanceof ClassType) {
            return [];
        }
        if (t instanceof UnionType) {
            return ["java.io.IOException"];
        }
        if (t instanceof EnumType) {
            return ["java.io.IOException"];
        }
        return assertNever(t);
    }
    importsForClass(c) {
        const imports = [];
        this.forEachClassProperty(c, "none", (_name, _jsonName, p) => {
            this.javaImport(p.type).forEach(imp => imports.push(imp));
        });
        imports.sort();
        return [...new Set(imports)];
    }
    importsForUnionMembers(u) {
        const imports = [];
        const [, nonNulls] = removeNullFromUnion(u);
        this.forEachUnionMember(u, nonNulls, "none", null, (_fieldName, t) => {
            this.javaImport(t).forEach(imp => imports.push(imp));
        });
        imports.sort();
        return [...new Set(imports)];
    }
    emitClassDefinition(c, className) {
        let imports = [...this.importsForType(c), ...this.importsForClass(c)];
        this.emitFileHeader(className, imports);
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAttributes(c, className);
        this.emitBlock(["public class ", className], () => {
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                if (this._options.lombok && this._options.lombokCopyAnnotations) {
                    const getter = this.annotationsForAccessor(c, className, name, jsonName, p, false);
                    const setter = this.annotationsForAccessor(c, className, name, jsonName, p, true);
                    if (getter.length !== 0) {
                        this.emitLine("@lombok.Getter(onMethod_ = {" + getter.join(", ") + "})");
                    }
                    if (setter.length !== 0) {
                        this.emitLine("@lombok.Setter(onMethod_ = {" + setter.join(", ") + "})");
                    }
                }
                this.emitLine("private ", this.javaType(false, p.type, true), " ", name, ";");
            });
            if (!this._options.lombok) {
                this.forEachClassProperty(c, "leading-and-interposing", (name, jsonName, p) => {
                    this.emitDescription(this.descriptionForClassProperty(c, jsonName));
                    const [getterName, setterName] = defined(this._gettersAndSettersForPropertyName.get(name));
                    const rendered = this.javaType(false, p.type);
                    this.annotationsForAccessor(c, className, name, jsonName, p, false).forEach(annotation => this.emitLine(annotation));
                    this.emitLine("public ", rendered, " ", getterName, "() { return ", name, "; }");
                    this.annotationsForAccessor(c, className, name, jsonName, p, true).forEach(annotation => this.emitLine(annotation));
                    this.emitLine("public void ", setterName, "(", rendered, " value) { this.", name, " = value; }");
                });
            }
        });
        this.finishFile();
    }
    unionField(u, t, withIssues = false) {
        const fieldType = this.javaType(true, t, withIssues);
        // FIXME: "Value" should be part of the name.
        const fieldName = [this.nameForUnionMember(u, t), "Value"];
        return { fieldType, fieldName };
    }
    emitUnionAttributes(_u, _unionName) {
        // empty
    }
    emitUnionSerializer(_u, _unionName) {
        // empty
    }
    emitUnionDefinition(u, unionName) {
        const imports = [...this.importsForType(u), ...this.importsForUnionMembers(u)];
        this.emitFileHeader(unionName, imports);
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = removeNullFromUnion(u);
        this.emitUnionAttributes(u, unionName);
        this.emitBlock(["public class ", unionName], () => {
            for (const t of nonNulls) {
                const { fieldType, fieldName } = this.unionField(u, t, true);
                this.emitLine("public ", fieldType, " ", fieldName, ";");
            }
            this.emitUnionSerializer(u, unionName);
        });
        this.finishFile();
    }
    emitEnumSerializationAttributes(_e) {
        // Empty
    }
    emitEnumDeserializationAttributes(_e) {
        // Empty
    }
    emitEnumDefinition(e, enumName) {
        this.emitFileHeader(enumName, this.importsForType(e));
        this.emitDescription(this.descriptionForType(e));
        const caseNames = [];
        this.forEachEnumCase(e, "none", name => {
            if (caseNames.length > 0)
                caseNames.push(", ");
            caseNames.push(name);
        });
        caseNames.push(";");
        this.emitBlock(["public enum ", enumName], () => {
            this.emitLine(caseNames);
            this.ensureBlankLine();
            this.emitEnumSerializationAttributes(e);
            this.emitBlock("public String toValue()", () => {
                this.emitLine("switch (this) {");
                this.indent(() => {
                    this.forEachEnumCase(e, "none", (name, jsonName) => {
                        this.emitLine("case ", name, ': return "', stringEscape$4(jsonName), '";');
                    });
                });
                this.emitLine("}");
                this.emitLine("return null;");
            });
            this.ensureBlankLine();
            this.emitEnumDeserializationAttributes(e);
            this.emitBlock(["public static ", enumName, " forValue(String value) throws IOException"], () => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    this.emitLine('if (value.equals("', stringEscape$4(jsonName), '")) return ', name, ";");
                });
                this.emitLine('throw new IOException("Cannot deserialize ', enumName, '");');
            });
        });
        this.finishFile();
    }
    emitSourceStructure() {
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
    }
}
class JacksonRenderer extends JavaRenderer {
    constructor(targetLanguage, renderContext, options) {
        super(targetLanguage, renderContext, options);
        this._converterKeywords = [
            "JsonProperty",
            "JsonDeserialize",
            "JsonDeserializer",
            "JsonSerialize",
            "JsonSerializer",
            "JsonParser",
            "JsonProcessingException",
            "DeserializationContext",
            "SerializerProvider"
        ];
    }
    emitClassAttributes(c, _className) {
        if (c.getProperties().size === 0)
            this.emitLine("@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.NONE)");
        super.emitClassAttributes(c, _className);
    }
    annotationsForAccessor(_c, _className, _propertyName, jsonName, p, _isSetter) {
        const superAnnotations = super.annotationsForAccessor(_c, _className, _propertyName, jsonName, p, _isSetter);
        const annotations = ['@JsonProperty("' + stringEscape$4(jsonName) + '")'];
        switch (p.type.kind) {
            case "date-time":
                this._dateTimeProvider.dateTimeJacksonAnnotations.forEach(annotation => annotations.push(annotation));
                break;
            case "date":
                this._dateTimeProvider.dateJacksonAnnotations.forEach(annotation => annotations.push(annotation));
                break;
            case "time":
                this._dateTimeProvider.timeJacksonAnnotations.forEach(annotation => annotations.push(annotation));
                break;
        }
        return [...superAnnotations, ...annotations];
    }
    importsForType(t) {
        if (t instanceof ClassType) {
            const imports = super.importsForType(t);
            imports.push("com.fasterxml.jackson.annotation.*");
            return imports;
        }
        if (t instanceof UnionType) {
            const imports = super.importsForType(t);
            imports.push("java.io.IOException", "com.fasterxml.jackson.core.*", "com.fasterxml.jackson.databind.*", "com.fasterxml.jackson.databind.annotation.*");
            if (this._options.useList) {
                imports.push("com.fasterxml.jackson.core.type.*");
            }
            return imports;
        }
        if (t instanceof EnumType) {
            const imports = super.importsForType(t);
            imports.push("com.fasterxml.jackson.annotation.*");
            return imports;
        }
        return assertNever(t);
    }
    emitUnionAttributes(_u, unionName) {
        this.emitLine("@JsonDeserialize(using = ", unionName, ".Deserializer.class)");
        this.emitLine("@JsonSerialize(using = ", unionName, ".Serializer.class)");
    }
    emitUnionSerializer(u, unionName) {
        const stringBasedObjects = ["uuid", "time", "date", "date-time"];
        const tokenCase = (tokenType) => {
            this.emitLine("case ", tokenType, ":");
        };
        const emitNullDeserializer = () => {
            this.indent(() => {
                tokenCase("VALUE_NULL");
                this.indent(() => this.emitLine("break;"));
            });
        };
        const emitDeserializerCodeForStringObjects = (fieldName, kind, parseFrom) => {
            switch (kind) {
                case "date":
                    this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToDate(parseFrom), ";");
                    break;
                case "time":
                    this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToTime(parseFrom), ";");
                    break;
                case "date-time":
                    this.emitLine("value.", fieldName, " = ", this._dateTimeProvider.convertStringToDateTime(parseFrom), ";");
                    break;
                case "uuid":
                    this.emitLine("value.", fieldName, " = UUID.fromString(", parseFrom, ");");
                    break;
                default:
                    return panic("Requested type isnt an object!");
            }
        };
        const emitDeserializeType = (t, variableFieldName = "") => {
            const { fieldName } = this.unionField(u, t);
            const rendered = this.javaTypeWithoutGenerics(true, t);
            if (this._options.useList && t instanceof ArrayType) {
                this.emitLine("value.", fieldName, " = jsonParser.readValueAs(new TypeReference<", rendered, ">() {});");
            }
            else if (stringBasedObjects.some(stringBasedTypeKind => t.kind === stringBasedTypeKind)) {
                emitDeserializerCodeForStringObjects(fieldName, t.kind, variableFieldName);
            }
            else if (t.kind === "string") {
                this.emitLine("value.", fieldName, " = ", variableFieldName, ";");
            }
            else if (t.kind === "enum") {
                const { fieldType } = this.unionField(u, t, true);
                this.emitLine("value.", fieldName, " = ", fieldType, ".forValue(", variableFieldName, ");");
            }
            else {
                this.emitLine("value.", fieldName, " = jsonParser.readValueAs(", rendered, ".class);");
            }
        };
        const emitDeserializer = (tokenTypes, kind) => {
            const t = u.findMember(kind);
            if (t === undefined)
                return;
            this.indent(() => {
                for (const tokenType of tokenTypes) {
                    tokenCase(tokenType);
                }
                this.indent(() => {
                    emitDeserializeType(t);
                    this.emitLine("break;");
                });
            });
        };
        const emitStringDeserializer = () => {
            const enumType = u.findMember("enum");
            const stringType = u.findMember("string");
            if (stringBasedObjects.every(kind => u.findMember(kind) === undefined) &&
                stringType === undefined &&
                enumType === undefined)
                return;
            this.indent(() => {
                tokenCase("VALUE_STRING");
                this.indent(() => {
                    const fromVariable = "string";
                    this.emitLine("String " + fromVariable + " = jsonParser.readValueAs(String.class);");
                    stringBasedObjects.forEach(kind => {
                        const type = u.findMember(kind);
                        if (type !== undefined) {
                            this.emitIgnoredTryCatchBlock(() => {
                                emitDeserializeType(type, fromVariable);
                            });
                        }
                    });
                    if (enumType !== undefined) {
                        this.emitIgnoredTryCatchBlock(() => {
                            emitDeserializeType(enumType, fromVariable);
                        });
                    }
                    // String should be the last one if exists, because it cannot fail, unlike the parsers.
                    if (stringType !== undefined) {
                        emitDeserializeType(stringType, fromVariable);
                    }
                    this.emitLine("break;");
                });
            });
        };
        const emitNumberDeserializer = () => {
            const integerType = u.findMember("integer");
            const doubleType = u.findMember("double");
            if (doubleType === undefined && integerType === undefined)
                return;
            this.indent(() => {
                tokenCase("VALUE_NUMBER_INT");
                if (integerType !== undefined) {
                    this.indent(() => {
                        emitDeserializeType(integerType);
                        this.emitLine("break;");
                    });
                }
                if (doubleType !== undefined) {
                    tokenCase("VALUE_NUMBER_FLOAT");
                    this.indent(() => {
                        emitDeserializeType(doubleType);
                        this.emitLine("break;");
                    });
                }
            });
        };
        const customObjectSerializer = ["time", "date", "date-time"];
        const serializerCodeForType = (type, fieldName) => {
            switch (type.kind) {
                case "date":
                    return this._dateTimeProvider.convertDateToString(fieldName);
                case "time":
                    return this._dateTimeProvider.convertTimeToString(fieldName);
                case "date-time":
                    return this._dateTimeProvider.convertDateTimeToString(fieldName);
                default:
                    return panic("Requested type doesn't have custom serializer code!");
            }
        };
        const emitSerializeType = (t) => {
            let { fieldName } = this.unionField(u, t, true);
            this.emitBlock(["if (obj.", fieldName, " != null)"], () => {
                if (customObjectSerializer.some(customSerializerType => t.kind === customSerializerType)) {
                    this.emitLine("jsonGenerator.writeObject(", serializerCodeForType(t, ["obj.", fieldName]), ");");
                }
                else {
                    this.emitLine("jsonGenerator.writeObject(obj.", fieldName, ");");
                }
                this.emitLine("return;");
            });
        };
        const [maybeNull, nonNulls] = removeNullFromUnion(u);
        this.ensureBlankLine();
        this.emitBlock(["static class Deserializer extends JsonDeserializer<", unionName, ">"], () => {
            this.emitLine("@Override");
            this.emitBlock([
                "public ",
                unionName,
                " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException"
            ], () => {
                this.emitLine(unionName, " value = new ", unionName, "();");
                this.emitLine("switch (jsonParser.currentToken()) {");
                if (maybeNull !== null)
                    emitNullDeserializer();
                emitNumberDeserializer();
                emitDeserializer(["VALUE_TRUE", "VALUE_FALSE"], "bool");
                emitStringDeserializer();
                emitDeserializer(["START_ARRAY"], "array");
                emitDeserializer(["START_OBJECT"], "class");
                emitDeserializer(["START_OBJECT"], "map");
                this.indent(() => this.emitLine('default: throw new IOException("Cannot deserialize ', unionName, '");'));
                this.emitLine("}");
                this.emitLine("return value;");
            });
        });
        this.ensureBlankLine();
        this.emitBlock(["static class Serializer extends JsonSerializer<", unionName, ">"], () => {
            this.emitLine("@Override");
            this.emitBlock([
                "public void serialize(",
                unionName,
                " obj, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException"
            ], () => {
                for (const t of nonNulls) {
                    emitSerializeType(t);
                }
                if (maybeNull !== null) {
                    this.emitLine("jsonGenerator.writeNull();");
                }
                else {
                    this.emitLine('throw new IOException("', unionName, ' must not be null");');
                }
            });
        });
    }
    emitEnumSerializationAttributes(_e) {
        this.emitLine("@JsonValue");
    }
    emitEnumDeserializationAttributes(_e) {
        this.emitLine("@JsonCreator");
    }
    emitOffsetDateTimeConverterModule() {
        this.emitLine("SimpleModule module = new SimpleModule();");
        if (this._dateTimeProvider.shouldEmitDateTimeConverter) {
            this.emitLine("module.addDeserializer(", this._dateTimeProvider.dateTimeType, ".class, new JsonDeserializer<", this._dateTimeProvider.dateTimeType, ">() {");
            this.indent(() => {
                this.emitLine("@Override");
                this.emitBlock([
                    "public ",
                    this._dateTimeProvider.dateTimeType,
                    " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
                    "throws IOException, JsonProcessingException"
                ], () => {
                    this.emitLine("String value = jsonParser.getText();");
                    this.emitLine("return ", this._dateTimeProvider.convertStringToDateTime("value"), ";");
                });
            });
            this.emitLine("});");
        }
        if (!this._dateTimeProvider.shouldEmitTimeConverter) {
            this.emitLine("module.addDeserializer(", this._dateTimeProvider.timeType, ".class, new JsonDeserializer<", this._dateTimeProvider.timeType, ">() {");
            this.indent(() => {
                this.emitLine("@Override");
                this.emitBlock([
                    "public ",
                    this._dateTimeProvider.timeType,
                    " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
                    "throws IOException, JsonProcessingException"
                ], () => {
                    this.emitLine("String value = jsonParser.getText();");
                    this.emitLine("return ", this._dateTimeProvider.convertStringToTime("value"), ";");
                });
            });
            this.emitLine("});");
        }
        if (!this._dateTimeProvider.shouldEmitDateConverter) {
            this.emitLine("module.addDeserializer(", this._dateTimeProvider.dateType, ".class, new JsonDeserializer<", this._dateTimeProvider.dateType, ">() {");
            this.indent(() => {
                this.emitLine("@Override");
                this.emitBlock([
                    "public ",
                    this._dateTimeProvider.dateType,
                    " deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) ",
                    "throws IOException, JsonProcessingException"
                ], () => {
                    this.emitLine("String value = jsonParser.getText();");
                    this.emitLine("return ", this._dateTimeProvider.convertStringToDate("value"), ";");
                });
            });
            this.emitLine("});");
        }
        this.emitLine("mapper.registerModule(module);");
    }
    emitConverterClass() {
        this.startFile(this._converterClassname);
        this.emitCommentLines([
            "To use this code, add the following Maven dependency to your project:",
            "",
            this._options.lombok ? "    org.projectlombok : lombok : 1.18.2" : "",
            "    com.fasterxml.jackson.core     : jackson-databind          : 2.9.0",
            this._options.dateTimeProvider === "java8"
                ? "    com.fasterxml.jackson.datatype : jackson-datatype-jsr310   : 2.9.0"
                : "",
            "",
            "Import this package:",
            ""
        ]);
        this.emitLine("//     import ", this._options.packageName, ".Converter;");
        this.emitMultiline(`//
// Then you can deserialize a JSON string with
//`);
        this.forEachTopLevel("none", (t, name) => {
            this.emitLine("//     ", this.javaType(false, t), " data = Converter.", this.decoderName(name), "(jsonString);");
        });
        this.ensureBlankLine();
        const imports = [
            "java.io.IOException",
            "com.fasterxml.jackson.databind.*",
            "com.fasterxml.jackson.databind.module.SimpleModule",
            "com.fasterxml.jackson.core.JsonParser",
            "com.fasterxml.jackson.core.JsonProcessingException",
            "java.util.*"
        ].concat(this._dateTimeProvider.converterImports);
        this.emitPackageAndImports(imports);
        this.ensureBlankLine();
        this.emitBlock(["public class Converter"], () => {
            this.emitLine("// Date-time helpers");
            this._dateTimeProvider.emitDateTimeConverters();
            this.emitLine("// Serialize/deserialize helpers");
            this.forEachTopLevel("leading-and-interposing", (topLevelType, topLevelName) => {
                const topLevelTypeRendered = this.javaType(false, topLevelType);
                this.emitBlock([
                    "public static ",
                    topLevelTypeRendered,
                    " ",
                    this.decoderName(topLevelName),
                    "(String json) throws IOException"
                ], () => {
                    this.emitLine("return ", this.readerGetterName(topLevelName), "().readValue(json);");
                });
                this.ensureBlankLine();
                this.emitBlock([
                    "public static String ",
                    this.encoderName(topLevelName),
                    "(",
                    topLevelTypeRendered,
                    " obj) throws JsonProcessingException"
                ], () => {
                    this.emitLine("return ", this.writerGetterName(topLevelName), "().writeValueAsString(obj);");
                });
            });
            this.forEachTopLevel("leading-and-interposing", (topLevelType, topLevelName) => {
                const readerName = this.fieldOrMethodName("reader", topLevelName);
                const writerName = this.fieldOrMethodName("writer", topLevelName);
                this.emitLine("private static ObjectReader ", readerName, ";");
                this.emitLine("private static ObjectWriter ", writerName, ";");
                this.ensureBlankLine();
                this.emitBlock(["private static void ", this.methodName("instantiate", "Mapper", topLevelName), "()"], () => {
                    const renderedForClass = this.javaTypeWithoutGenerics(false, topLevelType);
                    this.emitLine("ObjectMapper mapper = new ObjectMapper();");
                    this.emitLine("mapper.findAndRegisterModules();");
                    this.emitLine("mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);");
                    this.emitLine("mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);");
                    this.emitOffsetDateTimeConverterModule();
                    this.emitLine(readerName, " = mapper.readerFor(", renderedForClass, ".class);");
                    this.emitLine(writerName, " = mapper.writerFor(", renderedForClass, ".class);");
                });
                this.ensureBlankLine();
                this.emitBlock(["private static ObjectReader ", this.readerGetterName(topLevelName), "()"], () => {
                    this.emitLine("if (", readerName, " == null) ", this.methodName("instantiate", "Mapper", topLevelName), "();");
                    this.emitLine("return ", readerName, ";");
                });
                this.ensureBlankLine();
                this.emitBlock(["private static ObjectWriter ", this.writerGetterName(topLevelName), "()"], () => {
                    this.emitLine("if (", writerName, " == null) ", this.methodName("instantiate", "Mapper", topLevelName), "();");
                    this.emitLine("return ", writerName, ";");
                });
            });
        });
        this.finishFile();
    }
    emitSourceStructure() {
        this.emitConverterClass();
        super.emitSourceStructure();
    }
}

var ConvertersOptions;
(function (ConvertersOptions) {
    ConvertersOptions["AllObjects"] = "all-objects";
    ConvertersOptions["TopLevel"] = "top-level";
})(ConvertersOptions || (ConvertersOptions = {}));
function convertersOption() {
    return new EnumOption("converters", "Which converters to generate (top-level by default)", [
        [ConvertersOptions.TopLevel, ConvertersOptions.TopLevel],
        [ConvertersOptions.AllObjects, ConvertersOptions.AllObjects]
    ], ConvertersOptions.TopLevel, "secondary");
}

/* eslint-disable */
// Taken from https://github.com/Microsoft/TypeScript
function lookupInUnicodeMap(code, map) {
    // Bail out quickly if it couldn't possibly be in the map.
    if (code < map[0]) {
        return false;
    }
    // Perform binary search in one of the Unicode range maps
    let lo = 0;
    let hi = map.length;
    let mid;
    while (lo + 1 < hi) {
        mid = lo + (hi - lo) / 2;
        // mid has to be even to catch a range's beginning
        mid -= mid % 2;
        if (map[mid] <= code && code <= map[mid + 1]) {
            return true;
        }
        if (code < map[mid]) {
            hi = mid;
        }
        else {
            lo = mid + 2;
        }
    }
    return false;
}
function isES3IdentifierStart(ch) {
    return ((ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */) ||
        (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) ||
        ch === 36 /* CharacterCodes.$ */ ||
        ch === 95 /* CharacterCodes._ */ ||
        (ch > 127 /* CharacterCodes.maxAsciiCharacter */ && lookupInUnicodeMap(ch, unicodeES3IdentifierStart)));
}
function isES3IdentifierPart(ch) {
    return ((ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */) ||
        (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) ||
        (ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) ||
        ch === 36 /* CharacterCodes.$ */ ||
        ch === 95 /* CharacterCodes._ */ ||
        (ch > 127 /* CharacterCodes.maxAsciiCharacter */ && lookupInUnicodeMap(ch, unicodeES3IdentifierPart)));
}
/*
    As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
    IdentifierStart ::
        Can contain Unicode 3.0.0 categories:
        Uppercase letter (Lu),
        Lowercase letter (Ll),
        Titlecase letter (Lt),
        Modifier letter (Lm),
        Other letter (Lo), or
        Letter number (Nl).
    IdentifierPart :: =
        Can contain IdentifierStart + Unicode 3.0.0 categories:
        Non-spacing mark (Mn),
        Combining spacing mark (Mc),
        Decimal number (Nd), or
        Connector punctuation (Pc).
    Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
    http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
*/
const unicodeES3IdentifierStart = [
    170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736,
    740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164,
    1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522,
    1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309,
    2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489,
    2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616,
    2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739,
    2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870,
    2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975,
    2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168,
    3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344,
    3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,
    3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747,
    3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840,
    3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342,
    4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698,
    4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805,
    4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024,
    5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929,
    7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064,
    8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,
    8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490,
    8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436,
    12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869,
    40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310,
    64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967,
    65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479,
    65482, 65487, 65490, 65495, 65498, 65500
];
const unicodeES3IdentifierPart = [
    170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736,
    740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011,
    1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377,
    1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594,
    1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920,
    1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448,
    2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524,
    2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614,
    2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693,
    2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765,
    2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870,
    2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954,
    2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006,
    3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123,
    3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214,
    3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297,
    3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415,
    3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530,
    3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719,
    3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769,
    3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893,
    3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038,
    4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352,
    4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701,
    4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,
    4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977,
    5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272,
    6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,
    8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160,
    8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467,
    8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293,
    12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549,
    12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256,
    64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326,
    64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136,
    65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474,
    65479, 65482, 65487, 65490, 65495, 65498, 65500
];

const javaScriptOptions = {
    acronymStyle: acronymOption(AcronymStyleOptions.Pascal),
    runtimeTypecheck: new BooleanOption("runtime-typecheck", "Verify JSON.parse results at runtime", true),
    runtimeTypecheckIgnoreUnknownProperties: new BooleanOption("runtime-typecheck-ignore-unknown-properties", "Ignore unknown properties when verifying at runtime", false, "secondary"),
    converters: convertersOption(),
    rawType: new EnumOption("raw-type", "Type of raw input (json by default)", [
        ["json", "json"],
        ["any", "any"]
    ], "json", "secondary")
};
class JavaScriptTargetLanguage extends TargetLanguage {
    constructor(displayName = "JavaScript", names = ["javascript", "js", "jsx"], extension = "js") {
        super(displayName, names, extension);
    }
    getOptions() {
        return [
            javaScriptOptions.runtimeTypecheck,
            javaScriptOptions.runtimeTypecheckIgnoreUnknownProperties,
            javaScriptOptions.acronymStyle,
            javaScriptOptions.converters,
            javaScriptOptions.rawType
        ];
    }
    get stringTypeMapping() {
        const mapping = new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("date-time", dateTimeType);
        return mapping;
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsFullObjectType() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptRenderer(this, renderContext, getOptionValues(javaScriptOptions, untypedOptionValues));
    }
}
const legalizeName$a = utf16LegalizeCharacters(isES3IdentifierPart);
const identityNamingFunction$1 = funPrefixNamer("properties", s => s);
class JavaScriptRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
    }
    nameStyle(original, upper) {
        const acronyms = acronymStyle(this._jsOptions.acronymStyle);
        const words = splitIntoWords(original);
        return combineWords(words, legalizeName$a, upper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, upper ? (s) => capitalize(acronyms(s)) : allLowerWordStyle, acronyms, "", isES3IdentifierStart);
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("types", s => this.nameStyle(s, true));
    }
    namerForObjectProperty() {
        return identityNamingFunction$1;
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("enum-cases", s => this.nameStyle(s, true));
    }
    namedTypeToNameForTopLevel(type) {
        return directlyReachableSingleNamedType(type);
    }
    makeNameForProperty(c, className, p, jsonName, _assignedName) {
        // Ignore the assigned name
        return super.makeNameForProperty(c, className, p, jsonName, undefined);
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    typeMapTypeFor(t) {
        if (["class", "object", "enum"].includes(t.kind)) {
            return ['r("', this.nameForNamedType(t), '")'];
        }
        return matchType(t, _anyType => '"any"', _nullType => "null", _boolType => "true", _integerType => "0", _doubleType => "3.14", _stringType => '""', arrayType => ["a(", this.typeMapTypeFor(arrayType.items), ")"], _classType => panic("We handled this above"), mapType => ["m(", this.typeMapTypeFor(mapType.values), ")"], _enumType => panic("We handled this above"), unionType => {
            const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type));
            return ["u(", ...collectionUtils.arrayIntercalate(", ", children), ")"];
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return "Date";
            }
            return '""';
        });
    }
    typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        if (!p.isOptional) {
            return typeMap;
        }
        return ["u(undefined, ", typeMap, ")"];
    }
    emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
    }
    emitTypeMap() {
        const { any: anyAnnotation } = this.typeAnnotations;
        this.emitBlock(`const typeMap${anyAnnotation} = `, ";", () => {
            this.forEachObject("none", (t, name) => {
                const additionalProperties = t.getAdditionalProperties();
                const additional = additionalProperties !== undefined ? this.typeMapTypeFor(additionalProperties) : "false";
                this.emitLine('"', name, '": o([');
                this.indent(() => {
                    this.forEachClassProperty(t, "none", (propName, jsonName, property) => {
                        this.emitLine('{ json: "', utf16StringEscape(jsonName), '", js: "', modifySource(utf16StringEscape, propName), '", typ: ', this.typeMapTypeForProperty(property), " },");
                    });
                });
                this.emitLine("], ", additional, "),");
            });
            this.forEachEnum("none", (e, name) => {
                this.emitLine('"', name, '": [');
                this.indent(() => {
                    this.forEachEnumCase(e, "none", (_caseName, jsonName) => {
                        this.emitLine(`"${utf16StringEscape(jsonName)}",`);
                    });
                });
                this.emitLine("],");
            });
        });
    }
    deserializerFunctionName(name) {
        return ["to", name];
    }
    deserializerFunctionLine(_t, name) {
        return ["function ", this.deserializerFunctionName(name), "(json)"];
    }
    serializerFunctionName(name) {
        const camelCaseName = modifySource(camelCase, name);
        return [camelCaseName, "ToJson"];
    }
    serializerFunctionLine(_t, name) {
        return ["function ", this.serializerFunctionName(name), "(value)"];
    }
    get moduleLine() {
        return undefined;
    }
    get castFunctionLines() {
        return ["function cast(val, typ)", "function uncast(val, typ)"];
    }
    get typeAnnotations() {
        return {
            any: "",
            anyArray: "",
            anyMap: "",
            string: "",
            stringArray: "",
            boolean: "",
            never: ""
        };
    }
    emitConvertModuleBody() {
        const converter = (t, name) => {
            const typeMap = this.typeMapTypeFor(t);
            this.emitBlock([this.deserializerFunctionLine(t, name), " "], "", () => {
                const parsedJson = this._jsOptions.rawType === "json" ? "JSON.parse(json)" : "json";
                if (!this._jsOptions.runtimeTypecheck) {
                    this.emitLine("return ", parsedJson, ";");
                }
                else {
                    this.emitLine("return cast(", parsedJson, ", ", typeMap, ");");
                }
            });
            this.ensureBlankLine();
            this.emitBlock([this.serializerFunctionLine(t, name), " "], "", () => {
                if (this._jsOptions.rawType === "json") {
                    if (!this._jsOptions.runtimeTypecheck) {
                        this.emitLine("return JSON.stringify(value);");
                    }
                    else {
                        this.emitLine("return JSON.stringify(uncast(value, ", typeMap, "), null, 2);");
                    }
                }
                else {
                    if (!this._jsOptions.runtimeTypecheck) {
                        this.emitLine("return value;");
                    }
                    else {
                        this.emitLine("return uncast(value, ", typeMap, ");");
                    }
                }
            });
        };
        switch (this._jsOptions.converters) {
            case ConvertersOptions.AllObjects:
                this.forEachObject("interposing", converter);
                break;
            default:
                this.forEachTopLevel("interposing", converter);
                break;
        }
    }
    emitConvertModuleHelpers() {
        if (this._jsOptions.runtimeTypecheck) {
            const { any: anyAnnotation, anyArray: anyArrayAnnotation, anyMap: anyMapAnnotation, string: stringAnnotation, stringArray: stringArrayAnnotation, never: neverAnnotation } = this.typeAnnotations;
            this.ensureBlankLine();
            this
                .emitMultiline(`function invalidValue(typ${anyAnnotation}, val${anyAnnotation}, key${anyAnnotation}, parent${anyAnnotation} = '')${neverAnnotation} {
    const prettyTyp = prettyTypeName(typ);
    const parentText = parent ? \` on \${parent}\` : '';
    const keyText = key ? \` for key "\${key}"\` : '';
    throw Error(\`Invalid value\${keyText}\${parentText}. Expected \${prettyTyp} but got \${JSON.stringify(val)}\`);
}

function prettyTypeName(typ${anyAnnotation})${stringAnnotation} {
    if (Array.isArray(typ)) {
        if (typ.length === 2 && typ[0] === undefined) {
            return \`an optional \${prettyTypeName(typ[1])}\`;
        } else {
            return \`one of [\${typ.map(a => { return prettyTypeName(a); }).join(", ")}]\`;
        }
    } else if (typeof typ === "object" && typ.literal !== undefined) {
        return typ.literal;
    } else {
        return typeof typ;
    }
}

function jsonToJSProps(typ${anyAnnotation})${anyAnnotation} {
    if (typ.jsonToJS === undefined) {
        const map${anyAnnotation} = {};
        typ.props.forEach((p${anyAnnotation}) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ${anyAnnotation})${anyAnnotation} {
    if (typ.jsToJSON === undefined) {
        const map${anyAnnotation} = {};
        typ.props.forEach((p${anyAnnotation}) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val${anyAnnotation}, typ${anyAnnotation}, getProps${anyAnnotation}, key${anyAnnotation} = '', parent${anyAnnotation} = '')${anyAnnotation} {
    function transformPrimitive(typ${stringAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key, parent);
    }

    function transformUnion(typs${anyArrayAnnotation}, val${anyAnnotation})${anyAnnotation} {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val, key, parent);
    }

    function transformEnum(cases${stringArrayAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases.map(a => { return l(a); }), val, key, parent);
    }

    function transformArray(typ${anyAnnotation}, val${anyAnnotation})${anyAnnotation} {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(l("array"), val, key, parent);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val${anyAnnotation})${anyAnnotation} {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(l("Date"), val, key, parent);
        }
        return d;
    }

    function transformObject(props${anyMapAnnotation}, additional${anyAnnotation}, val${anyAnnotation})${anyAnnotation} {
        if (val === null || typeof val !== "object" || Array.isArray(val)) {
            return invalidValue(l(ref || "object"), val, key, parent);
        }
        const result${anyAnnotation} = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, key, ref);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = ${this._jsOptions.runtimeTypecheckIgnoreUnknownProperties
                ? "val[key]"
                : "transform(val[key], additional, getProps, key, ref)"};
            }
        });
        return result;
    }

    if (typ === "any") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val, key, parent);
    }
    if (typ === false) return invalidValue(typ, val, key, parent);
    let ref${anyAnnotation} = undefined;
    while (typeof typ === "object" && typ.ref !== undefined) {
        ref = typ.ref;
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === "object") {
        return typ.hasOwnProperty("unionMembers") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty("arrayItems")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty("props")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val, key, parent);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== "number") return transformDate(val);
    return transformPrimitive(typ, val);
}

${this.castFunctionLines[0]} {
    return transform(val, typ, jsonToJSProps);
}

${this.castFunctionLines[1]} {
    return transform(val, typ, jsToJSONProps);
}

function l(typ${anyAnnotation}) {
    return { literal: typ };
}

function a(typ${anyAnnotation}) {
    return { arrayItems: typ };
}

function u(...typs${anyArrayAnnotation}) {
    return { unionMembers: typs };
}

function o(props${anyArrayAnnotation}, additional${anyAnnotation}) {
    return { props, additional };
}

function m(additional${anyAnnotation}) {
    return { props: [], additional };
}

function r(name${stringAnnotation}) {
    return { ref: name };
}
`);
            this.emitTypeMap();
        }
    }
    emitConvertModule() {
        this.ensureBlankLine();
        this.emitMultiline(`// Converts JSON ${this._jsOptions.rawType === "json" ? "strings" : "types"} to/from your types`);
        if (this._jsOptions.runtimeTypecheck) {
            this.emitMultiline(`// and asserts the results${this._jsOptions.rawType === "json" ? " of JSON.parse" : ""} at runtime`);
        }
        const moduleLine = this.moduleLine;
        if (moduleLine === undefined) {
            this.emitConvertModuleBody();
        }
        else {
            this.emitBlock([moduleLine, " "], "", () => this.emitConvertModuleBody());
        }
    }
    emitTypes() {
        return;
    }
    emitUsageImportComment() {
        this.emitLine('//   const Convert = require("./file");');
    }
    emitUsageComments() {
        this.emitMultiline(`// To parse this data:
//`);
        this.emitUsageImportComment();
        this.emitLine("//");
        this.forEachTopLevel("none", (_t, name) => {
            const camelCaseName = modifySource(camelCase, name);
            this.emitLine("//   const ", camelCaseName, " = Convert.to", name, "(json);");
        });
        if (this._jsOptions.runtimeTypecheck) {
            this.emitLine("//");
            this.emitLine("// These functions will throw an error if the JSON doesn't");
            this.emitLine("// match the expected interface, even if the JSON is valid.");
        }
    }
    emitModuleExports() {
        this.ensureBlankLine();
        this.emitBlock("module.exports = ", ";", () => {
            this.forEachTopLevel("none", (_, name) => {
                const serializer = this.serializerFunctionName(name);
                const deserializer = this.deserializerFunctionName(name);
                this.emitLine('"', serializer, '": ', serializer, ",");
                this.emitLine('"', deserializer, '": ', deserializer, ",");
            });
        });
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else {
            this.emitUsageComments();
        }
        this.emitTypes();
        this.emitConvertModule();
        this.emitConvertModuleHelpers();
        this.emitModuleExports();
    }
}

const javaScriptPropTypesOptions = {
    acronymStyle: acronymOption(AcronymStyleOptions.Pascal),
    converters: convertersOption(),
    moduleSystem: new EnumOption("module-system", "Which module system to use", [
        ["common-js", false],
        ["es6", true]
    ], "es6")
};
class JavaScriptPropTypesTargetLanguage extends TargetLanguage {
    getOptions() {
        return [javaScriptPropTypesOptions.acronymStyle, javaScriptPropTypesOptions.converters];
    }
    constructor(displayName = "JavaScript PropTypes", names = ["javascript-prop-types"], extension = "js") {
        super(displayName, names, extension);
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new JavaScriptPropTypesRenderer(this, renderContext, getOptionValues(javaScriptPropTypesOptions, untypedOptionValues));
    }
}
const identityNamingFunction = funPrefixNamer("properties", s => s);
class JavaScriptPropTypesRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _jsOptions) {
        super(targetLanguage, renderContext);
        this._jsOptions = _jsOptions;
    }
    nameStyle(original, upper) {
        const acronyms = acronymStyle(this._jsOptions.acronymStyle);
        const words = splitIntoWords(original);
        return combineWords(words, legalizeName$a, upper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, upper ? (s) => capitalize(acronyms(s)) : allLowerWordStyle, acronyms, "", isES3IdentifierStart);
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("types", s => this.nameStyle(s, true));
    }
    namerForObjectProperty() {
        return identityNamingFunction;
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("enum-cases", s => this.nameStyle(s, false));
    }
    namedTypeToNameForTopLevel(type) {
        return directlyReachableSingleNamedType(type);
    }
    makeNameForProperty(c, className, p, jsonName, _assignedName) {
        // Ignore the assigned name
        return super.makeNameForProperty(c, className, p, jsonName, undefined);
    }
    typeMapTypeFor(t, required = true) {
        if (["class", "object", "enum"].includes(t.kind)) {
            return ["_", this.nameForNamedType(t)];
        }
        const match = matchType(t, _anyType => "PropTypes.any", _nullType => "PropTypes.any", _boolType => "PropTypes.bool", _integerType => "PropTypes.number", _doubleType => "PropTypes.number", _stringType => "PropTypes.string", arrayType => ["PropTypes.arrayOf(", this.typeMapTypeFor(arrayType.items, false), ")"], _classType => tsNecessities.panic("Should already be handled."), _mapType => "PropTypes.object", _enumType => tsNecessities.panic("Should already be handled."), unionType => {
            const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
            return ["PropTypes.oneOfType([", ...collectionUtils.arrayIntercalate(", ", children), "])"];
        }, _transformedStringType => {
            return "PropTypes.string";
        });
        if (required) {
            return [match];
        }
        return match;
    }
    typeMapTypeForProperty(p) {
        return this.typeMapTypeFor(p.type);
    }
    importStatement(lhs, moduleName) {
        if (this._jsOptions.moduleSystem) {
            return ["import ", lhs, " from ", moduleName, ";"];
        }
        else {
            return ["const ", lhs, " = require(", moduleName, ");"];
        }
    }
    emitUsageComments() {
        // FIXME: Use the correct type name
        this.emitCommentLines([
            "Example usage:",
            "",
            this.importStatement("{ MyShape }", "./myShape.js"),
            "",
            "class MyComponent extends React.Component {",
            "  //",
            "}",
            "",
            "MyComponent.propTypes = {",
            "  input: MyShape",
            "};"
        ], { lineStart: "// " });
    }
    emitBlock(source, end, emit) {
        this.emitLine(source, "{");
        this.indent(emit);
        this.emitLine("}", end);
    }
    emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("PropTypes", '"prop-types"'));
    }
    emitExport(name, value) {
        if (this._jsOptions.moduleSystem) {
            this.emitLine("export const ", name, " = ", value, ";");
        }
        else {
            this.emitLine("module.exports = exports = { ", name, ": ", value, " };");
        }
    }
    emitTypes() {
        this.ensureBlankLine();
        this.forEachObject("none", (_type, name) => {
            this.emitLine("let _", name, ";");
        });
        this.forEachEnum("none", (enumType, enumName) => {
            const options = [];
            this.forEachEnumCase(enumType, "none", (name, _jsonName, _position) => {
                options.push("'");
                options.push(name);
                options.push("'");
                options.push(", ");
            });
            options.pop();
            this.emitLine(["const _", enumName, " = PropTypes.oneOfType([", ...options, "]);"]);
        });
        const order = [];
        const mapKey = [];
        const mapValue = [];
        this.forEachObject("none", (type, name) => {
            mapKey.push(name);
            mapValue.push(this.gatherSource(() => this.emitObject(name, type)));
        });
        // order these
        mapKey.forEach((_, index) => {
            // assume first
            let ordinal = 0;
            // pull out all names
            const source = mapValue[index];
            const names = source.filter(value => value);
            // must be behind all these names
            names.forEach(name => {
                const depName = name;
                // find this name's ordinal, if it has already been added
                order.forEach(orderItem => {
                    const depIndex = orderItem;
                    if (mapKey[depIndex] === depName) {
                        // this is the index of the dependency, so make sure we come after it
                        ordinal = Math.max(ordinal, depIndex + 1);
                    }
                });
            });
            // insert index
            order.splice(ordinal, 0, index);
        });
        // now emit ordered source
        order.forEach(i => this.emitGatheredSource(mapValue[i]));
        // now emit top levels
        this.forEachTopLevel("none", (type, name) => {
            if (type instanceof PrimitiveType) {
                this.ensureBlankLine();
                this.emitExport(name, this.typeMapTypeFor(type));
            }
            else {
                if (type.kind === "array") {
                    this.ensureBlankLine();
                    this.emitExport(name, ["PropTypes.arrayOf(", this.typeMapTypeFor(type.items), ")"]);
                }
                else {
                    this.ensureBlankLine();
                    this.emitExport(name, ["_", name]);
                }
            }
        });
    }
    emitObject(name, t) {
        this.ensureBlankLine();
        this.emitLine("_", name, " = PropTypes.shape({");
        this.indent(() => {
            this.forEachClassProperty(t, "none", (_, jsonName, property) => {
                this.emitLine(`"${utf16StringEscape(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
            });
        });
        this.emitLine("});");
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else {
            this.emitUsageComments();
        }
        this.emitImports();
        this.emitTypes();
    }
}

class JSONSchemaTargetLanguage extends TargetLanguage {
    constructor() {
        super("JSON Schema", ["schema", "json-schema"], "schema");
    }
    getOptions() {
        return [];
    }
    get stringTypeMapping() {
        return getNoStringTypeMapping();
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsFullObjectType() {
        return true;
    }
    makeRenderer(renderContext, _untypedOptionValues) {
        return new JSONSchemaRenderer(this, renderContext);
    }
}
const namingFunction$1 = funPrefixNamer("namer", jsonNameStyle);
const legalizeName$9 = legalizeCharacters(cp => cp >= 32 && cp < 128 && cp !== 0x2f /* slash */);
function jsonNameStyle(original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$9, firstUpperWordStyle, firstUpperWordStyle, allUpperWordStyle, allUpperWordStyle, "", _ => true);
}
class JSONSchemaRenderer extends ConvenienceRenderer {
    makeNamedTypeNamer() {
        return namingFunction$1;
    }
    namerForObjectProperty() {
        return null;
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return null;
    }
    nameForType(t) {
        return defined(this.names.get(this.nameForNamedType(t)));
    }
    makeOneOf(types) {
        const first = collectionUtils.iterableFirst(types);
        if (first === undefined) {
            return panic("Must have at least one type for oneOf");
        }
        if (types.size === 1) {
            return this.schemaForType(first);
        }
        return { anyOf: Array.from(types).map((t) => this.schemaForType(t)) };
    }
    makeRef(t) {
        return { $ref: `#/definitions/${this.nameForType(t)}` };
    }
    addAttributesToSchema(t, schema) {
        const attributes = this.typeGraph.attributeStore.attributesForType(t);
        for (const [kind, attr] of attributes) {
            kind.addToSchema(schema, t, attr);
        }
    }
    schemaForType(t) {
        const schema = matchTypeExhaustive(t, _noneType => {
            return panic("none type should have been replaced");
        }, _anyType => ({}), _nullType => ({ type: "null" }), _boolType => ({ type: "boolean" }), _integerType => ({ type: "integer" }), _doubleType => ({ type: "number" }), _stringType => ({ type: "string" }), arrayType => ({ type: "array", items: this.schemaForType(arrayType.items) }), classType => this.makeRef(classType), mapType => this.definitionForObject(mapType, undefined), objectType => this.makeRef(objectType), enumType => this.makeRef(enumType), unionType => {
            if (this.unionNeedsName(unionType)) {
                return this.makeRef(unionType);
            }
            else {
                return this.definitionForUnion(unionType);
            }
        }, transformedStringType => {
            const target = transformedStringTypeTargetTypeKindsMap.get(transformedStringType.kind);
            if (target === undefined) {
                return panic(`Unknown transformed string type ${transformedStringType.kind}`);
            }
            return { type: "string", format: target.jsonSchema };
        });
        if (schema.$ref === undefined) {
            this.addAttributesToSchema(t, schema);
        }
        return schema;
    }
    definitionForObject(o, title) {
        let properties;
        let required;
        if (o.getProperties().size === 0) {
            properties = undefined;
            required = undefined;
        }
        else {
            const props = {};
            const req = [];
            for (const [name, p] of o.getProperties()) {
                const prop = this.schemaForType(p.type);
                if (prop.description === undefined) {
                    addDescriptionToSchema(prop, this.descriptionForClassProperty(o, name));
                }
                props[name] = prop;
                if (!p.isOptional) {
                    req.push(name);
                }
            }
            properties = props;
            required = req.sort();
        }
        const additional = o.getAdditionalProperties();
        const additionalProperties = additional !== undefined ? this.schemaForType(additional) : false;
        const schema = {
            type: "object",
            additionalProperties,
            properties,
            required,
            title
        };
        this.addAttributesToSchema(o, schema);
        return schema;
    }
    definitionForUnion(u, title) {
        const oneOf = this.makeOneOf(u.sortedMembers);
        if (title !== undefined) {
            oneOf.title = title;
        }
        this.addAttributesToSchema(u, oneOf);
        return oneOf;
    }
    definitionForEnum(e, title) {
        const schema = { type: "string", enum: Array.from(e.cases), title };
        this.addAttributesToSchema(e, schema);
        return schema;
    }
    emitSourceStructure() {
        // FIXME: Find a good way to do multiple top-levels.  Maybe multiple files?
        const topLevelType = this.topLevels.size === 1 ? this.schemaForType(defined(collectionUtils.mapFirst(this.topLevels))) : {};
        const schema = Object.assign({ $schema: "http://json-schema.org/draft-06/schema#" }, topLevelType);
        const definitions = {};
        this.forEachObject("none", (o, name) => {
            const title = defined(this.names.get(name));
            definitions[title] = this.definitionForObject(o, title);
        });
        this.forEachUnion("none", (u, name) => {
            if (!this.unionNeedsName(u))
                return;
            const title = defined(this.names.get(name));
            definitions[title] = this.definitionForUnion(u, title);
        });
        this.forEachEnum("none", (e, name) => {
            const title = defined(this.names.get(name));
            definitions[title] = this.definitionForEnum(e, title);
        });
        schema.definitions = definitions;
        this.emitMultiline(JSON.stringify(schema, undefined, "    "));
    }
}

var Framework$2;
(function (Framework) {
    Framework["None"] = "None";
    Framework["Jackson"] = "Jackson";
    Framework["Klaxon"] = "Klaxon";
    Framework["KotlinX"] = "KotlinX";
})(Framework$2 || (Framework$2 = {}));
const kotlinOptions = {
    framework: new EnumOption("framework", "Serialization framework", [
        ["just-types", Framework$2.None],
        ["jackson", Framework$2.Jackson],
        ["klaxon", Framework$2.Klaxon],
        ["kotlinx", Framework$2.KotlinX]
    ], "klaxon"),
    acronymStyle: acronymOption(AcronymStyleOptions.Pascal),
    packageName: new StringOption("package", "Package", "PACKAGE", "quicktype")
};
class KotlinTargetLanguage extends TargetLanguage {
    constructor() {
        super("Kotlin", ["kotlin"], "kt");
    }
    getOptions() {
        return [kotlinOptions.framework, kotlinOptions.acronymStyle, kotlinOptions.packageName];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(kotlinOptions, untypedOptionValues);
        switch (options.framework) {
            case Framework$2.None:
                return new KotlinRenderer(this, renderContext, options);
            case Framework$2.Jackson:
                return new KotlinJacksonRenderer(this, renderContext, options);
            case Framework$2.Klaxon:
                return new KotlinKlaxonRenderer(this, renderContext, options);
            case Framework$2.KotlinX:
                return new KotlinXRenderer(this, renderContext, options);
            default:
                return assertNever(options.framework);
        }
    }
}
const keywords$7 = [
    "package",
    "as",
    "typealias",
    "class",
    "this",
    "super",
    "val",
    "var",
    "fun",
    "for",
    "null",
    "true",
    "false",
    "is",
    "in",
    "throw",
    "return",
    "break",
    "continue",
    "object",
    "if",
    "try",
    "else",
    "while",
    "do",
    "when",
    "interface",
    "typeof",
    "klaxon",
    "toJson",
    "Any",
    "Boolean",
    "Double",
    "Float",
    "Long",
    "Int",
    "Short",
    "System",
    "Byte",
    "String",
    "Array",
    "List",
    "Map",
    "Enum",
    "Class",
    "JsonObject",
    "JsonValue",
    "Converter",
    "Klaxon"
];
function isPartCharacter$6(codePoint) {
    return isLetterOrUnderscore(codePoint) || isNumeric(codePoint);
}
function isStartCharacter$6(codePoint) {
    return isPartCharacter$6(codePoint) && !isDigit(codePoint);
}
const legalizeName$8 = legalizeCharacters(isPartCharacter$6);
function kotlinNameStyle(isUpper, original, acronymsStyle = allUpperWordStyle) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$8, isUpper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, isUpper ? allUpperWordStyle : allLowerWordStyle, acronymsStyle, "", isStartCharacter$6);
}
function unicodeEscape$2(codePoint) {
    return "\\u" + intToHex(codePoint, 4);
}
// eslint-disable-next-line @typescript-eslint/naming-convention
const _stringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, unicodeEscape$2));
function stringEscape$3(s) {
    // "$this" is a template string in Kotlin so we have to escape $
    return _stringEscape(s).replace(/\$/g, "\\$");
}
class KotlinRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext);
        this._kotlinOptions = _kotlinOptions;
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$7;
    }
    forbiddenForObjectProperties(_o, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
    }
    topLevelNameStyle(rawName) {
        return kotlinNameStyle(true, rawName);
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("upper", s => kotlinNameStyle(true, s, acronymStyle(this._kotlinOptions.acronymStyle)));
    }
    namerForObjectProperty() {
        return funPrefixNamer("lower", s => kotlinNameStyle(false, s, acronymStyle(this._kotlinOptions.acronymStyle)));
    }
    makeUnionMemberNamer() {
        return funPrefixNamer("upper", s => kotlinNameStyle(true, s) + "Value");
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("upper", s => kotlinNameStyle(true, s, acronymStyle(this._kotlinOptions.acronymStyle)));
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly" ? ["{", "}"] : delimiter === "paren" ? ["(", ")"] : ["{", "})"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
    }
    anySourceType(optional) {
        return ["Any", optional];
    }
    // (asarazan): I've broken out the following two functions
    // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
    arrayType(arrayType, withIssues = false, _noOptional = false) {
        return ["List<", this.kotlinType(arrayType.items, withIssues), ">"];
    }
    mapType(mapType, withIssues = false, _noOptional = false) {
        return ["Map<String, ", this.kotlinType(mapType.values, withIssues), ">"];
    }
    kotlinType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return matchType(t, _anyType => {
            return maybeAnnotated(withIssues, anyTypeIssueAnnotation, this.anySourceType(optional));
        }, _nullType => {
            return maybeAnnotated(withIssues, nullTypeIssueAnnotation, this.anySourceType(optional));
        }, _boolType => "Boolean", _integerType => "Long", _doubleType => "Double", _stringType => "String", arrayType => this.arrayType(arrayType, withIssues), classType => this.nameForNamedType(classType), mapType => this.mapType(mapType, withIssues), enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return [this.kotlinType(nullable, withIssues), optional];
            return this.nameForNamedType(unionType);
        });
    }
    emitUsageHeader() {
        // To be overridden
    }
    emitHeader() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else {
            this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._kotlinOptions.packageName);
        this.ensureBlankLine();
    }
    emitTopLevelPrimitive(t, name) {
        const elementType = this.kotlinType(t);
        this.emitLine(["typealias ", name, " = ", elementType, ""]);
    }
    emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitLine(["typealias ", name, " = ArrayList<", elementType, ">"]);
    }
    emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitLine(["typealias ", name, " = HashMap<String, ", elementType, ">"]);
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAnnotations(c, className);
        this.emitLine("class ", className, "()");
    }
    emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
            this.emitEmptyClassDefinition(c, className);
            return;
        }
        const kotlinType = (p) => {
            if (p.isOptional) {
                return [this.kotlinType(p.type, true, true), "?"];
            }
            else {
                return this.kotlinType(p.type, true);
            }
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitClassAnnotations(c, className);
        this.emitLine("data class ", className, " (");
        this.indent(() => {
            let count = c.getProperties().size;
            let first = true;
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const nullable = p.type.kind === "union" && nullableFromUnion(p.type) !== null;
                const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
                const last = --count === 0;
                let meta = [];
                const description = this.descriptionForClassProperty(c, jsonName);
                if (description !== undefined) {
                    meta.push(() => this.emitDescription(description));
                }
                this.renameAttribute(name, jsonName, !nullableOrOptional, meta);
                if (meta.length > 0 && !first) {
                    this.ensureBlankLine();
                }
                for (const emit of meta) {
                    emit();
                }
                this.emitLine("val ", name, ": ", kotlinType(p), nullableOrOptional ? " = null" : "", last ? "" : ",");
                if (meta.length > 0 && !last) {
                    this.ensureBlankLine();
                }
                first = false;
            });
        });
        this.emitClassDefinitionMethods(c, className);
    }
    emitClassDefinitionMethods(_c, _className) {
        this.emitLine(")");
    }
    emitClassAnnotations(_c, _className) {
        // to be overridden
    }
    renameAttribute(_name, _jsonName, _required, _meta) {
        // to be overridden
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum class ", enumName], () => {
            let count = e.cases.size;
            this.forEachEnumCase(e, "none", name => {
                this.emitLine(name, --count === 0 ? "" : ",");
            });
        });
    }
    emitUnionDefinition(u, unionName) {
        function sortBy(t) {
            const kind = t.kind;
            if (kind === "class")
                return kind;
            return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = removeNullFromUnion(u, sortBy);
        this.emitClassAnnotations(u, unionName);
        this.emitBlock(["sealed class ", unionName], () => {
            {
                let table = [];
                this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                    table.push([
                        ["class ", name, "(val value: ", this.kotlinType(t), ")"],
                        [" : ", unionName, "()"]
                    ]);
                });
                if (maybeNull !== null) {
                    table.push([
                        ["class ", this.nameForUnionMember(u, maybeNull), "()"],
                        [" : ", unionName, "()"]
                    ]);
                }
                this.emitTable(table);
            }
            this.emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName);
        });
    }
    emitUnionDefinitionMethods(_u, _nonNulls, _maybeNull, _unionName) {
        // to be overridden
    }
    emitSourceStructure() {
        this.emitHeader();
        // Top-level arrays, maps
        this.forEachTopLevel("leading", (t, name) => {
            if (t instanceof ArrayType) {
                this.emitTopLevelArray(t, name);
            }
            else if (t instanceof MapType) {
                this.emitTopLevelMap(t, name);
            }
            else if (t.isPrimitive()) {
                this.emitTopLevelPrimitive(t, name);
            }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
    }
}
class KotlinKlaxonRenderer extends KotlinRenderer {
    constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
    }
    unionMemberFromJsonValue(t, e) {
        return matchType(t, _anyType => [e, ".inside"], _nullType => "null", _boolType => [e, ".boolean"], _integerType => ["(", e, ".int?.toLong() ?: ", e, ".longValue)"], _doubleType => [e, ".double"], _stringType => [e, ".string"], arrayType => [e, ".array?.let { klaxon.parseFromJsonArray<", this.kotlinType(arrayType.items), ">(it) }"], _classType => [e, ".obj?.let { klaxon.parseFromJsonObject<", this.kotlinType(t), ">(it) }"], _mapType => [e, ".obj?.let { klaxon.parseFromJsonObject<", this.kotlinType(t), ">(it) }"], enumType => [e, ".string?.let { ", this.kotlinType(enumType), ".fromValue(it) }"], _unionType => mustNotHappen());
    }
    unionMemberJsonValueGuard(t, _e) {
        return matchType(t, _anyType => "is Any", _nullType => "null", _boolType => "is Boolean", _integerType => "is Int, is Long", _doubleType => "is Double", _stringType => "is String", _arrayType => "is JsonArray<*>", 
        // These could be stricter, but for now we don't allow maps
        // and objects in the same union
        _classType => "is JsonObject", _mapType => "is JsonObject", 
        // This could be stricter, but for now we don't allow strings
        // and enums in the same union
        _enumType => "is String", _unionType => mustNotHappen());
    }
    emitUsageHeader() {
        this.emitLine("// To parse the JSON, install Klaxon and do:");
        this.emitLine("//");
        this.forEachTopLevel("none", (_, name) => {
            this.emitLine("//   val ", modifySource(camelCase, name), " = ", name, ".fromJson(jsonString)");
        });
    }
    emitHeader() {
        super.emitHeader();
        this.emitLine("import com.beust.klaxon.*");
        const hasUnions = collectionUtils.iterableSome(this.typeGraph.allNamedTypes(), t => t instanceof UnionType && nullableFromUnion(t) === null);
        const hasEmptyObjects = collectionUtils.iterableSome(this.typeGraph.allNamedTypes(), c => c instanceof ClassType && c.getProperties().size === 0);
        if (hasUnions || this.haveEnums || hasEmptyObjects) {
            this.emitGenericConverter();
        }
        let converters = [];
        if (hasEmptyObjects) {
            converters.push([[".convert(JsonObject::class,"], [" { it.obj!! },"], [" { it.toJsonString() })"]]);
        }
        this.forEachEnum("none", (_, name) => {
            converters.push([
                [".convert(", name, "::class,"],
                [" { ", name, ".fromValue(it.string!!) },"],
                [' { "\\"${it.value}\\"" })']
            ]);
        });
        this.forEachUnion("none", (_, name) => {
            converters.push([
                [".convert(", name, "::class,"],
                [" { ", name, ".fromJson(it) },"],
                [" { it.toJson() }, true)"]
            ]);
        });
        this.ensureBlankLine();
        this.emitLine("private val klaxon = Klaxon()");
        if (converters.length > 0) {
            this.indent(() => this.emitTable(converters));
        }
    }
    emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock(["class ", name, "(elements: Collection<", elementType, ">) : ArrayList<", elementType, ">(elements)"], () => {
            this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitLine("public fun fromJson(json: String) = ", name, "(klaxon.parseArray<", elementType, ">(json)!!)");
            });
        });
    }
    emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
            "class ",
            name,
            "(elements: Map<String, ",
            elementType,
            ">) : HashMap<String, ",
            elementType,
            ">(elements)"
        ], () => {
            this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitBlock(["public fun fromJson(json: String) = ", name], () => {
                    this.emitLine("klaxon.parseJsonObject(java.io.StringReader(json)) as Map<String, ", elementType, ">");
                }, "paren");
            });
        });
    }
    klaxonRenameAttribute(propName, jsonName, ignore = false) {
        const escapedName = stringEscape$3(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        if (namesDiffer) {
            properties.push(['name = "', escapedName, '"']);
        }
        if (ignore) {
            properties.push("ignored = true");
        }
        return properties.length === 0 ? undefined : ["@Json(", collectionUtils.arrayIntercalate(", ", properties), ")"];
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("typealias ", className, " = JsonObject");
    }
    emitClassDefinitionMethods(c, className) {
        const isTopLevel = collectionUtils.iterableSome(this.topLevels, ([_, top]) => top === c);
        if (isTopLevel) {
            this.emitBlock(")", () => {
                this.emitLine("public fun toJson() = klaxon.toJsonString(this)");
                this.ensureBlankLine();
                this.emitBlock("companion object", () => {
                    this.emitLine("public fun fromJson(json: String) = klaxon.parse<", className, ">(json)");
                });
            });
        }
        else {
            this.emitLine(")");
        }
    }
    renameAttribute(name, jsonName, _required, meta) {
        const rename = this.klaxonRenameAttribute(name, jsonName);
        if (rename !== undefined) {
            meta.push(() => this.emitLine(rename));
        }
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
            let count = e.cases.size;
            this.forEachEnumCase(e, "none", (name, json) => {
                this.emitLine(name, `("${stringEscape$3(json)}")`, --count === 0 ? ";" : ",");
            });
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitBlock(["public fun fromValue(value: String): ", enumName, " = when (value)"], () => {
                    let table = [];
                    this.forEachEnumCase(e, "none", (name, json) => {
                        table.push([[`"${stringEscape$3(json)}"`], [" -> ", name]]);
                    });
                    table.push([["else"], [" -> throw IllegalArgumentException()"]]);
                    this.emitTable(table);
                });
            });
        });
    }
    emitGenericConverter() {
        this.ensureBlankLine();
        this.emitLine("private fun <T> Klaxon.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonValue) -> T, toJson: (T) -> String, isUnion: Boolean = false) =");
        this.indent(() => {
            this.emitLine("this.converter(object: Converter {");
            this.indent(() => {
                this.emitLine('@Suppress("UNCHECKED_CAST")');
                this.emitTable([
                    ["override fun toJson(value: Any)", " = toJson(value as T)"],
                    ["override fun fromJson(jv: JsonValue)", " = fromJson(jv) as Any"],
                    [
                        "override fun canConvert(cls: Class<*>)",
                        " = cls == k.java || (isUnion && cls.superclass == k.java)"
                    ]
                ]);
            });
            this.emitLine("})");
        });
    }
    emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName) {
        this.ensureBlankLine();
        this.emitLine("public fun toJson(): String = klaxon.toJsonString(when (this) {");
        this.indent(() => {
            let toJsonTable = [];
            this.forEachUnionMember(u, nonNulls, "none", null, name => {
                toJsonTable.push([["is ", name], [" -> this.value"]]);
            });
            if (maybeNull !== null) {
                const name = this.nameForUnionMember(u, maybeNull);
                toJsonTable.push([["is ", name], [' -> "null"']]);
            }
            this.emitTable(toJsonTable);
        });
        this.emitLine("})");
        this.ensureBlankLine();
        this.emitBlock("companion object", () => {
            this.emitLine("public fun fromJson(jv: JsonValue): ", unionName, " = when (jv.inside) {");
            this.indent(() => {
                let table = [];
                this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                    table.push([
                        [this.unionMemberJsonValueGuard(t, "jv.inside")],
                        [" -> ", name, "(", this.unionMemberFromJsonValue(t, "jv"), "!!)"]
                    ]);
                });
                if (maybeNull !== null) {
                    const name = this.nameForUnionMember(u, maybeNull);
                    table.push([[this.unionMemberJsonValueGuard(maybeNull, "jv.inside")], [" -> ", name, "()"]]);
                }
                table.push([["else"], [" -> throw IllegalArgumentException()"]]);
                this.emitTable(table);
            });
            this.emitLine("}");
        });
    }
}
class KotlinJacksonRenderer extends KotlinRenderer {
    constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
    }
    unionMemberJsonValueGuard(t, _e) {
        return matchType(t, _anyType => "is Any", _nullType => "null", _boolType => "is BooleanNode", _integerType => "is IntNode, is LongNode", _doubleType => "is DoubleNode", _stringType => "is TextNode", _arrayType => "is ArrayNode", 
        // These could be stricter, but for now we don't allow maps
        // and objects in the same union
        _classType => "is ObjectNode", _mapType => "is ObjectNode", 
        // This could be stricter, but for now we don't allow strings
        // and enums in the same union
        _enumType => "is TextNode", _unionType => mustNotHappen());
    }
    emitUsageHeader() {
        this.emitLine("// To parse the JSON, install jackson-module-kotlin and do:");
        this.emitLine("//");
        this.forEachTopLevel("none", (_, name) => {
            this.emitLine("//   val ", modifySource(camelCase, name), " = ", name, ".fromJson(jsonString)");
        });
    }
    emitHeader() {
        super.emitHeader();
        this.emitMultiline(`import com.fasterxml.jackson.annotation.*
import com.fasterxml.jackson.core.*
import com.fasterxml.jackson.databind.*
import com.fasterxml.jackson.databind.deser.std.StdDeserializer
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.node.*
import com.fasterxml.jackson.databind.ser.std.StdSerializer
import com.fasterxml.jackson.module.kotlin.*`);
        const hasUnions = collectionUtils.iterableSome(this.typeGraph.allNamedTypes(), t => t instanceof UnionType && nullableFromUnion(t) === null);
        const hasEmptyObjects = collectionUtils.iterableSome(this.typeGraph.allNamedTypes(), c => c instanceof ClassType && c.getProperties().size === 0);
        if (hasUnions || this.haveEnums || hasEmptyObjects) {
            this.emitGenericConverter();
        }
        let converters = [];
        // if (hasEmptyObjects) {
        //     converters.push([["convert(JsonNode::class,"], [" { it },"], [" { writeValueAsString(it) })"]]);
        // }
        this.forEachEnum("none", (_, name) => {
            converters.push([
                ["convert(", name, "::class,"],
                [" { ", name, ".fromValue(it.asText()) },"],
                [' { "\\"${it.value}\\"" })']
            ]);
        });
        this.forEachUnion("none", (_, name) => {
            converters.push([
                ["convert(", name, "::class,"],
                [" { ", name, ".fromJson(it) },"],
                [" { it.toJson() }, true)"]
            ]);
        });
        this.ensureBlankLine();
        this.emitLine("val mapper = jacksonObjectMapper().apply {");
        this.indent(() => {
            this.emitLine("propertyNamingStrategy = PropertyNamingStrategy.LOWER_CAMEL_CASE");
            this.emitLine("setSerializationInclusion(JsonInclude.Include.NON_NULL)");
        });
        if (converters.length > 0) {
            this.indent(() => this.emitTable(converters));
        }
        this.emitLine("}");
    }
    emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitBlock(["class ", name, "(elements: Collection<", elementType, ">) : ArrayList<", elementType, ">(elements)"], () => {
            this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitLine("fun fromJson(json: String) = mapper.readValue<", name, ">(json)");
            });
        });
    }
    emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        this.emitBlock([
            "class ",
            name,
            "(elements: Map<String, ",
            elementType,
            ">) : HashMap<String, ",
            elementType,
            ">(elements)"
        ], () => {
            this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitLine("fun fromJson(json: String) = mapper.readValue<", name, ">(json)");
            });
        });
    }
    jacksonRenameAttribute(propName, jsonName, required, ignore = false) {
        const escapedName = stringEscape$3(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        const properties = [];
        const isPrefixBool = jsonName.startsWith("is"); // https://github.com/FasterXML/jackson-module-kotlin/issues/80
        const propertyOpts = [];
        if (namesDiffer || isPrefixBool) {
            propertyOpts.push('"' + escapedName + '"');
        }
        if (required) {
            propertyOpts.push("required=true");
        }
        if (propertyOpts.length > 0) {
            properties.push(["@get:JsonProperty(", collectionUtils.arrayIntercalate(", ", propertyOpts), ")"]);
            properties.push(["@field:JsonProperty(", collectionUtils.arrayIntercalate(", ", propertyOpts), ")"]);
        }
        if (ignore) {
            properties.push("@get:JsonIgnore");
            properties.push("@field:JsonIgnore");
        }
        return properties.length === 0 ? undefined : properties;
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("typealias ", className, " = JsonNode");
    }
    emitClassDefinitionMethods(c, className) {
        const isTopLevel = collectionUtils.iterableSome(this.topLevels, ([_, top]) => top === c);
        if (isTopLevel) {
            this.emitBlock(")", () => {
                this.emitLine("fun toJson() = mapper.writeValueAsString(this)");
                this.ensureBlankLine();
                this.emitBlock("companion object", () => {
                    this.emitLine("fun fromJson(json: String) = mapper.readValue<", className, ">(json)");
                });
            });
        }
        else {
            this.emitLine(")");
        }
    }
    renameAttribute(name, jsonName, required, meta) {
        const rename = this.jacksonRenameAttribute(name, jsonName, required);
        if (rename !== undefined) {
            meta.push(() => this.emitLine(rename));
        }
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
            let count = e.cases.size;
            this.forEachEnumCase(e, "none", (name, json) => {
                this.emitLine(name, `("${stringEscape$3(json)}")`, --count === 0 ? ";" : ",");
            });
            this.ensureBlankLine();
            this.emitBlock("companion object", () => {
                this.emitBlock(["fun fromValue(value: String): ", enumName, " = when (value)"], () => {
                    let table = [];
                    this.forEachEnumCase(e, "none", (name, json) => {
                        table.push([[`"${stringEscape$3(json)}"`], [" -> ", name]]);
                    });
                    table.push([["else"], [" -> throw IllegalArgumentException()"]]);
                    this.emitTable(table);
                });
            });
        });
    }
    emitGenericConverter() {
        this.ensureBlankLine();
        this.emitMultiline(`
@Suppress("UNCHECKED_CAST")
private fun <T> ObjectMapper.convert(k: kotlin.reflect.KClass<*>, fromJson: (JsonNode) -> T, toJson: (T) -> String, isUnion: Boolean = false) = registerModule(SimpleModule().apply {
    addSerializer(k.java as Class<T>, object : StdSerializer<T>(k.java as Class<T>) {
        override fun serialize(value: T, gen: JsonGenerator, provider: SerializerProvider) = gen.writeRawValue(toJson(value))
    })
    addDeserializer(k.java as Class<T>, object : StdDeserializer<T>(k.java as Class<T>) {
        override fun deserialize(p: JsonParser, ctxt: DeserializationContext) = fromJson(p.readValueAsTree())
    })
})`);
    }
    emitUnionDefinitionMethods(u, nonNulls, maybeNull, unionName) {
        this.ensureBlankLine();
        this.emitLine("fun toJson(): String = mapper.writeValueAsString(when (this) {");
        this.indent(() => {
            let toJsonTable = [];
            this.forEachUnionMember(u, nonNulls, "none", null, name => {
                toJsonTable.push([["is ", name], [" -> this.value"]]);
            });
            if (maybeNull !== null) {
                const name = this.nameForUnionMember(u, maybeNull);
                toJsonTable.push([["is ", name], [' -> "null"']]);
            }
            this.emitTable(toJsonTable);
        });
        this.emitLine("})");
        this.ensureBlankLine();
        this.emitBlock("companion object", () => {
            this.emitLine("fun fromJson(jn: JsonNode): ", unionName, " = when (jn) {");
            this.indent(() => {
                let table = [];
                this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                    table.push([[this.unionMemberJsonValueGuard(t, "jn")], [" -> ", name, "(mapper.treeToValue(jn))"]]);
                });
                if (maybeNull !== null) {
                    const name = this.nameForUnionMember(u, maybeNull);
                    table.push([[this.unionMemberJsonValueGuard(maybeNull, "jn")], [" -> ", name, "()"]]);
                }
                table.push([["else"], [" -> throw IllegalArgumentException()"]]);
                this.emitTable(table);
            });
            this.emitLine("}");
        });
    }
}
/**
 * Currently supports simple classes, enums, and TS string unions (which are also enums).
 * TODO: Union, Any, Top Level Array, Top Level Map
 */
class KotlinXRenderer extends KotlinRenderer {
    constructor(targetLanguage, renderContext, _kotlinOptions) {
        super(targetLanguage, renderContext, _kotlinOptions);
    }
    anySourceType(optional) {
        return ["JsonElement", optional];
    }
    arrayType(arrayType, withIssues = false, noOptional = false) {
        const valType = this.kotlinType(arrayType.items, withIssues, true);
        const name = this.sourcelikeToString(valType);
        if (name === "JsonObject" || name === "JsonElement") {
            return "JsonArray";
        }
        return super.arrayType(arrayType, withIssues, noOptional);
    }
    mapType(mapType, withIssues = false, noOptional = false) {
        const valType = this.kotlinType(mapType.values, withIssues, true);
        const name = this.sourcelikeToString(valType);
        if (name === "JsonObject" || name === "JsonElement") {
            return "JsonObject";
        }
        return super.mapType(mapType, withIssues, noOptional);
    }
    emitTopLevelMap(t, name) {
        const elementType = this.kotlinType(t.values);
        if (elementType === "JsonObject") {
            this.emitLine(["typealias ", name, " = JsonObject"]);
        }
        else {
            super.emitTopLevelMap(t, name);
        }
    }
    emitTopLevelArray(t, name) {
        const elementType = this.kotlinType(t.items);
        this.emitLine(["typealias ", name, " = JsonArray<", elementType, ">"]);
    }
    emitUsageHeader() {
        this.emitLine("// To parse the JSON, install kotlin's serialization plugin and do:");
        this.emitLine("//");
        const table = [];
        table.push(["// val ", "json", " = Json { allowStructuredMapKeys = true }"]);
        this.forEachTopLevel("none", (_, name) => {
            table.push([
                "// val ",
                modifySource(camelCase, name),
                ` = json.parse(${this.sourcelikeToString(name)}.serializer(), jsonString)`
            ]);
        });
        this.emitTable(table);
    }
    emitHeader() {
        super.emitHeader();
        this.emitLine("import kotlinx.serialization.*");
        this.emitLine("import kotlinx.serialization.json.*");
        this.emitLine("import kotlinx.serialization.descriptors.*");
        this.emitLine("import kotlinx.serialization.encoding.*");
    }
    emitClassAnnotations(_c, _className) {
        this.emitLine("@Serializable");
    }
    renameAttribute(name, jsonName, _required, meta) {
        const rename = this._rename(name, jsonName);
        if (rename !== undefined) {
            meta.push(() => this.emitLine(rename));
        }
    }
    _rename(propName, jsonName) {
        const escapedName = stringEscape$3(jsonName);
        const namesDiffer = this.sourcelikeToString(propName) !== escapedName;
        if (namesDiffer) {
            return ['@SerialName("', escapedName, '")'];
        }
        return undefined;
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine(["@Serializable"]);
        this.emitBlock(["enum class ", enumName, "(val value: String)"], () => {
            let count = e.cases.size;
            this.forEachEnumCase(e, "none", (name, json) => {
                const jsonEnum = stringEscape$3(json);
                this.emitLine(`@SerialName("${jsonEnum}") `, name, `("${jsonEnum}")`, --count === 0 ? ";" : ",");
            });
        });
    }
}

const DEFAULT_CLASS_PREFIX = "QT";
const objcOptions = {
    features: new EnumOption("features", "Interface and implementation", [
        ["all", { interface: true, implementation: true }],
        ["interface", { interface: true, implementation: false }],
        ["implementation", { interface: false, implementation: true }]
    ]),
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    marshallingFunctions: new BooleanOption("functions", "C-style functions", false),
    classPrefix: new StringOption("class-prefix", "Class prefix", "PREFIX", DEFAULT_CLASS_PREFIX),
    extraComments: new BooleanOption("extra-comments", "Extra comments", false)
};
class ObjectiveCTargetLanguage extends TargetLanguage {
    constructor() {
        super("Objective-C", ["objc", "objective-c", "objectivec"], "m");
    }
    getOptions() {
        return [
            objcOptions.justTypes,
            objcOptions.classPrefix,
            objcOptions.features,
            objcOptions.extraComments,
            objcOptions.marshallingFunctions
        ];
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new ObjectiveCRenderer(this, renderContext, getOptionValues(objcOptions, untypedOptionValues));
    }
}
function typeNameStyle(prefix, original) {
    const words = splitIntoWords(original);
    const result = combineWords(words, legalizeName$7, firstUpperWordStyle, firstUpperWordStyle, allUpperWordStyle, allUpperWordStyle, "", isStartCharacter$5);
    return addPrefixIfNecessary(prefix, result);
}
function propertyNameStyle(original, isBool = false) {
    // Objective-C developers are uncomfortable with property "id"
    // so we use an alternate name in this special case.
    if (original === "id") {
        original = "identifier";
    }
    let words = splitIntoWords(original);
    if (isBool) {
        if (words.length === 0) {
            words = [{ word: "flag", isAcronym: false }];
        }
        else if (!words[0].isAcronym && !booleanPrefixes.includes(words[0].word)) {
            words = [{ word: "is", isAcronym: false }, ...words];
        }
    }
    // Properties cannot even begin with any of the forbidden names
    // For example, properies named new* are treated differently by ARC
    if (words.length > 0 && forbiddenPropertyNames$1.includes(words[0].word)) {
        words = [{ word: "the", isAcronym: false }, ...words];
    }
    return combineWords(words, legalizeName$7, allLowerWordStyle, firstUpperWordStyle, allLowerWordStyle, allUpperWordStyle, "", isStartCharacter$5);
}
const keywords$6 = [
    /*
    "_Bool",
    "_Complex",
    "_Imaginary",
    */
    "asm",
    "atomic",
    "auto",
    "bool",
    "break",
    "case",
    "char",
    "const",
    "continue",
    "default",
    "do",
    "double",
    "else",
    "enum",
    "extern",
    "false",
    "float",
    "for",
    "goto",
    "if",
    "inline",
    "int",
    "long",
    "nil",
    "nonatomic",
    "register",
    "restrict",
    "retain",
    "return",
    "short",
    "signed",
    "sizeof",
    "static",
    "struct",
    "switch",
    "typedef",
    "typeof",
    "true",
    "union",
    "unsigned",
    "void",
    "volatile",
    "while"
];
const forbiddenPropertyNames$1 = [
    "id",
    "hash",
    "description",
    "init",
    "copy",
    "mutableCopy",
    "superclass",
    "debugDescription",
    "new"
];
const booleanPrefixes = [
    "is",
    "are",
    "were",
    "was",
    "will",
    "all",
    "some",
    "many",
    "has",
    "have",
    "had",
    "does",
    "do",
    "requires",
    "require",
    "needs",
    "need"
];
function isStartCharacter$5(utf16Unit) {
    return $747425b437e121da$export$2e2bcd8739ae039.isAlphabetic(utf16Unit) || utf16Unit === 0x5f; // underscore
}
function isPartCharacter$5(utf16Unit) {
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(utf16Unit);
    return ["Nd", "Pc", "Mn", "Mc"].includes(category) || isStartCharacter$5(utf16Unit);
}
const legalizeName$7 = utf16LegalizeCharacters(isPartCharacter$5);
const staticEnumValuesIdentifier = "values";
const forbiddenForEnumCases = ["new", staticEnumValuesIdentifier];
function splitExtension(filename) {
    const i = filename.lastIndexOf(".");
    const extension = i !== -1 ? filename.split(".").pop() : "m";
    filename = i !== -1 ? filename.slice(0, i) : filename;
    return [filename, extension !== null && extension !== void 0 ? extension : "m"];
}
class ObjectiveCRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        // Infer the class prefix from a top-level name if it's not given
        if (_options.classPrefix === DEFAULT_CLASS_PREFIX) {
            const aTopLevel = defined(collectionUtils.iterableFirst(this.topLevels.keys()));
            this._classPrefix = this.inferClassPrefix(aTopLevel);
        }
        else {
            this._classPrefix = _options.classPrefix;
        }
    }
    inferClassPrefix(name) {
        const l = name.length;
        let firstNonUpper = 0;
        while (firstNonUpper < l && fastIsUpperCase(name.charCodeAt(firstNonUpper))) {
            firstNonUpper += 1;
        }
        if (firstNonUpper < 2)
            return DEFAULT_CLASS_PREFIX;
        return name.slice(0, firstNonUpper - 1);
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$6;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: forbiddenPropertyNames$1, includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: forbiddenForEnumCases, includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("types", rawName => typeNameStyle(this._classPrefix, rawName));
    }
    namerForObjectProperty(_, p) {
        // TODO why is underscore being removed?
        return new Namer("properties", s => propertyNameStyle(s, p.type.kind === "bool"), [
            "_",
            "the",
            "one",
            "some",
            "another"
        ]);
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return new Namer("enum-cases", propertyNameStyle, []);
    }
    namedTypeToNameForTopLevel(type) {
        return type;
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: "/// " });
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    emitMethod(declaration, f) {
        this.emitLine(declaration);
        this.emitLine("{");
        this.indent(f);
        this.emitLine("}");
    }
    emitExtraComments(...comments) {
        if (!this._options.extraComments)
            return;
        for (const comment of comments) {
            this.emitLine("// ", comment);
        }
    }
    startFile(basename, extension) {
        assert(this._currentFilename === undefined, "Previous file wasn't finished");
        // FIXME: The filenames should actually be Sourcelikes, too
        this._currentFilename = `${this.sourcelikeToString(basename)}.${extension}`;
    }
    finishFile() {
        super.finishFile(defined(this._currentFilename));
        this._currentFilename = undefined;
    }
    memoryAttribute(t, isNullable) {
        return matchType(t, _anyType => "copy", _nullType => "copy", _boolType => (isNullable ? "strong" : "assign"), _integerType => (isNullable ? "strong" : "assign"), _doubleType => (isNullable ? "strong" : "assign"), _stringType => "copy", _arrayType => "copy", _classType => "strong", _mapType => "copy", _enumType => "assign", unionType => {
            const nullable = nullableFromUnion(unionType);
            return nullable !== null ? this.memoryAttribute(nullable, true) : "copy";
        });
    }
    objcType(t, nullableOrBoxed = false) {
        return matchType(t, _anyType => ["id", ""], 
        // For now, we're treating nulls just like any
        _nullType => ["id", ""], _boolType => (nullableOrBoxed ? ["NSNumber", " *"] : ["BOOL", ""]), _integerType => (nullableOrBoxed ? ["NSNumber", " *"] : ["NSInteger", ""]), _doubleType => (nullableOrBoxed ? ["NSNumber", " *"] : ["double", ""]), _stringType => ["NSString", " *"], arrayType => {
            const itemType = arrayType.items;
            const itemTypeName = this.objcType(itemType, true);
            // NSArray<id>* === NSArray*
            if (isAnyOrNull(itemType)) {
                return ["NSArray", " *"];
            }
            return [["NSArray<", itemTypeName, ">"], " *"];
        }, classType => [this.nameForNamedType(classType), " *"], mapType => [["NSDictionary<NSString *, ", this.objcType(mapType.values, true), ">"], " *"], enumType => [this.nameForNamedType(enumType), " *"], unionType => {
            const nullable = nullableFromUnion(unionType);
            return nullable !== null ? this.objcType(nullable, true) : ["id", ""];
        });
    }
    jsonType(t) {
        return matchType(t, _anyType => ["id", ""], 
        // For now, we're treating nulls just like any
        _nullType => ["id", ""], _boolType => ["NSNumber", " *"], _integerType => ["NSNumber", " *"], _doubleType => ["NSNumber", " *"], _stringType => ["NSString", " *"], _arrayType => ["NSArray", " *"], _classType => ["NSDictionary<NSString *, id>", " *"], mapType => [["NSDictionary<NSString *, ", this.jsonType(mapType.values), ">"], " *"], _enumType => ["NSString", " *"], unionType => {
            const nullable = nullableFromUnion(unionType);
            return nullable !== null ? this.jsonType(nullable) : ["id", ""];
        });
    }
    fromDynamicExpression(t, ...dynamic) {
        return matchType(t, _anyType => dynamic, _nullType => dynamic, _boolType => dynamic, _integerType => dynamic, _doubleType => dynamic, _stringType => dynamic, arrayType => ["map(", dynamic, ", λ(id x, ", this.fromDynamicExpression(arrayType.items, "x"), "))"], classType => ["[", this.nameForNamedType(classType), " fromJSONDictionary:", dynamic, "]"], mapType => ["map(", dynamic, ", λ(id x, ", this.fromDynamicExpression(mapType.values, "x"), "))"], enumType => ["[", this.nameForNamedType(enumType), " withValue:", dynamic, "]"], unionType => {
            const nullable = nullableFromUnion(unionType);
            return nullable !== null ? this.fromDynamicExpression(nullable, dynamic) : dynamic;
        });
    }
    toDynamicExpression(t, typed) {
        return matchType(t, _anyType => ["NSNullify(", typed, ")"], _nullType => ["NSNullify(", typed, ")"], 
        // Sadly, KVC
        _boolType => [typed, " ? @YES : @NO"], _integerType => typed, _doubleType => typed, _stringType => typed, arrayType => {
            if (this.implicitlyConvertsFromJSON(arrayType)) {
                // TODO check each value type
                return typed;
            }
            return ["map(", typed, ", λ(id x, ", this.toDynamicExpression(arrayType.items, "x"), "))"];
        }, _classType => ["[", typed, " JSONDictionary]"], mapType => {
            if (this.implicitlyConvertsFromJSON(mapType)) {
                // TODO check each value type
                return typed;
            }
            return ["map(", typed, ", λ(id x, ", this.toDynamicExpression(mapType.values, "x"), "))"];
        }, _enumType => ["[", typed, " value]"], unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                if (this.implicitlyConvertsFromJSON(nullable)) {
                    return ["NSNullify(", typed, ")"];
                }
                else {
                    return ["NSNullify(", this.toDynamicExpression(nullable, typed), ")"];
                }
            }
            else {
                // TODO support unions
                return typed;
            }
        });
    }
    implicitlyConvertsFromJSON(t) {
        if (t instanceof ClassType) {
            return false;
        }
        else if (t instanceof EnumType) {
            return false;
        }
        else if (t instanceof ArrayType) {
            return this.implicitlyConvertsFromJSON(t.items);
        }
        else if (t instanceof MapType) {
            return this.implicitlyConvertsFromJSON(t.values);
        }
        else if (t.isPrimitive()) {
            return true;
        }
        else if (t instanceof UnionType) {
            const nullable = nullableFromUnion(t);
            if (nullable !== null) {
                return this.implicitlyConvertsFromJSON(nullable);
            }
            else {
                // We don't support unions yet, so this is just untyped
                return true;
            }
        }
        else {
            return false;
        }
    }
    implicitlyConvertsToJSON(t) {
        return this.implicitlyConvertsFromJSON(t) && "bool" !== t.kind;
    }
    emitPropertyAssignment(propertyName, jsonName, propertyType) {
        const name = ["_", propertyName];
        matchType(propertyType, anyType => this.emitLine(name, " = ", this.fromDynamicExpression(anyType, name), ";"), nullType => this.emitLine(name, " = ", this.fromDynamicExpression(nullType, name), ";"), boolType => this.emitLine(name, " = ", this.fromDynamicExpression(boolType, name), ";"), integerType => this.emitLine(name, " = ", this.fromDynamicExpression(integerType, name), ";"), doubleType => this.emitLine(name, " = ", this.fromDynamicExpression(doubleType, name), ";"), stringType => this.emitLine(name, " = ", this.fromDynamicExpression(stringType, name), ";"), arrayType => this.emitLine(name, " = ", this.fromDynamicExpression(arrayType, name), ";"), classType => this.emitLine(name, " = ", this.fromDynamicExpression(classType, ["(id)", name]), ";"), mapType => {
            const itemType = mapType.values;
            this.emitLine(name, " = map(", name, ", ", ["λ(id x, ", this.fromDynamicExpression(itemType, "x"), ")"], ");");
        }, enumType => this.emitLine(name, " = ", this.fromDynamicExpression(enumType, ["(id)", name]), ";"), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                this.emitPropertyAssignment(propertyName, jsonName, nullable);
            }
            else {
                // TODO This is a union, but for now we just leave it dynamic
                this.emitLine(name, " = ", this.fromDynamicExpression(unionType, name), ";");
            }
        });
    }
    emitPrivateClassInterface(_, name) {
        this.emitLine("@interface ", name, " (JSONConversion)");
        this.emitLine("+ (instancetype)fromJSONDictionary:(NSDictionary *)dict;");
        this.emitLine("- (NSDictionary *)JSONDictionary;");
        this.emitLine("@end");
    }
    pointerAwareTypeName(t) {
        const name = t instanceof Type ? this.objcType(t) : t;
        const isPointer = name[1] !== "";
        return isPointer ? name : [name, " "];
    }
    emitNonClassTopLevelTypedef(t, name) {
        let nonPointerTypeName = this.objcType(t)[0];
        this.emitLine("typedef ", nonPointerTypeName, " ", name, ";");
    }
    topLevelFromDataPrototype(name) {
        return [name, " *_Nullable ", name, "FromData(NSData *data, NSError **error)"];
    }
    topLevelFromJSONPrototype(name) {
        return [name, " *_Nullable ", name, "FromJSON(NSString *json, NSStringEncoding encoding, NSError **error)"];
    }
    topLevelToDataPrototype(name, pad = false) {
        const parameter = this.variableNameForTopLevel(name);
        const padding = pad ? repeatString(" ", this.sourcelikeToString(name).length - "NSData".length) : "";
        return ["NSData", padding, " *_Nullable ", name, "ToData(", name, " *", parameter, ", NSError **error)"];
    }
    topLevelToJSONPrototype(name, pad = false) {
        const parameter = this.variableNameForTopLevel(name);
        const padding = pad ? repeatString(" ", this.sourcelikeToString(name).length - "NSString".length) : "";
        return [
            "NSString",
            padding,
            " *_Nullable ",
            name,
            "ToJSON(",
            name,
            " *",
            parameter,
            ", NSStringEncoding encoding, NSError **error)"
        ];
    }
    emitTopLevelFunctionDeclarations(_, name) {
        this.emitLine(this.topLevelFromDataPrototype(name), ";");
        this.emitLine(this.topLevelFromJSONPrototype(name), ";");
        this.emitLine(this.topLevelToDataPrototype(name, true), ";");
        this.emitLine(this.topLevelToJSONPrototype(name, true), ";");
    }
    emitTryCatchAsError(inTry, inCatch) {
        this.emitLine("@try {");
        this.indent(inTry);
        this.emitLine("} @catch (NSException *exception) {");
        this.indent(() => {
            this.emitLine('*error = [NSError errorWithDomain:@"JSONSerialization" code:-1 userInfo:@{ @"exception": exception }];');
            inCatch();
        });
        this.emitLine("}");
    }
    emitTopLevelFunctions(t, name) {
        const parameter = this.variableNameForTopLevel(name);
        this.ensureBlankLine();
        this.emitMethod(this.topLevelFromDataPrototype(name), () => {
            this.emitTryCatchAsError(() => {
                this.emitLine("id json = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:error];");
                this.emitLine("return *error ? nil : ", this.fromDynamicExpression(t, "json"), ";");
            }, () => this.emitLine("return nil;"));
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelFromJSONPrototype(name), () => {
            this.emitLine("return ", name, "FromData([json dataUsingEncoding:encoding], error);");
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelToDataPrototype(name), () => {
            this.emitTryCatchAsError(() => {
                this.emitLine("id json = ", this.toDynamicExpression(t, parameter), ";");
                this.emitLine("NSData *data = [NSJSONSerialization dataWithJSONObject:json options:kNilOptions error:error];");
                this.emitLine("return *error ? nil : data;");
            }, () => this.emitLine("return nil;"));
        });
        this.ensureBlankLine();
        this.emitMethod(this.topLevelToJSONPrototype(name), () => {
            this.emitLine("NSData *data = ", name, "ToData(", parameter, ", error);");
            this.emitLine("return data ? [[NSString alloc] initWithData:data encoding:encoding] : nil;");
        });
    }
    emitClassInterface(t, className) {
        const isTopLevel = collectionUtils.mapContains(this.topLevels, t);
        this.emitDescription(this.descriptionForType(t));
        this.emitLine("@interface ", className, " : NSObject");
        this.emitPropertyTable(t, (name, _json, property) => {
            let attributes = ["nonatomic"];
            // TODO offer a 'readonly' option
            // TODO We must add "copy" if it's NSCopy, otherwise "strong"
            if (property.type.isNullable) {
                attributes.push("nullable");
            }
            attributes.push(this.memoryAttribute(property.type, property.type.isNullable));
            return [
                ["@property ", ["(", attributes.join(", "), ")"], " "],
                [this.pointerAwareTypeName(property.type), name, ";"]
            ];
        });
        if (!this._options.justTypes && isTopLevel) {
            if (t.getProperties().size > 0)
                this.ensureBlankLine();
            this.emitLine("+ (_Nullable instancetype)fromJSON:(NSString *)json encoding:(NSStringEncoding)encoding error:(NSError *_Nullable *)error;");
            this.emitLine("+ (_Nullable instancetype)fromData:(NSData *)data error:(NSError *_Nullable *)error;");
            this.emitLine("- (NSString *_Nullable)toJSON:(NSStringEncoding)encoding error:(NSError *_Nullable *)error;");
            this.emitLine("- (NSData *_Nullable)toData:(NSError *_Nullable *)error;");
        }
        this.emitLine("@end");
    }
    hasIrregularProperties(t) {
        let irregular = false;
        this.forEachClassProperty(t, "none", (name, jsonName) => {
            irregular = irregular || stringEscape$7(jsonName) !== this.sourcelikeToString(name);
        });
        return irregular;
    }
    hasUnsafeProperties(t) {
        let unsafe = false;
        this.forEachClassProperty(t, "none", (_, __, property) => {
            unsafe = unsafe || !this.implicitlyConvertsToJSON(property.type);
        });
        return unsafe;
    }
    // TODO Implement NSCopying
    emitClassImplementation(t, className) {
        const isTopLevel = collectionUtils.mapContains(this.topLevels, t);
        const hasIrregularProperties = this.hasIrregularProperties(t);
        const hasUnsafeProperties = this.hasUnsafeProperties(t);
        this.emitLine("@implementation ", className);
        if (!this._options.justTypes) {
            this.emitMethod("+ (NSDictionary<NSString *, NSString *> *)properties", () => {
                this.emitLine("static NSDictionary<NSString *, NSString *> *properties;");
                this.emitLine("return properties = properties ? properties : @{");
                this.indent(() => {
                    this.forEachClassProperty(t, "none", (name, jsonName) => this.emitLine(`@"${stringEscape$7(jsonName)}": @"`, name, '",'));
                });
                this.emitLine("};");
            });
            this.ensureBlankLine();
            if (isTopLevel) {
                this.emitMethod("+ (_Nullable instancetype)fromData:(NSData *)data error:(NSError *_Nullable *)error", () => {
                    this.emitLine("return ", className, "FromData(data, error);");
                });
                this.ensureBlankLine();
                this.emitMethod("+ (_Nullable instancetype)fromJSON:(NSString *)json encoding:(NSStringEncoding)encoding error:(NSError *_Nullable *)error", () => {
                    this.emitLine("return ", className, "FromJSON(json, encoding, error);");
                });
                this.ensureBlankLine();
            }
            this.emitMethod("+ (instancetype)fromJSONDictionary:(NSDictionary *)dict", () => {
                this.emitLine("return dict ? [[", className, " alloc] initWithJSONDictionary:dict] : nil;");
            });
            this.ensureBlankLine();
            this.emitMethod("- (instancetype)initWithJSONDictionary:(NSDictionary *)dict", () => {
                this.emitBlock("if (self = [super init])", () => {
                    this.emitLine("[self setValuesForKeysWithDictionary:dict];");
                    this.forEachClassProperty(t, "none", (name, jsonName, property) => {
                        if (!this.implicitlyConvertsFromJSON(property.type)) {
                            this.emitPropertyAssignment(name, jsonName, property.type);
                        }
                    });
                });
                this.emitLine("return self;");
            });
            this.ensureBlankLine();
            this.emitMethod("- (void)setValue:(nullable id)value forKey:(NSString *)key", () => {
                this.emitLine("id resolved = ", className, ".properties[key];");
                this.emitLine("if (resolved) [super setValue:value forKey:resolved];");
            });
            // setNilValueForKey: is automatically invoked by the NSObject setValue:forKey: when it is passed nil for a scalar (a.k.a. non-nullable) object
            // The approach below sets the scalar to 0 in this case, and therefore assumes an initializer with incomplete data shouldn't be grounds for raising an exception.
            // Put another way, if the initializer didn't have a key at all, there wouldn't be an exception raised, so sending nil for something probably shouldn't cause one.
            this.ensureBlankLine();
            this.emitMethod("- (void)setNilValueForKey:(NSString *)key", () => {
                this.emitLine("id resolved = ", className, ".properties[key];");
                this.emitLine("if (resolved) [super setValue:@(0) forKey:resolved];");
            });
            this.ensureBlankLine();
            this.emitMethod("- (NSDictionary *)JSONDictionary", () => {
                if (!hasIrregularProperties && !hasUnsafeProperties) {
                    this.emitLine("return [self dictionaryWithValuesForKeys:", className, ".properties.allValues];");
                    return;
                }
                this.emitLine("id dict = [[self dictionaryWithValuesForKeys:", className, ".properties.allValues] mutableCopy];");
                this.ensureBlankLine();
                if (hasIrregularProperties) {
                    this.emitExtraComments("Rewrite property names that differ in JSON");
                    this.emitBlock(["for (id jsonName in ", className, ".properties)"], () => {
                        this.emitLine("id propertyName = ", className, ".properties[jsonName];");
                        this.emitBlock("if (![jsonName isEqualToString:propertyName])", () => {
                            this.emitLine("dict[jsonName] = dict[propertyName];");
                            this.emitLine("[dict removeObjectForKey:propertyName];");
                        });
                    });
                }
                if (hasUnsafeProperties) {
                    this.ensureBlankLine();
                    this.emitExtraComments("Map values that need translation");
                    this.emitLine("[dict addEntriesFromDictionary:@{");
                    this.indent(() => {
                        this.forEachClassProperty(t, "none", (propertyName, jsonKey, property) => {
                            if (!this.implicitlyConvertsToJSON(property.type)) {
                                const key = stringEscape$7(jsonKey);
                                const name = ["_", propertyName];
                                this.emitLine('@"', key, '": ', this.toDynamicExpression(property.type, name), ",");
                            }
                        });
                    });
                    this.emitLine("}];");
                }
                this.ensureBlankLine();
                this.emitLine("return dict;");
            });
            if (isTopLevel) {
                this.ensureBlankLine();
                this.emitMethod("- (NSData *_Nullable)toData:(NSError *_Nullable *)error", () => {
                    this.emitLine("return ", className, "ToData(self, error);");
                });
                this.ensureBlankLine();
                this.emitMethod("- (NSString *_Nullable)toJSON:(NSStringEncoding)encoding error:(NSError *_Nullable *)error", () => {
                    this.emitLine("return ", className, "ToJSON(self, encoding, error);");
                });
            }
        }
        this.emitLine("@end");
    }
    emitMark(label) {
        this.ensureBlankLine();
        this.emitLine(`#pragma mark - ${label}`);
        this.ensureBlankLine();
    }
    variableNameForTopLevel(name) {
        const camelCaseName = modifySource(serialized => {
            // 1. remove class prefix
            serialized = serialized.slice(this._classPrefix.length);
            // 2. camel case
            return camelCase(serialized);
        }, name);
        return camelCaseName;
    }
    emitPseudoEnumInterface(enumType, enumName) {
        this.emitDescription(this.descriptionForType(enumType));
        this.emitLine("@interface ", enumName, " : NSObject");
        this.emitLine("@property (nonatomic, readonly, copy) NSString *value;");
        this.emitLine("+ (instancetype _Nullable)withValue:(NSString *)value;");
        this.forEachEnumCase(enumType, "none", (name, _) => {
            this.emitLine("+ (", enumName, " *)", name, ";");
        });
        this.emitLine("@end");
    }
    emitPseudoEnumImplementation(enumType, enumName) {
        this.emitLine("@implementation ", enumName);
        const instances = [enumName, ".", staticEnumValuesIdentifier];
        this.emitMethod(["+ (NSDictionary<NSString *, ", enumName, " *> *)", staticEnumValuesIdentifier], () => {
            this.emitLine("static NSDictionary<NSString *, ", enumName, " *> *", staticEnumValuesIdentifier, ";");
            this.emitLine("return ", staticEnumValuesIdentifier, " = ", staticEnumValuesIdentifier, " ? ", staticEnumValuesIdentifier, " : @{");
            this.indent(() => {
                this.forEachEnumCase(enumType, "none", (_, jsonValue) => {
                    const value = ['@"', stringEscape$7(jsonValue), '"'];
                    this.emitLine(value, ": [[", enumName, " alloc] initWithValue:", value, "],");
                });
            });
            this.emitLine("};");
        });
        this.ensureBlankLine();
        this.forEachEnumCase(enumType, "none", (name, jsonValue) => {
            this.emitLine("+ (", enumName, " *)", name, " { return ", instances, '[@"', stringEscape$7(jsonValue), '"]; }');
        });
        this.ensureBlankLine();
        this.emitMethod("+ (instancetype _Nullable)withValue:(NSString *)value", () => this.emitLine("return ", instances, "[value];"));
        this.ensureBlankLine();
        this.emitMethod("- (instancetype)initWithValue:(NSString *)value", () => {
            this.emitLine("if (self = [super init]) _value = value;");
            this.emitLine("return self;");
        });
        this.ensureBlankLine();
        this.emitLine("- (NSUInteger)hash { return _value.hash; }");
        this.emitLine("@end");
    }
    emitSourceStructure(proposedFilename) {
        const fileMode = proposedFilename !== "stdout";
        if (!fileMode) {
            // We don't have a filename, so we use a top-level name
            const firstTopLevel = defined(collectionUtils.mapFirst(this.topLevels));
            proposedFilename = this.sourcelikeToString(this.nameForNamedType(firstTopLevel)) + ".m";
        }
        const [filename, extension] = splitExtension(proposedFilename);
        if (this._options.features.interface) {
            this.startFile(filename, "h");
            if (this.leadingComments !== undefined) {
                this.emitComments(this.leadingComments);
            }
            else if (!this._options.justTypes) {
                this.emitCommentLines(["To parse this JSON:", ""]);
                this.emitLine("//   NSError *error;");
                this.forEachTopLevel("none", (t, topLevelName) => {
                    const fromJsonExpression = t instanceof ClassType
                        ? ["[", topLevelName, " fromJSON:json encoding:NSUTF8Encoding error:&error];"]
                        : [topLevelName, "FromJSON(json, NSUTF8Encoding, &error);"];
                    this.emitLine("//   ", topLevelName, " *", this.variableNameForTopLevel(topLevelName), " = ", fromJsonExpression);
                });
            }
            this.ensureBlankLine();
            this.emitLine("#import <Foundation/Foundation.h>");
            this.ensureBlankLine();
            // Emit @class declarations for top-level array+maps and classes
            this.forEachNamedType("none", (_, className) => this.emitLine("@class ", className, ";"), (_, enumName) => this.emitLine("@class ", enumName, ";"), () => null);
            this.ensureBlankLine();
            this.ensureBlankLine();
            this.emitLine("NS_ASSUME_NONNULL_BEGIN");
            this.ensureBlankLine();
            if (this.haveEnums) {
                this.emitMark("Boxed enums");
                this.forEachEnum("leading-and-interposing", (t, n) => this.emitPseudoEnumInterface(t, n));
            }
            // Emit interfaces for top-level array+maps and classes
            this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitNonClassTopLevelTypedef(t, n), t => !(t instanceof ClassType));
            const hasTopLevelNonClassTypes = collectionUtils.iterableSome(this.topLevels, ([_, t]) => !(t instanceof ClassType));
            if (!this._options.justTypes && (hasTopLevelNonClassTypes || this._options.marshallingFunctions)) {
                this.ensureBlankLine();
                this.emitMark("Top-level marshaling functions");
                this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitTopLevelFunctionDeclarations(t, n), 
                // Objective-C developers get freaked out by C functions, so we don't
                // declare them for top-level object types (we always need them for non-object types)
                t => this._options.marshallingFunctions || !(t instanceof ClassType));
            }
            this.emitMark("Object interfaces");
            this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassInterface(c, className), () => null, () => null);
            this.ensureBlankLine();
            this.emitLine("NS_ASSUME_NONNULL_END");
            this.finishFile();
        }
        if (this._options.features.implementation) {
            this.startFile(filename, extension);
            this.emitLine(`#import "${filename}.h"`);
            this.ensureBlankLine();
            if (!this._options.justTypes) {
                this.ensureBlankLine();
                this.emitExtraComments("Shorthand for simple blocks");
                this.emitLine("#define λ(decl, expr) (^(decl) { return (expr); })");
                this.ensureBlankLine();
                this.emitExtraComments("nil → NSNull conversion for JSON dictionaries");
                this.emitBlock("static id NSNullify(id _Nullable x)", () => this.emitLine("return (x == nil || x == NSNull.null) ? NSNull.null : x;"));
                this.ensureBlankLine();
                this.emitLine("NS_ASSUME_NONNULL_BEGIN");
                this.ensureBlankLine();
                // We wouldn't need to emit these private iterfaces if we emitted implementations in forward-order
                // but the code is more readable and explicit if we do this.
                if (this._options.extraComments) {
                    this.emitMark("Private model interfaces");
                }
                this.forEachNamedType("leading-and-interposing", (c, className) => this.emitPrivateClassInterface(c, className), () => null, () => null);
                if (this.haveEnums) {
                    if (this._options.extraComments) {
                        this.ensureBlankLine();
                        this.emitExtraComments("These enum-like reference types are needed so that enum", "values can be contained by NSArray and NSDictionary.");
                        this.ensureBlankLine();
                    }
                    this.forEachEnum("leading-and-interposing", (t, n) => this.emitPseudoEnumImplementation(t, n));
                }
                this.ensureBlankLine();
                this.emitMapFunction();
                this.ensureBlankLine();
                this.emitMark("JSON serialization");
                this.forEachTopLevel("leading-and-interposing", (t, n) => this.emitTopLevelFunctions(t, n));
            }
            this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassImplementation(c, className), () => null, () => null);
            if (!this._options.justTypes) {
                this.ensureBlankLine();
                this.emitLine("NS_ASSUME_NONNULL_END");
            }
            this.finishFile();
        }
    }
    get needsMap() {
        // TODO this isn't complete (needs union support, for example)
        function needsMap(t) {
            return (t instanceof MapType ||
                t instanceof ArrayType ||
                (t instanceof ClassType && collectionUtils.mapSome(t.getProperties(), p => needsMap(p.type))));
        }
        return collectionUtils.iterableSome(this.typeGraph.allTypesUnordered(), needsMap);
    }
    emitMapFunction() {
        if (this.needsMap) {
            this.emitMultiline(`static id map(id collection, id (^f)(id value)) {
    id result = nil;
    if ([collection isKindOfClass:NSArray.class]) {
        result = [NSMutableArray arrayWithCapacity:[collection count]];
        for (id x in collection) [result addObject:f(x)];
    } else if ([collection isKindOfClass:NSDictionary.class]) {
        result = [NSMutableDictionary dictionaryWithCapacity:[collection count]];
        for (id key in collection) [result setObject:f([collection objectForKey:key]) forKey:key];
    }
    return result;
}`);
        }
    }
}

const phpOptions = {
    withGet: new BooleanOption("with-get", "Create Getter", true),
    fastGet: new BooleanOption("fast-get", "getter without validation", false),
    withSet: new BooleanOption("with-set", "Create Setter", false),
    withClosing: new BooleanOption("with-closing", "PHP Closing Tag", false),
    acronymStyle: acronymOption(AcronymStyleOptions.Pascal)
};
class PhpTargetLanguage extends TargetLanguage {
    constructor() {
        super("PHP", ["php"], "php");
    }
    getOptions() {
        return ___namespace.values(phpOptions);
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(phpOptions, untypedOptionValues);
        return new PhpRenderer(this, renderContext, options);
    }
    get stringTypeMapping() {
        const mapping = new Map();
        mapping.set("date", "date"); // TODO is not implemented yet
        mapping.set("time", "time"); // TODO is not implemented yet
        mapping.set("uuid", "uuid"); // TODO is not implemented yet
        mapping.set("date-time", "date-time");
        return mapping;
    }
}
const stringEscape$2 = utf16ConcatMap(escapeNonPrintableMapper(isAscii, standardUnicodeHexEscape));
function isStartCharacter$4(codePoint) {
    if (codePoint === 0x5f)
        return true; // underscore
    return isAscii(codePoint) && isLetter(codePoint);
}
function isPartCharacter$4(codePoint) {
    return isStartCharacter$4(codePoint) || (isAscii(codePoint) && isDigit(codePoint));
}
const legalizeName$6 = utf16LegalizeCharacters(isPartCharacter$4);
function phpNameStyle(startWithUpper, upperUnderscore, original, acronymsStyle = allUpperWordStyle) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$6, upperUnderscore ? allUpperWordStyle : startWithUpper ? firstUpperWordStyle : allLowerWordStyle, upperUnderscore ? allUpperWordStyle : firstUpperWordStyle, upperUnderscore || startWithUpper ? allUpperWordStyle : allLowerWordStyle, acronymsStyle, upperUnderscore ? "_" : "", isStartCharacter$4);
}
class PhpRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._gettersAndSettersForPropertyName = new Map();
        this._haveEmittedLeadingComments = false;
        this._converterClassname = "Converter";
        this._converterKeywords = [];
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return this.getNameStyling("typeNamingFunction");
    }
    namerForObjectProperty() {
        return this.getNameStyling("propertyNamingFunction");
    }
    makeUnionMemberNamer() {
        return this.getNameStyling("propertyNamingFunction");
    }
    makeEnumCaseNamer() {
        return this.getNameStyling("enumCaseNamingFunction");
    }
    unionNeedsName(u) {
        return nullableFromUnion(u) === null;
    }
    namedTypeToNameForTopLevel(type) {
        return directlyReachableSingleNamedType(type);
    }
    makeNamesForPropertyGetterAndSetter(_c, _className, _p, _jsonName, name) {
        const getterName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `get_${lookup(name)}`);
        const setterName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `set_${lookup(name)}`);
        const validateName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `validate_${lookup(name)}`);
        const fromName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `from_${lookup(name)}`);
        const toName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `to_${lookup(name)}`);
        const sampleName = new DependencyName(this.getNameStyling("propertyNamingFunction"), name.order, lookup => `sample_${lookup(name)}`);
        return {
            getter: getterName,
            setter: setterName,
            validate: validateName,
            from: fromName,
            to: toName,
            sample: sampleName
        };
    }
    makePropertyDependencyNames(c, className, p, jsonName, name) {
        const getterAndSetterNames = this.makeNamesForPropertyGetterAndSetter(c, className, p, jsonName, name);
        this._gettersAndSettersForPropertyName.set(name, getterAndSetterNames);
        return [
            getterAndSetterNames.getter,
            getterAndSetterNames.setter,
            getterAndSetterNames.validate,
            getterAndSetterNames.to,
            getterAndSetterNames.from,
            getterAndSetterNames.sample
        ];
    }
    getNameStyling(convention) {
        const styling = {
            typeNamingFunction: funPrefixNamer("types", n => phpNameStyle(true, false, n, acronymStyle(this._options.acronymStyle))),
            propertyNamingFunction: funPrefixNamer("properties", n => phpNameStyle(false, false, n, acronymStyle(this._options.acronymStyle))),
            enumCaseNamingFunction: funPrefixNamer("enum-cases", n => phpNameStyle(true, true, n, acronymStyle(this._options.acronymStyle)))
        };
        return styling[convention];
    }
    startFile(_basename) {
        this.ensureBlankLine();
        if (!this._haveEmittedLeadingComments && this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
            this.ensureBlankLine();
            this._haveEmittedLeadingComments = true;
        }
    }
    finishFile() {
        // empty
    }
    emitFileHeader(fileName, _imports) {
        this.startFile(fileName);
        this.emitLine("// This is a autogenerated file:", fileName);
        this.ensureBlankLine();
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    phpType(_reference, t, isOptional = false, prefix = "?", suffix = "") {
        function optionalize(s) {
            return [isOptional ? prefix : "", s, isOptional ? suffix : ""];
        }
        return matchType(t, _anyType => maybeAnnotated(isOptional, anyTypeIssueAnnotation, "Object"), _nullType => maybeAnnotated(isOptional, nullTypeIssueAnnotation, "Object"), _boolType => optionalize("bool"), _integerType => optionalize("int"), _doubleType => optionalize("float"), _stringType => optionalize("string"), _arrayType => optionalize("array"), classType => optionalize(this.nameForNamedType(classType)), _mapType => optionalize("stdClass"), enumType => optionalize(this.nameForNamedType(enumType)), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return this.phpType(true, nullable, true, prefix, suffix);
            return this.nameForNamedType(unionType);
        }, transformedStringType => {
            if (transformedStringType.kind === "time") {
                throw Error('transformedStringType.kind === "time"');
            }
            if (transformedStringType.kind === "date") {
                throw Error('transformedStringType.kind === "date"');
            }
            if (transformedStringType.kind === "date-time") {
                return "DateTime";
            }
            if (transformedStringType.kind === "uuid") {
                throw Error('transformedStringType.kind === "uuid"');
            }
            return "string";
        });
    }
    phpDocConvertType(className, t) {
        return matchType(t, _anyType => "any", _nullType => "null", _boolType => "bool", _integerType => "int", _doubleType => "float", _stringType => "string", arrayType => [this.phpDocConvertType(className, arrayType.items), "[]"], _classType => _classType.getCombinedName(), _mapType => "stdClass", enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return [this.phpDocConvertType(className, nullable), "|null"];
            }
            throw Error("union are not supported");
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return "DateTime";
            }
            throw Error('transformedStringType.kind === "unknown"');
        });
    }
    phpConvertType(className, t) {
        return matchType(t, _anyType => "any", _nullType => "null", _boolType => "bool", _integerType => "int", _doubleType => "float", _stringType => "string", _arrayType => "array", _classType => "stdClass", _mapType => "stdClass", _enumType => "string", // TODO number this.nameForNamedType(enumType),
        // TODO number this.nameForNamedType(enumType),
        unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return ["?", this.phpConvertType(className, nullable)];
            }
            throw Error("union are not supported");
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return "string";
            }
            throw Error('transformedStringType.kind === "unknown"');
        });
    }
    phpToObjConvert(className, t, lhs, args) {
        matchType(t, _anyType => this.emitLine(...lhs, ...args, "; /*any*/"), _nullType => this.emitLine(...lhs, ...args, "; /*null*/"), _boolType => this.emitLine(...lhs, ...args, "; /*bool*/"), _integerType => this.emitLine(...lhs, ...args, "; /*int*/"), _doubleType => this.emitLine(...lhs, ...args, "; /*float*/"), _stringType => this.emitLine(...lhs, ...args, "; /*string*/"), arrayType => {
            this.emitLine(...lhs, "array_map(function ($value) {");
            this.indent(() => {
                this.phpToObjConvert(className, arrayType.items, ["return "], ["$value"]);
                // this.emitLine("return $tmp;");
            });
            this.emitLine("}, ", ...args, ");");
        }, _classType => this.emitLine(...lhs, ...args, "->to(); ", "/*class*/"), mapType => {
            this.emitBlock(["function to($my): stdClass"], () => {
                this.emitLine("$out = new stdClass();");
                this.emitBlock(["foreach ($my as $k => $v)"], () => {
                    this.phpToObjConvert(className, mapType.values, ["$my->$k = "], ["$v"]);
                });
                this.emitLine("return $out;");
            });
            this.emitLine("return to(", ...args, ");");
        }, enumType => this.emitLine(...lhs, this.nameForNamedType(enumType), "::to(", ...args, "); ", "/*enum*/"), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                this.emitLine("if (!is_null(", ...args, ")) {");
                this.indent(() => this.phpToObjConvert(className, nullable, lhs, args));
                this.emitLine("} else {");
                this.indent(() => this.emitLine(...lhs, " null;"));
                this.emitLine("}");
                return;
            }
            throw Error("union are not supported");
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                this.emitLine(...lhs, ...args, "->format(DateTimeInterface::ISO8601);");
                return;
            }
            throw Error('transformedStringType.kind === "unknown"');
        });
    }
    transformDateTime(className, attrName, scopeAttrName) {
        this.emitBlock(["if (!is_a(", scopeAttrName, ", 'DateTime'))"], () => this.emitLine("throw new Exception('Attribute Error:", className, "::", attrName, "');"));
        // if (lhs !== undefined) {
        //     this.emitLine(lhs, "$tmp;");
        // }
    }
    phpFromObjConvert(className, t, lhs, args) {
        matchType(t, _anyType => this.emitLine(...lhs, ...args, "; /*any*/"), _nullType => this.emitLine(...lhs, ...args, "; /*null*/"), _boolType => this.emitLine(...lhs, ...args, "; /*bool*/"), _integerType => this.emitLine(...lhs, ...args, "; /*int*/"), _doubleType => this.emitLine(...lhs, ...args, "; /*float*/"), _stringType => this.emitLine(...lhs, ...args, "; /*string*/"), arrayType => {
            this.emitLine(...lhs, " array_map(function ($value) {");
            this.indent(() => {
                this.phpFromObjConvert(className, arrayType.items, ["return "], ["$value"]);
                // this.emitLine("return $tmp;");
            });
            this.emitLine("}, ", ...args, ");");
        }, classType => this.emitLine(...lhs, this.nameForNamedType(classType), "::from(", ...args, "); ", "/*class*/"), mapType => {
            this.emitBlock(["function from($my): stdClass"], () => {
                this.emitLine("$out = new stdClass();");
                this.emitBlock(["foreach ($my as $k => $v)"], () => {
                    this.phpFromObjConvert(className, mapType.values, ["$out->$k = "], ["$v"]);
                });
                this.emitLine("return $out;");
            });
            this.emitLine("return from(", ...args, ");");
        }, enumType => this.emitLine(...lhs, this.nameForNamedType(enumType), "::from(", ...args, "); ", "/*enum*/"), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                this.emitLine("if (!is_null(", ...args, ")) {");
                this.indent(() => this.phpFromObjConvert(className, nullable, lhs, args));
                this.emitLine("} else {");
                this.indent(() => this.emitLine("return null;"));
                this.emitLine("}");
                return;
            }
            throw Error("union are not supported");
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                this.emitLine("$tmp = ", "DateTime::createFromFormat(DateTimeInterface::ISO8601, ", args, ");");
                this.transformDateTime(className, "", ["$tmp"]);
                this.emitLine("return $tmp;");
                return;
            }
            throw Error('transformedStringType.kind === "unknown"');
        });
    }
    phpSampleConvert(className, t, lhs, args, idx, suffix) {
        matchType(t, _anyType => this.emitLine(...lhs, "'AnyType::", className, "::", args, "::" + idx, "'", suffix, "/*", "" + idx, ":", args, "*/"), _nullType => this.emitLine(...lhs, "null", suffix, " /*", "" + idx, ":", args, "*/"), _boolType => this.emitLine(...lhs, "true", suffix, " /*", "" + idx, ":", args, "*/"), _integerType => this.emitLine(...lhs, "" + idx, suffix, " /*", "" + idx, ":", args, "*/"), _doubleType => this.emitLine(...lhs, "" + (idx + idx / 1000), suffix, " /*", "" + idx, ":", args, "*/"), _stringType => this.emitLine(...lhs, "'", className, "::", args, "::" + idx, "'", suffix, " /*", "" + idx, ":", args, "*/"), arrayType => {
            this.emitLine(...lhs, " array(");
            this.indent(() => {
                this.phpSampleConvert(className, arrayType.items, [], [], idx, "");
            });
            this.emitLine("); /* ", "" + idx, ":", args, "*/");
        }, classType => this.emitLine(...lhs, this.nameForNamedType(classType), "::sample()", suffix, " /*", "" + idx, ":", args, "*/"), mapType => {
            this.emitBlock(["function sample(): stdClass"], () => {
                this.emitLine("$out = new stdClass();");
                this.phpSampleConvert(className, mapType.values, ["$out->{'", className, "'} = "], args, idx, ";");
                this.emitLine("return $out;");
            });
            this.emitLine("return sample();");
        }, enumType => this.emitLine(...lhs, this.nameForNamedType(enumType), "::sample()", suffix, " /*enum*/"), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                this.phpSampleConvert(className, nullable, lhs, args, idx, suffix);
                return;
            }
            throw Error("union are not supported:" + unionType);
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                const x = ___namespace.pad("" + (1 + (idx % 31)), 2, "0");
                this.emitLine(...lhs, "DateTime::createFromFormat(DateTimeInterface::ISO8601, '", `2020-12-${x}T12:${x}:${x}+00:00`, "')", suffix);
                // this.emitLine("return sample();");
                return;
            }
            throw Error('transformedStringType.kind === "unknown"');
        });
    }
    phpValidate(className, t, attrName, scopeAttrName) {
        const is = (isfn, myT = className) => {
            this.emitBlock(["if (!", isfn, "(", scopeAttrName, "))"], () => this.emitLine('throw new Exception("Attribute Error:', myT, "::", attrName, '");'));
        };
        matchType(t, _anyType => is("defined"), _nullType => is("is_null"), _boolType => is("is_bool"), _integerType => is("is_integer"), _doubleType => is("is_float"), _stringType => is("is_string"), arrayType => {
            is("is_array");
            this.emitLine("array_walk(", scopeAttrName, ", function(", scopeAttrName, "_v) {");
            this.indent(() => {
                this.phpValidate(className, arrayType.items, attrName, `${scopeAttrName}_v`);
            });
            this.emitLine("});");
        }, _classType => {
            this.emitLine(scopeAttrName, "->validate();");
        }, mapType => {
            this.emitLine("foreach (", scopeAttrName, " as $k => $v) {");
            this.indent(() => {
                this.phpValidate(className, mapType.values, attrName, "$v");
            });
            this.emitLine("}");
        }, enumType => {
            this.emitLine(this.phpType(false, enumType), "::to(", scopeAttrName, ");");
        }, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                this.emitBlock(["if (!is_null(", scopeAttrName, "))"], () => {
                    this.phpValidate(className, nullable, attrName, scopeAttrName);
                });
                return;
            }
            throw Error("not implemented");
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                this.transformDateTime(className, attrName, [scopeAttrName]);
                return;
            }
            throw Error(`transformedStringType.kind === ${transformedStringType.kind}`);
        });
    }
    emitFromMethod(names, p, className, _name, desc) {
        this.emitLine("/**");
        if (desc !== undefined) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
        }
        // this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
        this.emitLine(" * @param ", this.phpConvertType(className, p.type), " $value");
        this.emitLine(" * @throws Exception");
        this.emitLine(" * @return ", this.phpType(false, p.type));
        this.emitLine(" */");
        this.emitBlock([
            "public static function ",
            names.from,
            "(",
            this.phpConvertType(className, p.type),
            " $value): ",
            this.phpType(false, p.type)
        ], () => {
            this.phpFromObjConvert(className, p.type, ["return "], ["$value"]);
            // this.emitLine("return $ret;");
        });
    }
    emitToMethod(names, p, className, name, desc) {
        this.emitLine("/**");
        if (desc !== undefined) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
        }
        this.emitLine(" * @throws Exception");
        this.emitLine(" * @return ", this.phpConvertType(className, p.type));
        this.emitLine(" */");
        this.emitBlock(["public function ", names.to, "(): ", this.phpConvertType(className, p.type)], () => {
            this.emitBlock(["if (", className, "::", names.validate, "($this->", name, ")) "], () => {
                this.phpToObjConvert(className, p.type, ["return "], ["$this->", name]);
            });
            this.emitLine("throw new Exception('never get to this ", className, "::", name, "');");
        });
    }
    emitValidateMethod(names, p, className, name, desc) {
        this.emitLine("/**");
        if (desc !== undefined) {
            this.emitLine(" * ", desc);
            this.emitLine(" *");
        }
        this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
        this.emitLine(" * @return bool");
        this.emitLine(" * @throws Exception");
        this.emitLine(" */");
        this.emitBlock(["public static function ", names.validate, "(", this.phpType(false, p.type), " $value): bool"], () => {
            this.phpValidate(className, p.type, name, "$value");
            this.emitLine("return true;");
        });
    }
    emitGetMethod(names, p, className, name, desc) {
        if (this._options.withGet) {
            this.emitLine("/**");
            if (desc !== undefined) {
                this.emitLine(" * ", desc);
                this.emitLine(" *");
            }
            if (!this._options.fastGet) {
                this.emitLine(" * @throws Exception");
            }
            const rendered = this.phpType(false, p.type);
            this.emitLine(" * @return ", rendered);
            this.emitLine(" */");
            this.emitBlock(["public function ", names.getter, "(): ", rendered], () => {
                if (!this._options.fastGet) {
                    this.emitBlock(["if (", className, "::", names.validate, "($this->", name, ")) "], () => {
                        this.emitLine("return $this->", name, ";");
                    });
                    this.emitLine("throw new Exception('never get to ", names.getter, " ", className, "::", name, "');");
                }
                else {
                    this.emitLine("return $this->", name, ";");
                }
            });
        }
    }
    emitSetMethod(names, p, className, name, desc) {
        if (this._options.withSet) {
            this.emitLine("/**");
            if (desc !== undefined) {
                this.emitLine(" * ", desc);
                this.emitLine(" *");
            }
            this.emitLine(" * @param ", this.phpType(false, p.type, false, "", "|null"));
            this.emitLine(" * @throws Exception");
            this.emitLine(" */");
            this.emitBlock(["public function ", names.setter, "(", this.phpType(false, p.type), " $value)"], () => {
                this.emitBlock(["if (", className, "::", names.validate, "($value)) "], () => {
                    this.emitLine("$this->", name, " = $value;");
                });
            });
        }
    }
    emitSampleMethod(names, p, className, name, desc, idx) {
        if (this._options.withGet) {
            this.emitLine("/**");
            if (desc !== undefined) {
                this.emitLine(" * ", desc);
                this.emitLine(" *");
            }
            const rendered = this.phpType(false, p.type);
            this.emitLine(" * @return ", rendered);
            this.emitLine(" */");
            this.emitBlock(["public static function ", names.sample, "(): ", rendered], () => {
                this.phpSampleConvert(className, p.type, ["return "], [name], idx, ";");
            });
        }
    }
    emitClassDefinition(c, className) {
        this.emitFileHeader(className, []);
        this.emitBlock(["class ", className], () => {
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                this.emitLine("private ", this.phpType(false, p.type), " $", name, "; // json:", jsonName, " ", p.type.isNullable ? "Optional" : "Required");
            });
            this.ensureBlankLine();
            const comments = [];
            const args = [];
            let prefix = "";
            this.forEachClassProperty(c, "none", (name, __, p) => {
                args.push([prefix, this.phpType(false, p.type), " $", name]);
                prefix = ", ";
                comments.push([" * @param ", this.phpType(false, p.type, false, "", "|null"), " $", name, "\n"]);
            });
            this.emitBlock(["/**\n", ...comments, " */\n", "public function __construct(", ...args, ")"], () => {
                this.forEachClassProperty(c, "none", name => {
                    this.emitLine("$this->", name, " = $", name, ";");
                });
            });
            let idx = 31;
            this.forEachClassProperty(c, "leading-and-interposing", (name, jsonName, p) => {
                const desc = this.descriptionForClassProperty(c, jsonName);
                const names = defined(this._gettersAndSettersForPropertyName.get(name));
                this.ensureBlankLine();
                this.emitFromMethod(names, p, className, name, desc);
                this.ensureBlankLine();
                this.emitToMethod(names, p, className, name, desc);
                this.ensureBlankLine();
                this.emitValidateMethod(names, p, className, name, desc);
                this.ensureBlankLine();
                this.emitGetMethod(names, p, className, name, desc);
                this.ensureBlankLine();
                this.emitSetMethod(names, p, className, name, desc);
                this.ensureBlankLine();
                this.emitSampleMethod(names, p, className, name, desc, idx++);
            });
            this.ensureBlankLine();
            this.emitBlock(["/**\n", " * @throws Exception\n", " * @return bool\n", " */\n", "public function validate(): bool"], () => {
                let lines = [];
                let p = "return ";
                this.forEachClassProperty(c, "none", (name, _jsonName, _p) => {
                    const names = defined(this._gettersAndSettersForPropertyName.get(name));
                    lines.push([p, className, "::", names.validate, "($this->", name, ")"]);
                    p = "|| ";
                });
                lines.forEach((line, jdx) => {
                    this.emitLine(...line, lines.length === jdx + 1 ? ";" : "");
                });
            });
            this.ensureBlankLine();
            this.emitBlock([
                "/**\n",
                " * @return stdClass\n",
                " * @throws Exception\n",
                " */\n",
                "public function to(): stdClass "
            ], () => {
                this.emitLine("$out = new stdClass();");
                this.forEachClassProperty(c, "none", (name, jsonName) => {
                    const names = defined(this._gettersAndSettersForPropertyName.get(name));
                    this.emitLine("$out->{'", jsonName, "'} = $this->", names.to, "();");
                });
                this.emitLine("return $out;");
            });
            this.ensureBlankLine();
            this.emitBlock([
                "/**\n",
                " * @param stdClass $obj\n",
                " * @return ",
                className,
                "\n",
                " * @throws Exception\n",
                " */\n",
                "public static function from(stdClass $obj): ",
                className
            ], () => {
                if (this._options.fastGet) {
                    this.forEachClassProperty(c, "none", name => {
                        const names = defined(this._gettersAndSettersForPropertyName.get(name));
                        this.emitLine(className, "::", names.validate, "($this->", name, ", true);");
                    });
                }
                this.emitLine("return new ", className, "(");
                let comma = " ";
                this.forEachClassProperty(c, "none", (name, jsonName) => {
                    const names = defined(this._gettersAndSettersForPropertyName.get(name));
                    this.emitLine(comma, className, "::", names.from, "($obj->{'", jsonName, "'})");
                    comma = ",";
                });
                this.emitLine(");");
            });
            this.ensureBlankLine();
            this.emitBlock(["/**\n", " * @return ", className, "\n", " */\n", "public static function sample(): ", className], () => {
                this.emitLine("return new ", className, "(");
                let comma = " ";
                this.forEachClassProperty(c, "none", name => {
                    const names = defined(this._gettersAndSettersForPropertyName.get(name));
                    this.emitLine(comma, className, "::", names.sample, "()");
                    comma = ",";
                });
                this.emitLine(");");
            });
        });
        this.finishFile();
    }
    emitUnionAttributes(_u, _unionName) {
        // empty
    }
    emitUnionSerializer(_u, _unionName) {
        // empty
    }
    emitUnionDefinition(_u, _unionName) {
        throw Error("emitUnionDefinition not implemented");
    }
    emitEnumSerializationAttributes(_e) {
        // Empty
    }
    emitEnumDeserializationAttributes(_e) {
        // Empty
    }
    emitEnumDefinition(e, enumName) {
        this.emitFileHeader(enumName, []);
        this.emitDescription(this.descriptionForType(e));
        const enumSerdeType = "string";
        this.emitBlock(["class ", enumName], () => {
            this.forEachEnumCase(e, "none", (name, _jsonName) => {
                this.emitLine("public static ", enumName, " $", name, ";");
            });
            this.emitBlock("public static function init()", () => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    this.emitLine(enumName, "::$", name, " = new ", enumName, "('", jsonName, "');");
                });
            });
            this.emitLine("private ", enumSerdeType, " $enum;");
            this.emitBlock(["public function __construct(", enumSerdeType, " $enum)"], () => {
                this.emitLine("$this->enum = $enum;");
            });
            this.ensureBlankLine();
            this.emitEnumSerializationAttributes(e);
            this.emitBlock([
                "/**\n",
                " * @param ",
                enumName,
                "\n",
                " * @return ",
                enumSerdeType,
                "\n",
                " * @throws Exception\n",
                " */\n",
                "public static function to(",
                enumName,
                " $obj): ",
                enumSerdeType
            ], () => {
                this.emitLine("switch ($obj->enum) {");
                this.indent(() => {
                    this.forEachEnumCase(e, "none", (name, jsonName) => {
                        // Todo String or Number
                        this.emitLine("case ", enumName, "::$", name, "->enum: return '", stringEscape$2(jsonName), "';");
                    });
                });
                this.emitLine("}");
                this.emitLine("throw new Exception('the give value is not an enum-value.');");
            });
            this.ensureBlankLine();
            this.emitEnumDeserializationAttributes(e);
            this.emitBlock([
                "/**\n",
                " * @param mixed\n",
                " * @return ",
                enumName,
                "\n",
                " * @throws Exception\n",
                " */\n",
                "public static function from($obj): ",
                enumName
            ], () => {
                this.emitLine("switch ($obj) {");
                this.indent(() => {
                    this.forEachEnumCase(e, "none", (name, jsonName) => {
                        // Todo String or Enum
                        this.emitLine("case '", stringEscape$2(jsonName), "': return ", enumName, "::$", name, ";");
                    });
                });
                this.emitLine("}");
                this.emitLine('throw new Exception("Cannot deserialize ', enumName, '");');
            });
            this.ensureBlankLine();
            this.emitBlock(["/**\n", " * @return ", enumName, "\n", " */\n", "public static function sample(): ", enumName], () => {
                const lines = [];
                this.forEachEnumCase(e, "none", name => {
                    lines.push([enumName, "::$", name]);
                });
                this.emitLine("return ", lines[0], ";");
            });
        });
        this.emitLine(enumName, "::init();");
        this.finishFile();
    }
    emitSourceStructure(givenFilename) {
        this.emitLine("<?php");
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
        if (this._options.withClosing) {
            this.emitLine("?>");
        }
        super.finishFile(defined(givenFilename));
    }
}

const keywords$5 = [
    "auto",
    "nomask",
    "final",
    "static",
    "extern",
    "private",
    "local",
    "public",
    "protected",
    "inline",
    "optional",
    "variant",
    "void",
    "mixed",
    "array",
    "__attribute__",
    "__deprecated__",
    "mapping",
    "multiset",
    "object",
    "function",
    "__func__",
    "program",
    "string",
    "float",
    "int",
    "enum",
    "typedef",
    "if",
    "do",
    "for",
    "while",
    "else",
    "foreach",
    "catch",
    "gauge",
    "class",
    "break",
    "case",
    "const",
    "constant",
    "continue",
    "default",
    "import",
    "inherit",
    "lambda",
    "predef",
    "return",
    "sscanf",
    "switch",
    "typeof",
    "global"
];
const legalizeName$5 = legalizeCharacters(isLetterOrUnderscoreOrDigit);
const enumNamingFunction = funPrefixNamer("enumNamer", makeNameStyle("upper-underscore", legalizeName$5));
const namingFunction = funPrefixNamer("genericNamer", makeNameStyle("underscore", legalizeName$5));
const namedTypeNamingFunction = funPrefixNamer("typeNamer", makeNameStyle("pascal", legalizeName$5));
class PikeTargetLanguage extends TargetLanguage {
    constructor() {
        super("Pike", ["pike", "pikelang"], "pmod");
    }
    getOptions() {
        return [];
    }
    makeRenderer(renderContext) {
        return new PikeRenderer(this, renderContext);
    }
}
class PikeRenderer extends ConvenienceRenderer {
    emitSourceStructure() {
        this.emitInformationComment();
        this.ensureBlankLine();
        this.forEachTopLevel("leading", (t, name) => {
            this.emitTopLevelTypedef(t, name);
            this.ensureBlankLine();
            this.emitTopLevelConverter(t, name);
            this.ensureBlankLine();
        }, t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.ensureBlankLine();
        this.forEachNamedType("leading-and-interposing", (c, className) => this.emitClassDefinition(c, className), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
    }
    get enumCasesInGlobalNamespace() {
        return true;
    }
    makeEnumCaseNamer() {
        return enumNamingFunction;
    }
    makeNamedTypeNamer() {
        return namedTypeNamingFunction;
    }
    makeUnionMemberNamer() {
        return namingFunction;
    }
    namerForObjectProperty() {
        return namingFunction;
    }
    forbiddenNamesForGlobalNamespace() {
        return [...keywords$5];
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
    }
    sourceFor(t) {
        if (["class", "object", "enum"].includes(t.kind)) {
            return singleWord(this.nameForNamedType(t));
        }
        return matchType(t, _anyType => singleWord("mixed"), _nullType => singleWord("mixed"), _boolType => singleWord("bool"), _integerType => singleWord("int"), _doubleType => singleWord("float"), _stringType => singleWord("string"), arrayType => singleWord(["array(", this.sourceFor(arrayType.items).source, ")"]), _classType => singleWord(this.nameForNamedType(_classType)), mapType => {
            let valueSource;
            const v = mapType.values;
            valueSource = this.sourceFor(v).source;
            return singleWord(["mapping(string:", valueSource, ")"]);
        }, _enumType => singleWord("enum"), unionType => {
            if (nullableFromUnion(unionType) !== null) {
                const children = Array.from(unionType.getChildren()).map(c => parenIfNeeded(this.sourceFor(c)));
                return multiWord("|", ...children);
            }
            else {
                return singleWord(this.nameForNamedType(unionType));
            }
        });
    }
    emitClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock(["class ", className], () => {
            this.emitClassMembers(c);
            this.ensureBlankLine();
            this.emitEncodingFunction(c);
        });
        this.ensureBlankLine();
        this.emitDecodingFunction(className, c);
    }
    emitEnum(e, enumName) {
        this.emitBlock([e.kind, " ", enumName], () => {
            let table = [];
            this.forEachEnumCase(e, "none", (name, jsonName) => {
                table.push([
                    [name, ' = "', stringEscape$7(jsonName), '", '],
                    ['// json: "', jsonName, '"']
                ]);
            });
            this.emitTable(table);
        });
    }
    emitUnion(u, unionName) {
        const isMaybeWithSingleType = nullableFromUnion(u);
        if (isMaybeWithSingleType !== null) {
            return;
        }
        this.emitDescription(this.descriptionForType(u));
        const [, nonNulls] = removeNullFromUnion(u);
        let types = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_name, t) => {
            const pikeType = this.sourceFor(t).source;
            types.push([pikeType]);
        });
        this.emitLine([
            "typedef ",
            types.map(r => r.map(sl => this.sourcelikeToString(sl))).join("|"),
            " ",
            unionName,
            ";"
        ]);
        this.ensureBlankLine();
        this.emitBlock([unionName, " ", unionName, "_from_JSON(mixed json)"], () => {
            this.emitLine(["return json;"]);
        });
    }
    emitBlock(line, f, opening = " {", closing = "}") {
        this.emitLine(line, opening);
        this.indent(f);
        this.emitLine(closing);
    }
    emitMappingBlock(line, f) {
        this.emitBlock(line, f, "([", "]);");
    }
    emitClassMembers(c) {
        let table = [];
        this.forEachClassProperty(c, "none", (name, jsonName, p) => {
            const pikeType = this.sourceFor(p.type).source;
            table.push([
                [pikeType, " "],
                [name, "; "],
                ['// json: "', jsonName, '"']
            ]);
        });
        this.emitTable(table);
    }
    emitInformationComment() {
        this.emitCommentLines([
            "This source has been automatically generated by quicktype.",
            "( https://github.com/quicktype/quicktype )",
            "",
            "To use this code, simply import it into your project as a Pike module.",
            "To JSON-encode your object, you can pass it to `Standards.JSON.encode`",
            "or call `encode_json` on it.",
            "",
            "To decode a JSON string, first pass it to `Standards.JSON.decode`,",
            "and then pass the result to `<YourClass>_from_JSON`.",
            "It will return an instance of <YourClass>.",
            "Bear in mind that these functions have unexpected behavior,",
            "and will likely throw an error, if the JSON string does not",
            "match the expected interface, even if the JSON itself is valid."
        ], { lineStart: "// " });
    }
    emitTopLevelTypedef(t, name) {
        this.emitLine("typedef ", this.sourceFor(t).source, " ", name, ";");
    }
    emitTopLevelConverter(t, name) {
        this.emitBlock([name, " ", name, "_from_JSON(mixed json)"], () => {
            if (t instanceof PrimitiveType) {
                this.emitLine(["return json;"]);
            }
            else if (t instanceof ArrayType) {
                if (t.items instanceof PrimitiveType)
                    this.emitLine(["return json;"]);
                else
                    this.emitLine(["return map(json, ", this.sourceFor(t.items).source, "_from_JSON);"]);
            }
            else if (t instanceof MapType) {
                const type = this.sourceFor(t.values).source;
                this.emitLine(["mapping(string:", type, ") retval = ([]);"]);
                let assignmentRval;
                if (t.values instanceof PrimitiveType)
                    assignmentRval = ["(", type, ") v"];
                else
                    assignmentRval = [type, "_from_JSON(v)"];
                this.emitBlock(["foreach (json; string k; mixed v)"], () => {
                    this.emitLine(["retval[k] = ", assignmentRval, ";"]);
                });
                this.emitLine(["return retval;"]);
            }
        });
    }
    emitEncodingFunction(c) {
        this.emitBlock(["string encode_json()"], () => {
            this.emitMappingBlock(["mapping(string:mixed) json = "], () => {
                this.forEachClassProperty(c, "none", (name, jsonName) => {
                    this.emitLine(['"', stringEscape$7(jsonName), '" : ', name, ","]);
                });
            });
            this.ensureBlankLine();
            this.emitLine(["return Standards.JSON.encode(json);"]);
        });
    }
    emitDecodingFunction(className, c) {
        this.emitBlock([className, " ", className, "_from_JSON(mixed json)"], () => {
            this.emitLine([className, " retval = ", className, "();"]);
            this.ensureBlankLine();
            this.forEachClassProperty(c, "none", (name, jsonName) => {
                this.emitLine(["retval.", name, ' = json["', stringEscape$7(jsonName), '"];']);
            });
            this.ensureBlankLine();
            this.emitLine(["return retval;"]);
        });
    }
}

const forbiddenTypeNames = [
    "Any",
    "True",
    "False",
    "None",
    "Enum",
    "List",
    "Dict",
    "Optional",
    "Union",
    "Iterable",
    "Type",
    "TypeVar",
    "T",
    "EnumT"
];
const forbiddenPropertyNames = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "bool",
    "break",
    "class",
    "continue",
    "datetime",
    "def",
    "del",
    "dict",
    "elif",
    "else",
    "except",
    "finally",
    "float",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "int",
    "is",
    "lambda",
    "nonlocal",
    "not",
    "or",
    "pass",
    "print",
    "raise",
    "return",
    "self",
    "str",
    "try",
    "while",
    "with",
    "yield"
];
const pythonOptions = {
    features: new EnumOption("python-version", "Python version", [
        ["3.5", { typeHints: false, dataClasses: false }],
        ["3.6", { typeHints: true, dataClasses: false }],
        ["3.7", { typeHints: true, dataClasses: true }]
    ], "3.6"),
    justTypes: new BooleanOption("just-types", "Classes only", false),
    nicePropertyNames: new BooleanOption("nice-property-names", "Transform property names to be Pythonic", true)
};
class PythonTargetLanguage extends TargetLanguage {
    getOptions() {
        return [pythonOptions.features, pythonOptions.justTypes, pythonOptions.nicePropertyNames];
    }
    get stringTypeMapping() {
        const mapping = new Map();
        const dateTimeType = "date-time";
        mapping.set("date", dateTimeType);
        mapping.set("time", dateTimeType);
        mapping.set("date-time", dateTimeType);
        mapping.set("uuid", "uuid");
        mapping.set("integer-string", "integer-string");
        mapping.set("bool-string", "bool-string");
        return mapping;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    get supportsOptionalClassProperties() {
        return false;
    }
    needsTransformerForType(t) {
        if (t instanceof UnionType) {
            return collectionUtils.iterableSome(t.members, m => this.needsTransformerForType(m));
        }
        return t.kind === "integer-string" || t.kind === "bool-string";
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(pythonOptions, untypedOptionValues);
        if (options.justTypes) {
            return new PythonRenderer(this, renderContext, options);
        }
        else {
            return new JSONPythonRenderer(this, renderContext, options);
        }
    }
}
function isNormalizedStartCharacter3(utf16Unit) {
    // FIXME: add Other_ID_Start - https://docs.python.org/3/reference/lexical_analysis.html#identifiers
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(utf16Unit);
    return ["Lu", "Ll", "Lt", "Lm", "Lo", "Nl"].includes(category);
}
function isNormalizedPartCharacter3(utf16Unit) {
    // FIXME: add Other_ID_Continue - https://docs.python.org/3/reference/lexical_analysis.html#identifiers
    if (isNormalizedStartCharacter3(utf16Unit))
        return true;
    const category = $747425b437e121da$export$2e2bcd8739ae039.getCategory(utf16Unit);
    return ["Mn", "Mc", "Nd", "Pc"].includes(category);
}
function isStartCharacter3(utf16Unit) {
    const s = String.fromCharCode(utf16Unit).normalize("NFKC");
    const l = s.length;
    if (l === 0 || !isNormalizedStartCharacter3(s.charCodeAt(0)))
        return false;
    for (let i = 1; i < l; i++) {
        if (!isNormalizedPartCharacter3(s.charCodeAt(i)))
            return false;
    }
    return true;
}
function isPartCharacter3(utf16Unit) {
    const s = String.fromCharCode(utf16Unit).normalize("NFKC");
    const l = s.length;
    for (let i = 0; i < l; i++) {
        if (!isNormalizedPartCharacter3(s.charCodeAt(i)))
            return false;
    }
    return true;
}
const legalizeName3 = utf16LegalizeCharacters(isPartCharacter3);
function classNameStyle(original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName3, firstUpperWordStyle, firstUpperWordStyle, allUpperWordStyle, allUpperWordStyle, "", isStartCharacter3);
}
function getWordStyle(uppercase, forceSnakeNameStyle) {
    if (!forceSnakeNameStyle) {
        return originalWord;
    }
    return uppercase ? allUpperWordStyle : allLowerWordStyle;
}
function snakeNameStyle(original, uppercase, forceSnakeNameStyle) {
    const wordStyle = getWordStyle(uppercase, forceSnakeNameStyle);
    const separator = forceSnakeNameStyle ? "_" : "";
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName3, wordStyle, wordStyle, wordStyle, wordStyle, separator, isStartCharacter3);
}
class PythonRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, pyOptions) {
        super(targetLanguage, renderContext);
        this.pyOptions = pyOptions;
        this.imports = new Map();
        this.declaredTypes = new Set();
    }
    forbiddenNamesForGlobalNamespace() {
        return forbiddenTypeNames;
    }
    forbiddenForObjectProperties(_, _classNamed) {
        return { names: forbiddenPropertyNames, includeGlobalForbidden: false };
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("type", classNameStyle);
    }
    namerForObjectProperty() {
        return funPrefixNamer("property", s => snakeNameStyle(s, false, this.pyOptions.nicePropertyNames));
    }
    makeUnionMemberNamer() {
        return null;
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("enum-case", s => snakeNameStyle(s, true, this.pyOptions.nicePropertyNames));
    }
    get commentLineStart() {
        return "# ";
    }
    emitDescriptionBlock(lines) {
        if (lines.length === 1) {
            const docstring = modifySource(content => {
                if (content.endsWith('"')) {
                    return content.slice(0, -1) + '\\"';
                }
                return content;
            }, lines[0]);
            this.emitComments([{ customLines: [docstring], lineStart: '"""', lineEnd: '"""' }]);
        }
        else {
            this.emitCommentLines(lines, {
                firstLineStart: '"""',
                lineStart: "",
                afterComment: '"""'
            });
        }
    }
    get needsTypeDeclarationBeforeUse() {
        return true;
    }
    canBeForwardDeclared(t) {
        const kind = t.kind;
        return kind === "class" || kind === "enum";
    }
    emitBlock(line, f) {
        this.emitLine(line);
        this.indent(f);
    }
    string(s) {
        const openQuote = '"';
        return [openQuote, stringEscape$7(s), '"'];
    }
    withImport(module, name) {
        if (this.pyOptions.features.typeHints || module !== "typing") {
            // FIXME: This is ugly.  We should rather not generate that import in the first
            // place, but right now we just make the type source and then throw it away.  It's
            // not a performance issue, so it's fine, I just bemoan this special case, and
            // potential others down the road.
            collectionUtils.mapUpdateInto(this.imports, module, s => (s ? collectionUtils.setUnionInto(s, [name]) : new Set([name])));
        }
        return name;
    }
    withTyping(name) {
        return this.withImport("typing", name);
    }
    namedType(t) {
        const name = this.nameForNamedType(t);
        if (this.declaredTypes.has(t))
            return name;
        return ["'", name, "'"];
    }
    pythonType(t, _isRootTypeDef = false) {
        const actualType = followTargetType(t);
        return matchType(actualType, _anyType => this.withTyping("Any"), _nullType => "None", _boolType => "bool", _integerType => "int", _doubletype => "float", _stringType => "str", arrayType => [this.withTyping("List"), "[", this.pythonType(arrayType.items), "]"], classType => this.namedType(classType), mapType => [this.withTyping("Dict"), "[str, ", this.pythonType(mapType.values), "]"], enumType => this.namedType(enumType), unionType => {
            const [hasNull, nonNulls] = removeNullFromUnion(unionType);
            const memberTypes = Array.from(nonNulls).map(m => this.pythonType(m));
            if (hasNull !== null) {
                let rest = [];
                if (!this.getAlphabetizeProperties() && this.pyOptions.features.dataClasses && _isRootTypeDef) {
                    // Only push "= None" if this is a root level type def
                    //   otherwise we may get type defs like List[Optional[int] = None]
                    //   which are invalid
                    rest.push(" = None");
                }
                if (nonNulls.size > 1) {
                    this.withImport("typing", "Union");
                    return [
                        this.withTyping("Optional"),
                        "[Union[",
                        collectionUtils.arrayIntercalate(", ", memberTypes),
                        "]]",
                        ...rest
                    ];
                }
                else {
                    return [this.withTyping("Optional"), "[", defined(collectionUtils.iterableFirst(memberTypes)), "]", ...rest];
                }
            }
            else {
                return [this.withTyping("Union"), "[", collectionUtils.arrayIntercalate(", ", memberTypes), "]"];
            }
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return this.withImport("datetime", "datetime");
            }
            if (transformedStringType.kind === "uuid") {
                return this.withImport("uuid", "UUID");
            }
            return panic(`Transformed type ${transformedStringType.kind} not supported`);
        });
    }
    declarationLine(t) {
        if (t instanceof ClassType) {
            return ["class ", this.nameForNamedType(t), ":"];
        }
        if (t instanceof EnumType) {
            return ["class ", this.nameForNamedType(t), "(", this.withImport("enum", "Enum"), "):"];
        }
        return panic(`Can't declare type ${t.kind}`);
    }
    declareType(t, emitter) {
        this.emitBlock(this.declarationLine(t), () => {
            this.emitDescription(this.descriptionForType(t));
            emitter();
        });
        this.declaredTypes.add(t);
    }
    emitClassMembers(t) {
        if (this.pyOptions.features.dataClasses)
            return;
        const args = [];
        this.forEachClassProperty(t, "none", (name, _, cp) => {
            args.push([name, this.typeHint(": ", this.pythonType(cp.type))]);
        });
        this.emitBlock(["def __init__(self, ", collectionUtils.arrayIntercalate(", ", args), ")", this.typeHint(" -> None"), ":"], () => {
            if (args.length === 0) {
                this.emitLine("pass");
            }
            else {
                this.forEachClassProperty(t, "none", name => {
                    this.emitLine("self.", name, " = ", name);
                });
            }
        });
    }
    typeHint(...sl) {
        if (this.pyOptions.features.typeHints) {
            return sl;
        }
        return [];
    }
    typingDecl(name, type) {
        return [name, this.typeHint(": ", this.withTyping(type))];
    }
    typingReturn(type) {
        return this.typeHint(" -> ", this.withTyping(type));
    }
    sortClassProperties(properties, propertyNames) {
        if (this.pyOptions.features.dataClasses) {
            return collectionUtils.mapSortBy(properties, (p) => {
                return (p.type instanceof UnionType && nullableFromUnion(p.type) != null) || p.isOptional ? 1 : 0;
            });
        }
        else {
            return super.sortClassProperties(properties, propertyNames);
        }
    }
    emitClass(t) {
        if (this.pyOptions.features.dataClasses) {
            this.emitLine("@", this.withImport("dataclasses", "dataclass"));
        }
        this.declareType(t, () => {
            if (this.pyOptions.features.typeHints) {
                if (t.getProperties().size === 0) {
                    this.emitLine("pass");
                }
                else {
                    this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
                        this.emitLine(name, this.typeHint(": ", this.pythonType(cp.type, true)));
                        this.emitDescription(this.descriptionForClassProperty(t, jsonName));
                    });
                }
                this.ensureBlankLine();
            }
            this.emitClassMembers(t);
        });
    }
    emitEnum(t) {
        this.declareType(t, () => {
            this.forEachEnumCase(t, "none", (name, jsonName) => {
                this.emitLine([name, " = ", this.string(jsonName)]);
            });
        });
    }
    emitImports() {
        this.imports.forEach((names, module) => {
            this.emitLine("from ", module, " import ", Array.from(names).join(", "));
        });
    }
    emitSupportCode() {
        return;
    }
    emitClosingCode() {
        return;
    }
    emitSourceStructure(_givenOutputFilename) {
        const declarationLines = this.gatherSource(() => {
            this.forEachNamedType(["interposing", 2], (c) => this.emitClass(c), e => this.emitEnum(e), _u => {
                return;
            });
        });
        const closingLines = this.gatherSource(() => this.emitClosingCode());
        const supportLines = this.gatherSource(() => this.emitSupportCode());
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        this.ensureBlankLine();
        this.emitImports();
        this.ensureBlankLine(2);
        this.emitGatheredSource(supportLines);
        this.ensureBlankLine(2);
        this.emitGatheredSource(declarationLines);
        this.ensureBlankLine(2);
        this.emitGatheredSource(closingLines);
    }
}
function compose(input, f) {
    if (typeof f === "function") {
        if (input.value !== undefined) {
            // `input` is a value, so just apply `f` to its source form.
            return { value: f(makeValue$1(input)) };
        }
        if (input.lambda !== undefined) {
            // `input` is a lambda, so build `lambda x: f(input(x))`.
            return { lambda: multiWord(" ", "lambda x:", f([parenIfNeeded(input.lambda), "(x)"])), value: undefined };
        }
        // `input` is the identify function, so the composition is `lambda x: f(x)`.
        return { lambda: multiWord(" ", "lambda x:", f("x")), value: undefined };
    }
    if (f.value !== undefined) {
        return panic("Cannot compose into a value");
    }
    if (f.lambda === undefined) {
        // `f` is the identity function, so the result is just `input`.
        return input;
    }
    if (input.value === undefined) {
        // `input` is a lambda
        if (input.lambda === undefined) {
            // `input` is the identity function, so the result is just `f`.
            return f;
        }
        // `input` is a lambda, so the result is `lambda x: f(input(x))`.
        return {
            lambda: multiWord("", "lambda x: ", parenIfNeeded(f.lambda), "(", parenIfNeeded(input.lambda), "(x))"),
            value: undefined
        };
    }
    // `input` is a value, so return `f(input)`.
    return { lambda: f.lambda, value: makeValue$1(input) };
}
const identity = { value: undefined };
// If `vol` is a lambda, return it in its source form.  If it's
// a value, return a `lambda` that returns the value.
function makeLambda(vol) {
    if (vol.lambda !== undefined) {
        if (vol.value === undefined) {
            return vol.lambda;
        }
        return multiWord("", "lambda x: ", parenIfNeeded(vol.lambda), "(", vol.value, ")");
    }
    else if (vol.value !== undefined) {
        return multiWord(" ", "lambda x:", vol.value);
    }
    return multiWord(" ", "lambda x:", "x");
}
// If `vol` is a value, return the value in its source form.
// Calling this with `vol` being a lambda is not allowed.
function makeValue$1(vol) {
    if (vol.value === undefined) {
        return panic("Cannot make value from lambda without value");
    }
    if (vol.lambda !== undefined) {
        return [parenIfNeeded(vol.lambda), "(", vol.value, ")"];
    }
    return vol.value;
}
class JSONPythonRenderer extends PythonRenderer {
    constructor() {
        super(...arguments);
        this._deserializerFunctions = new Set();
        this._converterNamer = funPrefixNamer("converter", s => snakeNameStyle(s, false, this.pyOptions.nicePropertyNames));
        this._topLevelConverterNames = new Map();
        this._haveTypeVar = false;
        this._haveEnumTypeVar = false;
        this._haveDateutil = false;
    }
    emitTypeVar(tvar, constraints) {
        if (!this.pyOptions.features.typeHints) {
            return;
        }
        this.emitLine(tvar, " = ", this.withTyping("TypeVar"), "(", this.string(tvar), constraints, ")");
    }
    typeVar() {
        this._haveTypeVar = true;
        // FIXME: This is ugly, but the code that requires the type variables, in
        // `emitImports` actually runs after imports have been imported.  The proper
        // solution would be to either allow more complex dependencies, or to
        // gather-emit the type variable declarations, too.  Unfortunately the
        // gather-emit is a bit buggy with blank lines, and I can't be bothered to
        // fix it now.
        this.withTyping("TypeVar");
        return "T";
    }
    enumTypeVar() {
        this._haveEnumTypeVar = true;
        // See the comment above.
        this.withTyping("TypeVar");
        this.withImport("enum", "Enum");
        return "EnumT";
    }
    cast(type, v) {
        if (!this.pyOptions.features.typeHints) {
            return v;
        }
        return [this.withTyping("cast"), "(", type, ", ", v, ")"];
    }
    emitNoneConverter() {
        // FIXME: We can't return the None type here because mypy thinks that means
        // We're not returning any value, when we're actually returning `None`.
        this.emitBlock(["def from_none(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> ", this.withTyping("Any")), ":"], () => {
            this.emitLine("assert x is None");
            this.emitLine("return x");
        });
    }
    emitBoolConverter() {
        this.emitBlock(["def from_bool(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> bool"), ":"], () => {
            this.emitLine("assert isinstance(x, bool)");
            this.emitLine("return x");
        });
    }
    emitIntConverter() {
        this.emitBlock(["def from_int(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> int"), ":"], () => {
            this.emitLine("assert isinstance(x, int) and not isinstance(x, bool)");
            this.emitLine("return x");
        });
    }
    emitFromFloatConverter() {
        this.emitBlock(["def from_float(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> float"), ":"], () => {
            this.emitLine("assert isinstance(x, (float, int)) and not isinstance(x, bool)");
            this.emitLine("return float(x)");
        });
    }
    emitToFloatConverter() {
        this.emitBlock(["def to_float(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> float"), ":"], () => {
            this.emitLine("assert isinstance(x, (int, float))");
            this.emitLine("return x");
        });
    }
    emitStrConverter() {
        this.emitBlock(["def from_str(", this.typingDecl("x", "Any"), ")", this.typeHint(" -> str"), ":"], () => {
            const strType = "str";
            this.emitLine("assert isinstance(x, ", strType, ")");
            this.emitLine("return x");
        });
    }
    emitToEnumConverter() {
        const tvar = this.enumTypeVar();
        this.emitBlock([
            "def to_enum(c",
            this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
            ", ",
            this.typingDecl("x", "Any"),
            ")",
            this.typeHint(" -> ", tvar),
            ":"
        ], () => {
            this.emitLine("assert isinstance(x, c)");
            this.emitLine("return x.value");
        });
    }
    emitListConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
            "def from_list(f",
            this.typeHint(": ", this.withTyping("Callable"), "[[", this.withTyping("Any"), "], ", tvar, "]"),
            ", ",
            this.typingDecl("x", "Any"),
            ")",
            this.typeHint(" -> ", this.withTyping("List"), "[", tvar, "]"),
            ":"
        ], () => {
            this.emitLine("assert isinstance(x, list)");
            this.emitLine("return [f(y) for y in x]");
        });
    }
    emitToClassConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
            "def to_class(c",
            this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
            ", ",
            this.typingDecl("x", "Any"),
            ")",
            this.typeHint(" -> dict"),
            ":"
        ], () => {
            this.emitLine("assert isinstance(x, c)");
            this.emitLine("return ", this.cast(this.withTyping("Any"), "x"), ".to_dict()");
        });
    }
    emitDictConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
            "def from_dict(f",
            this.typeHint(": ", this.withTyping("Callable"), "[[", this.withTyping("Any"), "], ", tvar, "]"),
            ", ",
            this.typingDecl("x", "Any"),
            ")",
            this.typeHint(" -> ", this.withTyping("Dict"), "[str, ", tvar, "]"),
            ":"
        ], () => {
            this.emitLine("assert isinstance(x, dict)");
            this.emitLine("return { k: f(v) for (k, v) in x.items() }");
        });
    }
    // This is not easily idiomatically typeable in Python.  See
    // https://stackoverflow.com/questions/51066468/computed-types-in-mypy/51084497
    emitUnionConverter() {
        this.emitMultiline(`def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False`);
    }
    emitFromDatetimeConverter() {
        this.emitBlock([
            "def from_datetime(",
            this.typingDecl("x", "Any"),
            ")",
            this.typeHint(" -> ", this.withImport("datetime", "datetime")),
            ":"
        ], () => {
            this._haveDateutil = true;
            this.emitLine("return dateutil.parser.parse(x)");
        });
    }
    emitFromStringifiedBoolConverter() {
        this.emitBlock(["def from_stringified_bool(x", this.typeHint(": str"), ")", this.typeHint(" -> bool"), ":"], () => {
            this.emitBlock('if x == "true":', () => this.emitLine("return True"));
            this.emitBlock('if x == "false":', () => this.emitLine("return False"));
            this.emitLine("assert False");
        });
    }
    emitIsTypeConverter() {
        const tvar = this.typeVar();
        this.emitBlock([
            "def is_type(t",
            this.typeHint(": ", this.withTyping("Type"), "[", tvar, "]"),
            ", ",
            this.typingDecl("x", "Any"),
            ")",
            this.typeHint(" -> ", tvar),
            ":"
        ], () => {
            this.emitLine("assert isinstance(x, t)");
            this.emitLine("return x");
        });
    }
    emitConverter(cf) {
        switch (cf) {
            case "none": {
                this.emitNoneConverter();
                return;
            }
            case "bool": {
                this.emitBoolConverter();
                return;
            }
            case "int": {
                this.emitIntConverter();
                return;
            }
            case "from-float": {
                this.emitFromFloatConverter();
                return;
            }
            case "to-float": {
                this.emitToFloatConverter();
                return;
            }
            case "str": {
                this.emitStrConverter();
                return;
            }
            case "to-enum": {
                this.emitToEnumConverter();
                return;
            }
            case "list": {
                this.emitListConverter();
                return;
            }
            case "to-class": {
                this.emitToClassConverter();
                return;
            }
            case "dict": {
                this.emitDictConverter();
                return;
            }
            case "union": {
                this.emitUnionConverter();
                return;
            }
            case "from-datetime": {
                this.emitFromDatetimeConverter();
                return;
            }
            case "from-stringified-bool": {
                this.emitFromStringifiedBoolConverter();
                return;
            }
            case "is-type": {
                this.emitIsTypeConverter();
                return;
            }
            default:
                return assertNever(cf);
        }
    }
    // Return the name of the Python converter function `cf`.
    conv(cf) {
        this._deserializerFunctions.add(cf);
        const name = cf.replace(/-/g, "_");
        if (cf.startsWith("from-") || cf.startsWith("to-") || cf.startsWith("is-"))
            return name;
        return ["from_", name];
    }
    // Applies the converter function to `arg`
    convFn(cf, arg) {
        return compose(arg, { lambda: singleWord(this.conv(cf)), value: undefined });
    }
    typeObject(t) {
        const s = matchType(t, _anyType => undefined, _nullType => "type(None)", _boolType => "bool", _integerType => "int", _doubleType => "float", _stringType => "str", _arrayType => "List", classType => this.nameForNamedType(classType), _mapType => "dict", enumType => this.nameForNamedType(enumType), _unionType => undefined, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return this.withImport("datetime", "datetime");
            }
            if (transformedStringType.kind === "uuid") {
                return this.withImport("uuid", "UUID");
            }
            return undefined;
        });
        if (s === undefined) {
            return panic(`No type object for ${t.kind}`);
        }
        return s;
    }
    transformer(inputTransformer, xfer, targetType) {
        const consume = (consumer, vol) => {
            if (consumer === undefined) {
                return vol;
            }
            return this.transformer(vol, consumer, targetType);
        };
        const isType = (t, valueToCheck) => {
            return compose(valueToCheck, v => [this.conv("is-type"), "(", this.typeObject(t), ", ", v, ")"]);
        };
        if (xfer instanceof DecodingChoiceTransformer || xfer instanceof ChoiceTransformer) {
            const lambdas = xfer.transformers.map(x => makeLambda(this.transformer(identity, x, targetType)).source);
            return compose(inputTransformer, v => [
                this.conv("union"),
                "([",
                collectionUtils.arrayIntercalate(", ", lambdas),
                "], ",
                v,
                ")"
            ]);
        }
        else if (xfer instanceof DecodingTransformer) {
            const consumer = xfer.consumer;
            const vol = this.deserializer(inputTransformer, xfer.sourceType);
            return consume(consumer, vol);
        }
        else if (xfer instanceof EncodingTransformer) {
            return this.serializer(inputTransformer, xfer.sourceType);
        }
        else if (xfer instanceof UnionInstantiationTransformer) {
            return inputTransformer;
        }
        else if (xfer instanceof UnionMemberMatchTransformer) {
            const consumer = xfer.transformer;
            const vol = isType(xfer.memberType, inputTransformer);
            return consume(consumer, vol);
        }
        else if (xfer instanceof ParseStringTransformer) {
            const consumer = xfer.consumer;
            const immediateTargetType = consumer === undefined ? targetType : consumer.sourceType;
            let vol;
            switch (immediateTargetType.kind) {
                case "integer":
                    vol = compose(inputTransformer, v => ["int(", v, ")"]);
                    break;
                case "bool":
                    vol = this.convFn("from-stringified-bool", inputTransformer);
                    break;
                case "enum":
                    vol = this.deserializer(inputTransformer, immediateTargetType);
                    break;
                case "date-time":
                    vol = this.convFn("from-datetime", inputTransformer);
                    break;
                case "uuid":
                    vol = compose(inputTransformer, v => [this.withImport("uuid", "UUID"), "(", v, ")"]);
                    break;
                default:
                    return panic(`Parsing of ${immediateTargetType.kind} in a transformer is not supported`);
            }
            return consume(consumer, vol);
        }
        else if (xfer instanceof StringifyTransformer) {
            const consumer = xfer.consumer;
            let vol;
            switch (xfer.sourceType.kind) {
                case "integer":
                    vol = compose(inputTransformer, v => ["str(", v, ")"]);
                    break;
                case "bool":
                    vol = compose(inputTransformer, v => ["str(", v, ").lower()"]);
                    break;
                case "enum":
                    vol = this.serializer(inputTransformer, xfer.sourceType);
                    break;
                case "date-time":
                    vol = compose(inputTransformer, v => [v, ".isoformat()"]);
                    break;
                case "uuid":
                    vol = compose(inputTransformer, v => ["str(", v, ")"]);
                    break;
                default:
                    return panic(`Parsing of ${xfer.sourceType.kind} in a transformer is not supported`);
            }
            return consume(consumer, vol);
        }
        else {
            return panic(`Transformer ${xfer.kind} is not supported`);
        }
    }
    // Returns the code to deserialize `value` as type `t`.  If `t` has
    // an associated transformer, the code for that transformer is
    // returned.
    deserializer(value, t) {
        const xf = transformationForType(t);
        if (xf !== undefined) {
            return this.transformer(value, xf.transformer, xf.targetType);
        }
        return matchType(t, _anyType => value, _nullType => this.convFn("none", value), _boolType => this.convFn("bool", value), _integerType => this.convFn("int", value), _doubleType => this.convFn("from-float", value), _stringType => this.convFn("str", value), arrayType => compose(value, v => [
            this.conv("list"),
            "(",
            makeLambda(this.deserializer(identity, arrayType.items)).source,
            ", ",
            v,
            ")"
        ]), classType => compose(value, {
            lambda: singleWord(this.nameForNamedType(classType), ".from_dict"),
            value: undefined
        }), mapType => compose(value, v => [
            this.conv("dict"),
            "(",
            makeLambda(this.deserializer(identity, mapType.values)).source,
            ", ",
            v,
            ")"
        ]), enumType => compose(value, { lambda: singleWord(this.nameForNamedType(enumType)), value: undefined }), unionType => {
            // FIXME: handle via transformers
            const deserializers = Array.from(unionType.members).map(m => makeLambda(this.deserializer(identity, m)).source);
            return compose(value, v => [
                this.conv("union"),
                "([",
                collectionUtils.arrayIntercalate(", ", deserializers),
                "], ",
                v,
                ")"
            ]);
        }, transformedStringType => {
            // FIXME: handle via transformers
            if (transformedStringType.kind === "date-time") {
                return this.convFn("from-datetime", value);
            }
            if (transformedStringType.kind === "uuid") {
                return compose(value, v => [this.withImport("uuid", "UUID"), "(", v, ")"]);
            }
            return panic(`Transformed type ${transformedStringType.kind} not supported`);
        });
    }
    serializer(value, t) {
        const xf = transformationForType(t);
        if (xf !== undefined) {
            const reverse = xf.reverse;
            return this.transformer(value, reverse.transformer, reverse.targetType);
        }
        return matchType(t, _anyType => value, _nullType => this.convFn("none", value), _boolType => this.convFn("bool", value), _integerType => this.convFn("int", value), _doubleType => this.convFn("to-float", value), _stringType => this.convFn("str", value), arrayType => compose(value, v => [
            this.conv("list"),
            "(",
            makeLambda(this.serializer(identity, arrayType.items)).source,
            ", ",
            v,
            ")"
        ]), classType => compose(value, v => [this.conv("to-class"), "(", this.nameForNamedType(classType), ", ", v, ")"]), mapType => compose(value, v => [
            this.conv("dict"),
            "(",
            makeLambda(this.serializer(identity, mapType.values)).source,
            ", ",
            v,
            ")"
        ]), enumType => compose(value, v => [this.conv("to-enum"), "(", this.nameForNamedType(enumType), ", ", v, ")"]), unionType => {
            const serializers = Array.from(unionType.members).map(m => makeLambda(this.serializer(identity, m)).source);
            return compose(value, v => [
                this.conv("union"),
                "([",
                collectionUtils.arrayIntercalate(", ", serializers),
                "], ",
                v,
                ")"
            ]);
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return compose(value, v => [v, ".isoformat()"]);
            }
            if (transformedStringType.kind === "uuid") {
                return compose(value, v => ["str(", v, ")"]);
            }
            return panic(`Transformed type ${transformedStringType.kind} not supported`);
        });
    }
    emitClassMembers(t) {
        super.emitClassMembers(t);
        this.ensureBlankLine();
        const className = this.nameForNamedType(t);
        this.emitLine("@staticmethod");
        this.emitBlock(["def from_dict(", this.typingDecl("obj", "Any"), ")", this.typeHint(" -> ", this.namedType(t)), ":"], () => {
            const args = [];
            this.emitLine("assert isinstance(obj, dict)");
            this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
                const property = { value: ["obj.get(", this.string(jsonName), ")"] };
                this.emitLine(name, " = ", makeValue$1(this.deserializer(property, cp.type)));
                args.push(name);
            });
            this.emitLine("return ", className, "(", collectionUtils.arrayIntercalate(", ", args), ")");
        });
        this.ensureBlankLine();
        this.emitBlock(["def to_dict(self)", this.typeHint(" -> dict"), ":"], () => {
            this.emitLine("result", this.typeHint(": dict"), " = {}");
            this.forEachClassProperty(t, "none", (name, jsonName, cp) => {
                const property = { value: ["self.", name] };
                if (cp.isOptional) {
                    this.emitBlock(["if self.", name, " is not None:"], () => {
                        this.emitLine("result[", this.string(jsonName), "] = ", makeValue$1(this.serializer(property, cp.type)));
                    });
                }
                else {
                    this.emitLine("result[", this.string(jsonName), "] = ", makeValue$1(this.serializer(property, cp.type)));
                }
            });
            this.emitLine("return result");
        });
    }
    emitImports() {
        super.emitImports();
        if (this._haveDateutil) {
            this.emitLine("import dateutil.parser");
        }
        if (!this._haveTypeVar && !this._haveEnumTypeVar)
            return;
        this.ensureBlankLine(2);
        if (this._haveTypeVar) {
            this.emitTypeVar(this.typeVar(), []);
        }
        if (this._haveEnumTypeVar) {
            this.emitTypeVar(this.enumTypeVar(), [", bound=", this.withImport("enum", "Enum")]);
        }
    }
    emitSupportCode() {
        const map = Array.from(this._deserializerFunctions).map(f => [f, f]);
        this.forEachWithBlankLines(map, ["interposing", 2], cf => {
            this.emitConverter(cf);
        });
    }
    makeTopLevelDependencyNames(_t, topLevelName) {
        const fromDict = new DependencyName(this._converterNamer, topLevelNameOrder, l => `${l(topLevelName)}_from_dict`);
        const toDict = new DependencyName(this._converterNamer, topLevelNameOrder, l => `${l(topLevelName)}_to_dict`);
        this._topLevelConverterNames.set(topLevelName, { fromDict, toDict });
        return [fromDict, toDict];
    }
    emitDefaultLeadingComments() {
        this.ensureBlankLine();
        if (this._haveDateutil) {
            this.emitCommentLines([
                "This code parses date/times, so please",
                "",
                "    pip install python-dateutil",
                ""
            ]);
        }
        this.emitCommentLines([
            "To use this code, make sure you",
            "",
            "    import json",
            "",
            "and then, to convert JSON from a string, do",
            ""
        ]);
        this.forEachTopLevel("none", (_, name) => {
            const { fromDict } = defined(this._topLevelConverterNames.get(name));
            this.emitLine(this.commentLineStart, "    result = ", fromDict, "(json.loads(json_string))");
        });
    }
    emitClosingCode() {
        this.forEachTopLevel(["interposing", 2], (t, name) => {
            const { fromDict, toDict } = defined(this._topLevelConverterNames.get(name));
            const pythonType = this.pythonType(t);
            this.emitBlock(["def ", fromDict, "(", this.typingDecl("s", "Any"), ")", this.typeHint(" -> ", pythonType), ":"], () => {
                this.emitLine("return ", makeValue$1(this.deserializer({ value: "s" }, t)));
            });
            this.ensureBlankLine(2);
            this.emitBlock(["def ", toDict, "(x", this.typeHint(": ", pythonType), ")", this.typingReturn("Any"), ":"], () => {
                this.emitLine("return ", makeValue$1(this.serializer({ value: "x" }, t)));
            });
        });
    }
}

const keywords$4 = [
    "__ENCODING__",
    "__FILE__",
    "__LINE__",
    "alias",
    "and",
    "begin",
    "BEGIN",
    "break",
    "case",
    "class",
    "def",
    "defined?",
    "do",
    "else",
    "elsif",
    "end",
    "END",
    "ensure",
    "false",
    "for",
    "if",
    "in",
    "module",
    "next",
    "nil",
    "not",
    "or",
    "redo",
    "rescue",
    "retry",
    "return",
    "self",
    "super",
    "then",
    "true",
    "undef",
    "unless",
    "until",
    "when",
    "while",
    "yield",
];
const globalClasses = [
    "ArgumentError",
    "Array",
    "BasicObject",
    "Class",
    "ClosedQueueError",
    "Comparable",
    "Complex",
    "ConditionVariable",
    "Continuation",
    "Data",
    "Date",
    "Dir",
    "ENV",
    "EOFError",
    "Encoding",
    "EncodingError",
    "Enumerable",
    "Enumerator",
    "Errno",
    "Exception",
    "FalseClass",
    "Fiber",
    "FiberError",
    "File",
    "FileTest",
    "Float",
    "FloatDomainError",
    "FrozenError",
    "GC",
    "Hash",
    "IO",
    "IOError",
    "IndexError",
    "Integer",
    "Interrupt",
    "KeyError",
    "LoadError",
    "LocalJumpError",
    "Marshal",
    "MatchData",
    "Math",
    "Method",
    "Module",
    "Mutex",
    "NameError",
    "NilClass",
    "NoMemoryError",
    "NoMethodError",
    "NotImplementedError",
    "Numeric",
    "Object",
    "ObjectSpace",
    "Proc",
    "Process",
    "Queue",
    "Random",
    "Range",
    "RangeError",
    "Rational",
    "Regexp",
    "RegexpError",
    "RubyVM",
    "RuntimeError",
    "ScriptError",
    "SecurityError",
    "Set",
    "Signal",
    "SignalException",
    "SizedQueue",
    "StandardError",
    "StopIteration",
    "String",
    "Struct",
    "Symbol",
    "SyntaxError",
    "SystemCallError",
    "SystemExit",
    "SystemStackError",
    "Thread",
    "ThreadError",
    "ThreadGroup",
    "Time",
    "TracePoint",
    "TrueClass",
    "TypeError",
    "UnboundMethod",
    "UncaughtThrowError",
    "Undefined",
    "UnicodeNormalize",
    "Warning",
    "ZeroDivisionError",
];
const kernel = [
    "__callee__",
    "__dir__",
    "__id__",
    "__method__",
    "__send__",
    "!",
    "!=",
    "!~",
    "<",
    "<=",
    "<=>",
    "==",
    "===",
    "=~",
    ">",
    ">=",
    "abort",
    "ancestors",
    "at_exit",
    "autoload",
    "autoload?",
    "binding",
    "block_given?",
    "caller",
    "caller_locations",
    "catch",
    "class",
    "class_eval",
    "class_exec",
    "class_variable_defined?",
    "class_variable_get",
    "class_variable_set",
    "class_variables",
    "clone",
    "const_defined?",
    "const_get",
    "const_missing",
    "const_set",
    "constants",
    "define_singleton_method",
    "deprecate_constant",
    "display",
    "dup",
    "enum_for",
    "eql?",
    "equal?",
    "eval",
    "exec",
    "exit",
    "exit!",
    "extend",
    "fail",
    "fork",
    "format",
    "freeze",
    "frozen?",
    "gets",
    "global_variables",
    "hash",
    "include",
    "include?",
    "included_modules",
    "inspect",
    "instance_eval",
    "instance_exec",
    "instance_method",
    "instance_methods",
    "instance_of?",
    "instance_variable_defined?",
    "instance_variable_get",
    "instance_variable_set",
    "instance_variables",
    "is_a?",
    "iterator?",
    "itself",
    "kind_of?",
    "lambda",
    "load",
    "local_variables",
    "loop",
    "method",
    "method_defined?",
    "methods",
    "module_eval",
    "module_exec",
    "name",
    "new",
    "nil?",
    "object_id",
    "open",
    "p",
    "prepend",
    "print",
    "printf",
    "private_class_method",
    "private_constant",
    "private_instance_methods",
    "private_method_defined?",
    "private_methods",
    "proc",
    "protected_instance_methods",
    "protected_method_defined?",
    "protected_methods",
    "public_class_method",
    "public_constant",
    "public_instance_method",
    "public_instance_methods",
    "public_method",
    "public_method_defined?",
    "public_methods",
    "public_send",
    "putc",
    "puts",
    "raise",
    "rand",
    "readline",
    "readlines",
    "remove_class_variable",
    "remove_instance_variable",
    "require",
    "require_relative",
    "respond_to?",
    "select",
    "send",
    "set_trace_func",
    "singleton_class",
    "singleton_class?",
    "singleton_method",
    "singleton_methods",
    "sleep",
    "spawn",
    "sprintf",
    "srand",
    "syscall",
    "system",
    "taint",
    "tainted?",
    "tap",
    "test",
    "throw",
    "to_enum",
    "to_s",
    "trace_var",
    "trap",
    "trust",
    "untaint",
    "untrace_var",
    "untrust",
    "untrusted?",
    "warn",
];
const globals = kernel.concat(globalClasses);
const reservedProperties = [
    "__id__",
    "__send__",
    "break",
    "call",
    "case",
    "class",
    "clone",
    "constrained_type",
    "constrained?",
    "constrained",
    "constructor",
    "default",
    "define_singleton_method",
    "display",
    "dup",
    "enum_for",
    "enum",
    "extend",
    "freeze",
    "gem",
    "hash",
    "inspect",
    "instance_eval",
    "instance_exec",
    "instance_variable_defined?",
    "instance_variable_get",
    "instance_variable_set",
    "instance_variables",
    "itself",
    "meta",
    "method",
    "methods",
    "next",
    "object_id",
    "optional",
    "options",
    "pristine",
    "private_methods",
    "protected_methods",
    "public_method",
    "public_methods",
    "public_send",
    "remove_instance_variable",
    "rule",
    "safe",
    "self",
    "send",
    "singleton_class",
    "singleton_method",
    "singleton_methods",
    "taint",
    "tap",
    "to_ast",
    "to_enum",
    "to_json",
    "to_s",
    "trust",
    "try",
    "type",
    "untaint",
    "undef",
    "untrust",
    "while",
    "with",
];

const forbiddenForObjectProperties = Array.from(new Set([...keywords$4, ...reservedProperties]));
function unicodeEscape$1(codePoint) {
    return "\\u{" + intToHex(codePoint, 0) + "}";
}
const stringEscape$1 = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, unicodeEscape$1));
var Strictness;
(function (Strictness) {
    Strictness["Coercible"] = "Coercible::";
    Strictness["None"] = "Types::";
    Strictness["Strict"] = "Strict::";
})(Strictness || (Strictness = {}));
const rubyOptions = {
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    strictness: new EnumOption("strictness", "Type strictness", [
        ["strict", Strictness.Strict],
        ["coercible", Strictness.Coercible],
        ["none", Strictness.None]
    ]),
    namespace: new StringOption("namespace", "Specify a wrapping Namespace", "NAME", "", "secondary")
};
class RubyTargetLanguage extends TargetLanguage {
    constructor() {
        super("Ruby", ["ruby"], "rb");
    }
    getOptions() {
        return [rubyOptions.justTypes, rubyOptions.strictness, rubyOptions.namespace];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get defaultIndentation() {
        return "  ";
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new RubyRenderer(this, renderContext, getOptionValues(rubyOptions, untypedOptionValues));
    }
}
const isStartCharacter$3 = isLetterOrUnderscore;
function isPartCharacter$3(utf16Unit) {
    const category = $747425b437e121da$export$410364bbb673ddbc(utf16Unit);
    return ["Nd", "Pc", "Mn", "Mc"].includes(category) || isStartCharacter$3(utf16Unit);
}
const legalizeName$4 = legalizeCharacters(isPartCharacter$3);
function simpleNameStyle(original, uppercase) {
    if (/^[0-9]+$/.test(original)) {
        original = original + "N";
    }
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$4, firstUpperWordStyle , firstUpperWordStyle , allUpperWordStyle, allUpperWordStyle, "", isStartCharacter$3);
}
function memberNameStyle(original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$4, allLowerWordStyle, allLowerWordStyle, allLowerWordStyle, allLowerWordStyle, "_", isStartCharacter$3);
}
class RubyRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
    }
    get commentLineStart() {
        return "# ";
    }
    get needsTypeDeclarationBeforeUse() {
        return true;
    }
    canBeForwardDeclared(t) {
        return "class" === t.kind;
    }
    forbiddenNamesForGlobalNamespace() {
        return globals.concat(["Types", "JSON", "Dry", "Constructor", "Self"]);
    }
    forbiddenForObjectProperties(_c, _classNamed) {
        return { names: forbiddenForObjectProperties, includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return new Namer("types", n => simpleNameStyle(n), []);
    }
    namerForObjectProperty() {
        return new Namer("properties", memberNameStyle, []);
    }
    makeUnionMemberNamer() {
        return new Namer("properties", memberNameStyle, []);
    }
    makeEnumCaseNamer() {
        return new Namer("enum-cases", n => simpleNameStyle(n), []);
    }
    dryType(t, isOptional = false) {
        const optional = isOptional ? ".optional" : "";
        return matchType(t, _anyType => ["Types::Any", optional], _nullType => ["Types::Nil", optional], _boolType => ["Types::Bool", optional], _integerType => ["Types::Integer", optional], _doubleType => ["Types::Double", optional], _stringType => ["Types::String", optional], arrayType => ["Types.Array(", this.dryType(arrayType.items), ")", optional], classType => [this.nameForNamedType(classType), optional], mapType => ["Types::Hash.meta(of: ", this.dryType(mapType.values), ")", optional], enumType => ["Types::", this.nameForNamedType(enumType), optional], unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return [this.dryType(nullable), ".optional"];
            }
            return ["Types.Instance(", this.nameForNamedType(unionType), ")", optional];
        });
    }
    exampleUse(t, exp, depth = 6, optional = false) {
        if (depth-- <= 0) {
            return exp;
        }
        const safeNav = optional ? "&" : "";
        return matchType(t, _anyType => exp, _nullType => [exp, ".nil?"], _boolType => exp, _integerType => [exp, ".even?"], _doubleType => exp, _stringType => exp, arrayType => this.exampleUse(arrayType.items, [exp, safeNav, ".first"], depth), classType => {
            let info;
            this.forEachClassProperty(classType, "none", (name, _json, prop) => {
                if (["class", "map", "array"].includes(prop.type.kind)) {
                    info = { name, prop };
                }
                else if (info === undefined) {
                    info = { name, prop };
                }
            });
            if (info !== undefined) {
                return this.exampleUse(info.prop.type, [exp, safeNav, ".", info.name], depth, info.prop.isOptional);
            }
            return exp;
        }, mapType => this.exampleUse(mapType.values, [exp, safeNav, '["…"]'], depth), enumType => {
            let name;
            // FIXME: This is a terrible way to get the first enum case name.
            this.forEachEnumCase(enumType, "none", theName => {
                if (name === undefined) {
                    name = theName;
                }
            });
            if (name !== undefined) {
                return [exp, " == ", this.nameForNamedType(enumType), "::", name];
            }
            return exp;
        }, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                if (["class", "map", "array"].includes(nullable.kind)) {
                    return this.exampleUse(nullable, exp, depth, true);
                }
                return [exp, ".nil?"];
            }
            return exp;
        });
    }
    jsonSample(t) {
        function inner() {
            if (t instanceof ArrayType) {
                return "[…]";
            }
            else if (t instanceof MapType) {
                return "{…}";
            }
            else if (t instanceof ClassType) {
                return "{…}";
            }
            else {
                return "…";
            }
        }
        return `"${inner()}"`;
    }
    fromDynamic(t, e, optional = false, castPrimitives = false) {
        const primitiveCast = [this.dryType(t, optional), "[", e, "]"];
        const primitive = castPrimitives ? primitiveCast : e;
        const safeAccess = optional ? "&" : "";
        return matchType(t, _anyType => primitive, _nullType => primitive, _boolType => primitive, _integerType => primitive, _doubleType => primitive, _stringType => primitive, arrayType => [e, safeAccess, ".map { |x| ", this.fromDynamic(arrayType.items, "x", false, true), " }"], classType => {
            const expression = [this.nameForNamedType(classType), ".from_dynamic!(", e, ")"];
            return optional ? [e, " ? ", expression, " : nil"] : expression;
        }, mapType => [
            ["Types::Hash", optional ? ".optional" : "", "[", e, "]"],
            safeAccess,
            ".map { |k, v| [k, ",
            this.fromDynamic(mapType.values, "v", false, true),
            "] }",
            safeAccess,
            ".to_h"
        ], enumType => {
            const expression = ["Types::", this.nameForNamedType(enumType), "[", e, "]"];
            return optional ? [e, ".nil? ? nil : ", expression] : expression;
        }, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return this.fromDynamic(nullable, e, true);
            }
            const expression = [this.nameForNamedType(unionType), ".from_dynamic!(", e, ")"];
            return optional ? [e, " ? ", expression, " : nil"] : expression;
        });
    }
    toDynamic(t, e, optional = false) {
        if (this.marshalsImplicitlyToDynamic(t)) {
            return e;
        }
        return matchType(t, _anyType => e, _nullType => e, _boolType => e, _integerType => e, _doubleType => e, _stringType => e, arrayType => [e, optional ? "&" : "", ".map { |x| ", this.toDynamic(arrayType.items, "x"), " }"], _classType => [e, optional ? "&" : "", ".to_dynamic"], mapType => [e, optional ? "&" : "", ".map { |k, v| [k, ", this.toDynamic(mapType.values, "v"), "] }.to_h"], _enumType => e, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return this.toDynamic(nullable, e, true);
            }
            if (this.marshalsImplicitlyToDynamic(unionType)) {
                return e;
            }
            return [e, optional ? "&" : "", ".to_dynamic"];
        });
    }
    marshalsImplicitlyToDynamic(t) {
        return matchType(t, _anyType => true, _nullType => true, _boolType => true, _integerType => true, _doubleType => true, _stringType => true, arrayType => this.marshalsImplicitlyToDynamic(arrayType.items), _classType => false, mapType => this.marshalsImplicitlyToDynamic(mapType.values), _enumType => true, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return this.marshalsImplicitlyToDynamic(nullable);
            }
            return false;
        });
    }
    // This is only to be used to allow class properties to possibly
    // marshal implicitly. They are allowed to do this because they will
    // be checked in Dry::Struct.new
    propertyTypeMarshalsImplicitlyFromDynamic(t) {
        return matchType(t, _anyType => true, _nullType => true, _boolType => true, _integerType => true, _doubleType => true, _stringType => true, arrayType => this.propertyTypeMarshalsImplicitlyFromDynamic(arrayType.items), _classType => false, 
        // Map properties must be checked because Dry:Types doesn't have a generic Map
        _mapType => false, _enumType => true, unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return this.propertyTypeMarshalsImplicitlyFromDynamic(nullable);
            }
            return false;
        });
    }
    emitBlock(source, emit) {
        this.emitLine(source);
        this.indent(emit);
        this.emitLine("end");
    }
    emitModule(emit) {
        const emitModuleInner = (moduleName) => {
            const [firstModule, ...subModules] = moduleName.split("::");
            if (subModules.length > 0) {
                this.emitBlock(["module ", firstModule], () => {
                    emitModuleInner(subModules.join("::"));
                });
            }
            else {
                this.emitBlock(["module ", moduleName], emit);
            }
        };
        if (this._options.namespace !== undefined && this._options.namespace !== "") {
            emitModuleInner(this._options.namespace);
        }
        else {
            emit();
        }
    }
    emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitBlock(["class ", className, " < Dry::Struct"], () => {
            let table = [];
            let count = c.getProperties().size;
            this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                const last = --count === 0;
                const description = this.descriptionForClassProperty(c, jsonName);
                const attribute = [
                    ["attribute :", name, ","],
                    [" ", this.dryType(p.type), p.isOptional ? ".optional" : ""]
                ];
                if (description !== undefined) {
                    if (table.length > 0) {
                        this.emitTable(table);
                        table = [];
                    }
                    this.ensureBlankLine();
                    this.emitDescriptionBlock(description);
                    this.emitLine(attribute);
                    if (!last) {
                        this.ensureBlankLine();
                    }
                }
                else {
                    table.push(attribute);
                }
            });
            if (table.length > 0) {
                this.emitTable(table);
            }
            if (this._options.justTypes) {
                return;
            }
            this.ensureBlankLine();
            this.emitBlock(["def self.from_dynamic!(d)"], () => {
                this.emitLine("d = Types::Hash[d]");
                this.emitLine("new(");
                this.indent(() => {
                    const inits = [];
                    this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                        const dynamic = p.isOptional
                            ? // If key is not found in hash, this will be nil
                                `d["${stringEscape$1(jsonName)}"]`
                            : // This will raise a runtime error if the key is not found in the hash
                                `d.fetch("${stringEscape$1(jsonName)}")`;
                        if (this.propertyTypeMarshalsImplicitlyFromDynamic(p.type)) {
                            inits.push([
                                [name, ": "],
                                [dynamic, ","]
                            ]);
                        }
                        else {
                            const expression = this.fromDynamic(p.type, dynamic, p.isOptional);
                            inits.push([
                                [name, ": "],
                                [expression, ","]
                            ]);
                        }
                    });
                    this.emitTable(inits);
                });
                this.emitLine(")");
            });
            this.ensureBlankLine();
            this.emitBlock("def self.from_json!(json)", () => {
                this.emitLine("from_dynamic!(JSON.parse(json))");
            });
            this.ensureBlankLine();
            this.emitBlock(["def to_dynamic"], () => {
                this.emitLine("{");
                this.indent(() => {
                    const inits = [];
                    this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                        const expression = this.toDynamic(p.type, name, p.isOptional);
                        inits.push([[`"${stringEscape$1(jsonName)}"`], [" => ", expression, ","]]);
                    });
                    this.emitTable(inits);
                });
                this.emitLine("}");
            });
            this.ensureBlankLine();
            this.emitBlock("def to_json(options = nil)", () => {
                this.emitLine("JSON.generate(to_dynamic, options)");
            });
        });
    }
    emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["module ", enumName], () => {
            const table = [];
            this.forEachEnumCase(e, "none", (name, json) => {
                table.push([[name], [` = "${stringEscape$1(json)}"`]]);
            });
            this.emitTable(table);
        });
    }
    emitUnion(u, unionName) {
        this.emitDescription(this.descriptionForType(u));
        this.emitBlock(["class ", unionName, " < Dry::Struct"], () => {
            const table = [];
            this.forEachUnionMember(u, u.getChildren(), "none", null, (name, t) => {
                table.push([["attribute :", name, ", "], [this.dryType(t, true)]]);
            });
            this.emitTable(table);
            if (this._options.justTypes) {
                return;
            }
            this.ensureBlankLine();
            const [maybeNull, nonNulls] = removeNullFromUnion(u, false);
            this.emitBlock("def self.from_dynamic!(d)", () => {
                const memberNames = Array.from(u.getChildren()).map(member => this.nameForUnionMember(u, member));
                this.forEachUnionMember(u, u.getChildren(), "none", null, (name, t) => {
                    const nilMembers = memberNames
                        .filter(n => n !== name)
                        .map(memberName => [", ", memberName, ": nil"]);
                    if (this.propertyTypeMarshalsImplicitlyFromDynamic(t)) {
                        this.emitBlock(["if schema[:", name, "].right.valid? d"], () => {
                            this.emitLine("return new(", name, ": d", nilMembers, ")");
                        });
                    }
                    else {
                        this.emitLine("begin");
                        this.indent(() => {
                            this.emitLine("value = ", this.fromDynamic(t, "d"));
                            this.emitBlock(["if schema[:", name, "].right.valid? value"], () => {
                                this.emitLine("return new(", name, ": value", nilMembers, ")");
                            });
                        });
                        this.emitLine("rescue");
                        this.emitLine("end");
                    }
                });
                this.emitLine('raise "Invalid union"');
            });
            this.ensureBlankLine();
            this.emitBlock("def self.from_json!(json)", () => {
                this.emitLine("from_dynamic!(JSON.parse(json))");
            });
            this.ensureBlankLine();
            this.emitBlock("def to_dynamic", () => {
                let first = true;
                this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                    this.emitLine(first ? "if" : "elsif", " ", name, " != nil");
                    this.indent(() => {
                        this.emitLine(this.toDynamic(t, name));
                    });
                    first = false;
                });
                if (maybeNull !== null) {
                    this.emitLine("else");
                    this.indent(() => {
                        this.emitLine("nil");
                    });
                }
                this.emitLine("end");
            });
            this.ensureBlankLine();
            this.emitBlock("def to_json(options = nil)", () => {
                this.emitLine("JSON.generate(to_dynamic, options)");
            });
        });
    }
    emitTypesModule() {
        this.emitBlock(["module Types"], () => {
            this.emitLine("include Dry.Types(default: :nominal)");
            const declarations = [];
            if (this._options.strictness !== Strictness.None) {
                let has = { int: false, nil: false, bool: false, hash: false, string: false, double: false };
                this.forEachType(t => {
                    has = {
                        int: has.int || t.kind === "integer",
                        nil: has.nil || t.kind === "null",
                        bool: has.bool || t.kind === "bool",
                        hash: has.hash || t.kind === "map" || t.kind === "class",
                        string: has.string || t.kind === "string" || t.kind === "enum",
                        double: has.double || t.kind === "double"
                    };
                });
                if (has.int)
                    declarations.push([["Integer"], [` = ${this._options.strictness}Integer`]]);
                if (this._options.strictness === Strictness.Strict) {
                    if (has.nil)
                        declarations.push([["Nil"], [` = ${this._options.strictness}Nil`]]);
                }
                if (has.bool)
                    declarations.push([["Bool"], [` = ${this._options.strictness}Bool`]]);
                if (has.hash)
                    declarations.push([["Hash"], [` = ${this._options.strictness}Hash`]]);
                if (has.string)
                    declarations.push([["String"], [` = ${this._options.strictness}String`]]);
                if (has.double)
                    declarations.push([
                        ["Double"],
                        [` = ${this._options.strictness}Float | ${this._options.strictness}Integer`]
                    ]);
            }
            this.forEachEnum("none", (enumType, enumName) => {
                const cases = [];
                this.forEachEnumCase(enumType, "none", (_name, json) => {
                    cases.push([cases.length === 0 ? "" : ", ", `"${stringEscape$1(json)}"`]);
                });
                declarations.push([[enumName], [" = ", this._options.strictness, "String.enum(", ...cases, ")"]]);
            });
            if (declarations.length > 0) {
                this.ensureBlankLine();
                this.emitTable(declarations);
            }
        });
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else if (!this._options.justTypes) {
            this.emitLine("# This code may look unusually verbose for Ruby (and it is), but");
            this.emitLine("# it performs some subtle and complex validation of JSON data.");
            this.emitLine("#");
            this.emitLine("# To parse this JSON, add 'dry-struct' and 'dry-types' gems, then do:");
            this.emitLine("#");
            this.forEachTopLevel("none", (topLevel, name) => {
                const variable = modifySource(snakeCase, name);
                this.emitLine("#   ", variable, " = ", name, ".from_json! ", this.jsonSample(topLevel));
                this.emitLine("#   puts ", this.exampleUse(topLevel, variable));
                this.emitLine("#");
            });
            this.emitLine("# If from_json! succeeds, the value returned matches the schema.");
        }
        this.ensureBlankLine();
        this.emitLine("require 'json'");
        this.emitLine("require 'dry-types'");
        this.emitLine("require 'dry-struct'");
        this.ensureBlankLine();
        this.emitModule(() => {
            this.emitTypesModule();
            this.forEachDeclaration("leading-and-interposing", decl => {
                if (decl.kind === "forward") {
                    this.emitCommentLines(["(forward declaration)"]);
                    this.emitModule(() => {
                        this.emitLine("class ", this.nameForNamedType(decl.type), " < Dry::Struct; end");
                    });
                }
            });
            this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClass(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
            if (!this._options.justTypes) {
                this.forEachTopLevel("leading-and-interposing", (topLevel, name) => {
                    const self = modifySource(snakeCase, name);
                    // The json gem defines to_json on maps and primitives, so we only need to supply
                    // it for arrays.
                    const needsToJsonDefined = "array" === topLevel.kind;
                    const classDeclaration = () => {
                        this.emitBlock(["class ", name], () => {
                            this.emitBlock(["def self.from_json!(json)"], () => {
                                if (needsToJsonDefined) {
                                    this.emitLine(self, " = ", this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                                    this.emitBlock([self, ".define_singleton_method(:to_json) do"], () => {
                                        this.emitLine("JSON.generate(", this.toDynamic(topLevel, "self"), ")");
                                    });
                                    this.emitLine(self);
                                }
                                else {
                                    this.emitLine(this.fromDynamic(topLevel, "JSON.parse(json, quirks_mode: true)"));
                                }
                            });
                        });
                    };
                    this.emitModule(() => {
                        classDeclaration();
                    });
                }, t => this.namedTypeToNameForTopLevel(t) === undefined);
            }
        });
    }
}

/* eslint-disable @typescript-eslint/naming-convention */
var Density;
(function (Density) {
    Density["Normal"] = "Normal";
    Density["Dense"] = "Dense";
})(Density || (Density = {}));
var Visibility;
(function (Visibility) {
    Visibility["Private"] = "Private";
    Visibility["Crate"] = "Crate";
    Visibility["Public"] = "Public";
})(Visibility || (Visibility = {}));
const rustOptions = {
    density: new EnumOption("density", "Density", [
        ["normal", Density.Normal],
        ["dense", Density.Dense]
    ]),
    visibility: new EnumOption("visibility", "Field visibility", [
        ["private", Visibility.Private],
        ["crate", Visibility.Crate],
        ["public", Visibility.Public]
    ]),
    deriveDebug: new BooleanOption("derive-debug", "Derive Debug impl", false),
    deriveClone: new BooleanOption("derive-clone", "Derive Clone impl", false),
    derivePartialEq: new BooleanOption("derive-partial-eq", "Derive PartialEq impl", false),
    skipSerializingNone: new BooleanOption("skip-serializing-none", "Skip serializing empty Option fields", false),
    edition2018: new BooleanOption("edition-2018", "Edition 2018", true),
    leadingComments: new BooleanOption("leading-comments", "Leading Comments", true)
};
const namingStyles = {
    snake_case: {
        regex: /^[a-z][a-z0-9]*(_[a-z0-9]+)*$/,
        toParts: (name) => name.split("_"),
        fromParts: (parts) => parts.map(p => p.toLowerCase()).join("_")
    },
    SCREAMING_SNAKE_CASE: {
        regex: /^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$/,
        toParts: (name) => name.split("_"),
        fromParts: (parts) => parts.map(p => p.toUpperCase()).join("_")
    },
    camelCase: {
        regex: /^[a-z]+([A-Z0-9][a-z]*)*$/,
        toParts: (name) => namingStyles.snake_case.toParts(name.replace(/(.)([A-Z])/g, "$1_$2")),
        fromParts: (parts) => parts
            .map((p, i) => i === 0 ? p.toLowerCase() : p.substring(0, 1).toUpperCase() + p.substring(1).toLowerCase())
            .join("")
    },
    PascalCase: {
        regex: /^[A-Z][a-z]*([A-Z0-9][a-z]*)*$/,
        toParts: (name) => namingStyles.snake_case.toParts(name.replace(/(.)([A-Z])/g, "$1_$2")),
        fromParts: (parts) => parts.map(p => p.substring(0, 1).toUpperCase() + p.substring(1).toLowerCase()).join("")
    },
    "kebab-case": {
        regex: /^[a-z][a-z0-9]*(-[a-z0-9]+)*$/,
        toParts: (name) => name.split("-"),
        fromParts: (parts) => parts.map(p => p.toLowerCase()).join("-")
    },
    "SCREAMING-KEBAB-CASE": {
        regex: /^[A-Z][A-Z0-9]*(-[A-Z0-9]+)*$/,
        toParts: (name) => name.split("-"),
        fromParts: (parts) => parts.map(p => p.toUpperCase()).join("-")
    },
    lowercase: {
        regex: /^[a-z][a-z0-9]*$/,
        toParts: (name) => [name],
        fromParts: (parts) => parts.map(p => p.toLowerCase()).join("")
    },
    UPPERCASE: {
        regex: /^[A-Z][A-Z0-9]*$/,
        toParts: (name) => [name],
        fromParts: (parts) => parts.map(p => p.toUpperCase()).join("")
    }
};
class RustTargetLanguage extends TargetLanguage {
    makeRenderer(renderContext, untypedOptionValues) {
        return new RustRenderer(this, renderContext, getOptionValues(rustOptions, untypedOptionValues));
    }
    constructor() {
        super("Rust", ["rust", "rs", "rustlang"], "rs");
    }
    getOptions() {
        return [
            rustOptions.density,
            rustOptions.visibility,
            rustOptions.deriveDebug,
            rustOptions.deriveClone,
            rustOptions.derivePartialEq,
            rustOptions.edition2018,
            rustOptions.leadingComments,
            rustOptions.skipSerializingNone
        ];
    }
}
const keywords$3 = [
    "Serialize",
    "Deserialize",
    // Special reserved identifiers used internally for elided lifetimes,
    // unnamed method parameters, crate root module, error recovery etc.
    "{{root}}",
    "$crate",
    // Keywords used in the language.
    "as",
    "async",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "type",
    "unsafe",
    "use",
    "where",
    "while",
    // Keywords reserved for future use.
    "abstract",
    "alignof",
    "become",
    "do",
    "final",
    "macro",
    "offsetof",
    "override",
    "priv",
    "proc",
    "pure",
    "sizeof",
    "typeof",
    "unsized",
    "virtual",
    "yield",
    // Weak keywords, have special meaning only in specific contexts.
    "catch",
    "default",
    "dyn",
    "'static",
    "union",
    // Conflict between `std::Option` and potentially generated Option
    "option"
];
const isAsciiLetterOrUnderscoreOrDigit = (codePoint) => {
    if (!isAscii(codePoint)) {
        return false;
    }
    return isLetterOrUnderscoreOrDigit(codePoint);
};
const isAsciiLetterOrUnderscore = (codePoint) => {
    if (!isAscii(codePoint)) {
        return false;
    }
    return isLetterOrUnderscore(codePoint);
};
const legalizeName$3 = legalizeCharacters(isAsciiLetterOrUnderscoreOrDigit);
function rustStyle(original, isSnakeCase) {
    const words = splitIntoWords(original);
    const wordStyle = isSnakeCase ? allLowerWordStyle : firstUpperWordStyle;
    const combined = combineWords(words, legalizeName$3, wordStyle, wordStyle, wordStyle, wordStyle, isSnakeCase ? "_" : "", isAsciiLetterOrUnderscore);
    return combined === "_" ? "_underscore" : combined;
}
const snakeNamingFunction = funPrefixNamer("default", (original) => rustStyle(original, true));
const camelNamingFunction = funPrefixNamer("camel", (original) => rustStyle(original, false));
const standardUnicodeRustEscape = (codePoint) => {
    if (codePoint <= 0xffff) {
        return "\\u{" + intToHex(codePoint, 4) + "}";
    }
    else {
        return "\\u{" + intToHex(codePoint, 6) + "}";
    }
};
const rustStringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, standardUnicodeRustEscape));
class RustRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
    }
    makeNamedTypeNamer() {
        return camelNamingFunction;
    }
    namerForObjectProperty() {
        return snakeNamingFunction;
    }
    makeUnionMemberNamer() {
        return camelNamingFunction;
    }
    makeEnumCaseNamer() {
        return camelNamingFunction;
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$3;
    }
    forbiddenForObjectProperties(_c, _className) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    get commentLineStart() {
        return "/// ";
    }
    nullableRustType(t, withIssues) {
        return ["Option<", this.breakCycle(t, withIssues), ">"];
    }
    isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
    }
    rustType(t, withIssues = false) {
        return matchType(t, _anyType => maybeAnnotated(withIssues, anyTypeIssueAnnotation, "Option<serde_json::Value>"), _nullType => maybeAnnotated(withIssues, nullTypeIssueAnnotation, "Option<serde_json::Value>"), _boolType => "bool", _integerType => "i64", _doubleType => "f64", _stringType => "String", arrayType => ["Vec<", this.rustType(arrayType.items, withIssues), ">"], classType => this.nameForNamedType(classType), mapType => ["HashMap<String, ", this.rustType(mapType.values, withIssues), ">"], enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return this.nullableRustType(nullable, withIssues);
            const [hasNull] = removeNullFromUnion(unionType);
            const isCycleBreaker = this.isCycleBreakerType(unionType);
            const name = isCycleBreaker
                ? ["Box<", this.nameForNamedType(unionType), ">"]
                : this.nameForNamedType(unionType);
            return hasNull !== null ? ["Option<", name, ">"] : name;
        });
    }
    breakCycle(t, withIssues) {
        const rustType = this.rustType(t, withIssues);
        const isCycleBreaker = this.isCycleBreakerType(t);
        return isCycleBreaker ? ["Box<", rustType, ">"] : rustType;
    }
    emitRenameAttribute(propName, jsonName, defaultNamingStyle, preferedNamingStyle) {
        const escapedName = rustStringEscape(jsonName);
        const name = namingStyles[defaultNamingStyle].fromParts(this.sourcelikeToString(propName).split(" "));
        const styledName = nameToNamingStyle(name, preferedNamingStyle);
        const namesDiffer = escapedName !== styledName;
        if (namesDiffer) {
            this.emitLine('#[serde(rename = "', escapedName, '")]');
        }
    }
    emitSkipSerializeNone(t) {
        if (t instanceof UnionType) {
            const nullable = nullableFromUnion(t);
            if (nullable !== null)
                this.emitLine('#[serde(skip_serializing_if = "Option::is_none")]');
        }
    }
    get visibility() {
        if (this._options.visibility === Visibility.Crate) {
            return "pub(crate) ";
        }
        else if (this._options.visibility === Visibility.Public) {
            return "pub ";
        }
        return "";
    }
    emitStructDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        // List the possible naming styles for every class property
        const propertiesNamingStyles = {};
        this.forEachClassProperty(c, "none", (_name, jsonName, _prop) => {
            propertiesNamingStyles[jsonName] = listMatchingNamingStyles(jsonName);
        });
        // Set the default naming style on the struct
        const defaultStyle = "snake_case";
        const preferedNamingStyle = getPreferedNamingStyle(Object.values(propertiesNamingStyles).flat(), defaultStyle);
        if (preferedNamingStyle !== defaultStyle) {
            this.emitLine(`#[serde(rename_all = "${preferedNamingStyle}")]`);
        }
        const blankLines = this._options.density === Density.Dense ? "none" : "interposing";
        const structBody = () => this.forEachClassProperty(c, blankLines, (name, jsonName, prop) => {
            this.emitDescription(this.descriptionForClassProperty(c, jsonName));
            this.emitRenameAttribute(name, jsonName, defaultStyle, preferedNamingStyle);
            if (this._options.skipSerializingNone) {
                this.emitSkipSerializeNone(prop.type);
            }
            this.emitLine(this.visibility, name, ": ", this.breakCycle(prop.type, true), ",");
        });
        this.emitBlock(["pub struct ", className], structBody);
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    emitUnion(u, unionName) {
        const isMaybeWithSingleType = nullableFromUnion(u);
        if (isMaybeWithSingleType !== null) {
            return;
        }
        this.emitDescription(this.descriptionForType(u));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        this.emitLine("#[serde(untagged)]");
        const [, nonNulls] = removeNullFromUnion(u);
        const blankLines = this._options.density === Density.Dense ? "none" : "interposing";
        this.emitBlock(["pub enum ", unionName], () => this.forEachUnionMember(u, nonNulls, blankLines, null, (fieldName, t) => {
            const rustType = this.breakCycle(t, true);
            this.emitLine([fieldName, "(", rustType, "),"]);
        }));
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("#[derive(", this._options.deriveDebug ? "Debug, " : "", this._options.deriveClone ? "Clone, " : "", this._options.derivePartialEq ? "PartialEq, " : "", "Serialize, Deserialize)]");
        // List the possible naming styles for every enum case
        const enumCasesNamingStyles = {};
        this.forEachEnumCase(e, "none", (_name, jsonName) => {
            enumCasesNamingStyles[jsonName] = listMatchingNamingStyles(jsonName);
        });
        // Set the default naming style on the enum
        const defaultStyle = "PascalCase";
        const preferedNamingStyle = getPreferedNamingStyle(Object.values(enumCasesNamingStyles).flat(), defaultStyle);
        if (preferedNamingStyle !== defaultStyle) {
            this.emitLine(`#[serde(rename_all = "${preferedNamingStyle}")]`);
        }
        const blankLines = this._options.density === Density.Dense ? "none" : "interposing";
        this.emitBlock(["pub enum ", enumName], () => this.forEachEnumCase(e, blankLines, (name, jsonName) => {
            this.emitRenameAttribute(name, jsonName, defaultStyle, preferedNamingStyle);
            this.emitLine([name, ","]);
        }));
    }
    emitTopLevelAlias(t, name) {
        this.emitLine("pub type ", name, " = ", this.rustType(t), ";");
    }
    emitLeadingComments() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
            return;
        }
        const topLevelName = defined(collectionUtils.mapFirst(this.topLevels)).getCombinedName();
        this.emitMultiline(`// Example code that deserializes and serializes the model.
// extern crate serde;
// #[macro_use]
// extern crate serde_derive;
// extern crate serde_json;
//
// use generated_module::${topLevelName};
//
// fn main() {
//     let json = r#"{"answer": 42}"#;
//     let model: ${topLevelName} = serde_json::from_str(&json).unwrap();
// }`);
    }
    emitSourceStructure() {
        if (this._options.leadingComments) {
            this.emitLeadingComments();
        }
        this.ensureBlankLine();
        if (this._options.edition2018) {
            this.emitLine("use serde::{Serialize, Deserialize};");
        }
        else {
            this.emitLine("extern crate serde_derive;");
        }
        if (this.haveMaps) {
            this.emitLine("use std::collections::HashMap;");
        }
        this.forEachTopLevel("leading", (t, name) => this.emitTopLevelAlias(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
        this.forEachNamedType("leading-and-interposing", (c, name) => this.emitStructDefinition(c, name), (e, name) => this.emitEnumDefinition(e, name), (u, name) => this.emitUnion(u, name));
    }
}
function getPreferedNamingStyle(namingStyleOccurences, defaultStyle) {
    const occurrences = Object.fromEntries(Object.keys(namingStyles).map(key => [key, 0]));
    namingStyleOccurences.forEach(style => ++occurrences[style]);
    const max = Math.max(...Object.values(occurrences));
    const preferedStyles = Object.entries(occurrences)
        .filter(([_style, num]) => num === max)
        .map(([style, _num]) => style);
    if (preferedStyles.includes(defaultStyle)) {
        return defaultStyle;
    }
    return preferedStyles[0];
}
function listMatchingNamingStyles(name) {
    return Object.entries(namingStyles)
        .filter(([_, { regex }]) => regex.test(name))
        .map(([namingStyle, _]) => namingStyle);
}
function nameToNamingStyle(name, style) {
    if (namingStyles[style].regex.test(name)) {
        return name;
    }
    const fromStyle = listMatchingNamingStyles(name)[0];
    if (fromStyle === undefined) {
        return name;
    }
    return namingStyles[style].fromParts(namingStyles[fromStyle].toParts(name));
}

var Framework$1;
(function (Framework) {
    Framework["None"] = "None";
    Framework["Upickle"] = "Upickle";
    Framework["Circe"] = "Circe";
})(Framework$1 || (Framework$1 = {}));
const scala3Options = {
    framework: new EnumOption("framework", "Serialization framework", [
        ["just-types", Framework$1.None],
        ["circe", Framework$1.Circe],
        ["upickle", Framework$1.Upickle]
    ], undefined),
    packageName: new StringOption("package", "Package", "PACKAGE", "quicktype")
};
// Use backticks for param names with symbols
const invalidSymbols$1 = [
    ":",
    "-",
    "+",
    "!",
    "@",
    "#",
    "$",
    "%",
    "^",
    "&",
    "*",
    "(",
    ")",
    ">",
    "<",
    "/",
    ";",
    "'",
    '"',
    "{",
    "}",
    ":",
    "~",
    "`",
    "."
];
const keywords$2 = [
    "abstract",
    "case",
    "catch",
    "class",
    "def",
    "do",
    "else",
    "enum",
    "extends",
    "export",
    "false",
    "final",
    "finally",
    "for",
    "forSome",
    "if",
    "implicit",
    "import",
    "lazy",
    "match",
    "new",
    "null",
    "object",
    "override",
    "package",
    "private",
    "protected",
    "return",
    "sealed",
    "super",
    "this",
    "then",
    "throw",
    "trait",
    "try",
    "true",
    "type",
    "val",
    "var",
    "while",
    "with",
    "yield",
    "Any",
    "Boolean",
    "Double",
    "Float",
    "Long",
    "Int",
    "Short",
    "System",
    "Byte",
    "String",
    "Array",
    "List",
    "Map",
    "Enum"
];
/**
 * Check if given parameter name should be wrapped in a backtick
 * @param paramName
 */
const shouldAddBacktick$1 = (paramName) => {
    return (keywords$2.some(s => paramName === s) ||
        invalidSymbols$1.some(s => paramName.includes(s)) ||
        !isNaN(+parseFloat(paramName)) ||
        !isNaN(parseInt(paramName.charAt(0))));
};
const wrapOption = (s, optional) => {
    if (optional) {
        return "Option[" + s + "]";
    }
    else {
        return s;
    }
};
function isPartCharacter$2(codePoint) {
    return isLetterOrUnderscore(codePoint) || isNumeric(codePoint);
}
function isStartCharacter$2(codePoint) {
    return isPartCharacter$2(codePoint) && !isDigit(codePoint);
}
const legalizeName$2 = legalizeCharacters(isPartCharacter$2);
function scalaNameStyle$1(isUpper, original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$2, isUpper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, isUpper ? allUpperWordStyle : allLowerWordStyle, allUpperWordStyle, "", isStartCharacter$2);
}
/* function unicodeEscape(codePoint: number): string {
    return "\\u" + intToHex(codePoint, 4);
} */
// const _stringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, unicodeEscape));
/* function stringEscape(s: string): string {
    // "$this" is a template string in Kotlin so we have to escape $
    return _stringEscape(s).replace(/\$/g, "\\$");
} */
const upperNamingFunction$1 = funPrefixNamer("upper", s => scalaNameStyle$1(true, s));
const lowerNamingFunction$1 = funPrefixNamer("lower", s => scalaNameStyle$1(false, s));
class Scala3Renderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _scalaOptions) {
        super(targetLanguage, renderContext);
        this._scalaOptions = _scalaOptions;
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$2;
    }
    forbiddenForObjectProperties(_, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
    }
    topLevelNameStyle(rawName) {
        return scalaNameStyle$1(true, rawName);
    }
    makeNamedTypeNamer() {
        return upperNamingFunction$1;
    }
    namerForObjectProperty() {
        return lowerNamingFunction$1;
    }
    makeUnionMemberNamer() {
        return funPrefixNamer("upper", s => scalaNameStyle$1(true, s) + "Value");
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("upper", s => s.replace(" ", "")); // TODO - add backticks where appropriate
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly"
            ? ["{", "}"]
            : delimiter === "paren"
                ? ["(", ")"]
                : delimiter === "none"
                    ? ["", ""]
                    : ["{", "})"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
    }
    anySourceType(optional) {
        return [wrapOption("Any", optional)];
    }
    // (asarazan): I've broken out the following two functions
    // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
    arrayType(arrayType, withIssues = false) {
        return ["Seq[", this.scalaType(arrayType.items, withIssues), "]"];
    }
    mapType(mapType, withIssues = false) {
        return ["Map[String, ", this.scalaType(mapType.values, withIssues), "]"];
    }
    scalaType(t, withIssues = false, noOptional = false) {
        return matchType(t, _anyType => {
            return maybeAnnotated(withIssues, anyTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, _nullType => {
            // return "None.type"
            return maybeAnnotated(withIssues, nullTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, _boolType => "Boolean", _integerType => "Long", _doubleType => "Double", _stringType => "String", arrayType => this.arrayType(arrayType, withIssues), classType => this.nameForNamedType(classType), mapType => this.mapType(mapType, withIssues), enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                if (noOptional) {
                    return [this.scalaType(nullable, withIssues)];
                }
                else {
                    return ["Option[", this.scalaType(nullable, withIssues), "]"];
                }
            }
            return this.nameForNamedType(unionType);
        });
    }
    emitUsageHeader() {
        // To be overridden
    }
    emitHeader() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else {
            this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine("package ", this._scalaOptions.packageName);
        this.ensureBlankLine();
    }
    emitTopLevelArray(t, name) {
        const elementType = this.scalaType(t.items);
        this.emitLine(["type ", name, " = List[", elementType, "]"]);
    }
    emitTopLevelMap(t, name) {
        const elementType = this.scalaType(t.values);
        this.emitLine(["type ", name, " = Map[String, ", elementType, "]"]);
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("case class ", className, "()");
    }
    emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
            this.emitEmptyClassDefinition(c, className);
            return;
        }
        const scalaType = (p) => {
            if (p.isOptional) {
                return ["Option[", this.scalaType(p.type, true, true), "]"];
            }
            else {
                return this.scalaType(p.type, true);
            }
        };
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("case class ", className, " (");
        this.indent(() => {
            let count = c.getProperties().size;
            let first = true;
            this.forEachClassProperty(c, "none", (_, jsonName, p) => {
                const nullable = p.type.kind === "union" && nullableFromUnion(p.type) !== null;
                const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
                const last = --count === 0;
                const meta = [];
                const description = this.descriptionForClassProperty(c, jsonName);
                if (description !== undefined) {
                    meta.push(() => this.emitDescription(description));
                }
                if (meta.length > 0 && !first) {
                    this.ensureBlankLine();
                }
                for (const emit of meta) {
                    emit();
                }
                const nameNeedsBackticks = jsonName.endsWith("_") || shouldAddBacktick$1(jsonName);
                const nameWithBackticks = nameNeedsBackticks ? "`" + jsonName + "`" : jsonName;
                this.emitLine("val ", nameWithBackticks, " : ", scalaType(p), p.isOptional ? " = None" : nullableOrOptional ? " = None" : "", last ? "" : ",");
                if (meta.length > 0 && !last) {
                    this.ensureBlankLine();
                }
                first = false;
            });
        });
        this.emitClassDefinitionMethods();
    }
    emitClassDefinitionMethods() {
        this.emitLine(")");
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.emitBlock(["enum ", enumName, " : "], () => {
            let count = e.cases.size;
            if (count > 0) {
                this.emitItem("\t case ");
            }
            this.forEachEnumCase(e, "none", (name, jsonName) => {
                if (!(jsonName == "")) {
                    const backticks = shouldAddBacktick$1(jsonName) ||
                        jsonName.includes(" ") ||
                        !isNaN(parseInt(jsonName.charAt(0)));
                    if (backticks) {
                        this.emitItem("`");
                    }
                    this.emitItemOnce([name]);
                    if (backticks) {
                        this.emitItem("`");
                    }
                    if (--count > 0)
                        this.emitItem([","]);
                }
                else {
                    --count;
                }
            });
        }, "none");
    }
    emitUnionDefinition(u, unionName) {
        function sortBy(t) {
            const kind = t.kind;
            if (kind === "class")
                return kind;
            return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = removeNullFromUnion(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
            theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
            theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitItem(["type ", unionName, " = "]);
        theTypes.forEach((t, i) => {
            this.emitItem(i === 0 ? t : [" | ", t]);
        });
        this.ensureBlankLine();
    }
    emitSourceStructure() {
        this.emitHeader();
        // Top-level arrays, maps
        this.forEachTopLevel("leading", (t, name) => {
            if (t instanceof ArrayType) {
                this.emitTopLevelArray(t, name);
            }
            else if (t instanceof MapType) {
                this.emitTopLevelMap(t, name);
            }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
    }
}
class UpickleRenderer extends Scala3Renderer {
    emitClassDefinitionMethods() {
        this.emitLine(") derives ReadWriter ");
    }
    emitHeader() {
        super.emitHeader();
        this.emitLine("import upickle.default.*");
        this.ensureBlankLine();
    }
}
class CirceRenderer extends Scala3Renderer {
    constructor() {
        super(...arguments);
        this.seenUnionTypes = [];
    }
    circeEncoderForType(t, __ = false, noOptional = false, paramName = "") {
        return matchType(t, _anyType => ["Encoder.encodeJson(", paramName, ")"], _nullType => ["Encoder.encodeNone(", paramName, ")"], _boolType => ["Encoder.encodeBoolean(", paramName, ")"], _integerType => ["Encoder.encodeLong(", paramName, ")"], _doubleType => ["Encoder.encodeDouble(", paramName, ")"], _stringType => ["Encoder.encodeString(", paramName, ")"], arrayType => ["Encoder.encodeSeq[", this.scalaType(arrayType.items), "].apply(", paramName, ")"], classType => ["Encoder.AsObject[", this.scalaType(classType), "].apply(", paramName, ")"], mapType => ["Encoder.encodeMap[String,", this.scalaType(mapType.values), "].apply(", paramName, ")"], _ => ["Encoder.encodeString(", paramName, ")"], unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                if (noOptional) {
                    return ["Encoder.AsObject[", this.nameForNamedType(nullable), "]"];
                }
                else {
                    return ["Encoder.AsObject[Option[", this.nameForNamedType(nullable), "]]"];
                }
            }
            return ["Encoder.AsObject[", this.nameForNamedType(unionType), "]"];
        });
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.ensureBlankLine();
        this.emitLine("case class ", className, "()  derives Encoder.AsObject, Decoder");
    }
    anySourceType(optional) {
        return [wrapOption("Json", optional)];
    }
    emitClassDefinitionMethods() {
        this.emitLine(") derives Encoder.AsObject, Decoder");
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.ensureBlankLine();
        this.emitItem(["type ", enumName, " = "]);
        let count = e.cases.size;
        this.forEachEnumCase(e, "none", (_, jsonName) => {
            // if (!(jsonName == "")) {
            /*                 const backticks =
                                shouldAddBacktick(jsonName) ||
                                jsonName.includes(" ") ||
                                !isNaN(parseInt(jsonName.charAt(0)))
                            if (backticks) {this.emitItem("`")} else  */
            this.emitItem(['"', jsonName, '"']);
            //                if (backticks) {this.emitItem("`")}
            if (--count > 0)
                this.emitItem([" | "]);
            // } else {
            // --count
            // }
        });
        this.ensureBlankLine();
    }
    emitHeader() {
        super.emitHeader();
        this.emitLine("import scala.util.Try");
        this.emitLine("import io.circe.syntax._");
        this.emitLine("import io.circe._");
        this.emitLine("import cats.syntax.functor._");
        this.ensureBlankLine();
        this.emitLine("// For serialising string unions");
        this.emitLine("given [A <: Singleton](using A <:< String): Decoder[A] = Decoder.decodeString.emapTry(x => Try(x.asInstanceOf[A])) ");
        this.emitLine("given [A <: Singleton](using ev: A <:< String): Encoder[A] = Encoder.encodeString.contramap(ev) ");
        this.ensureBlankLine();
        this.emitLine("// If a union has a null in, then we'll need this too... ");
        this.emitLine("type NullValue = None.type");
    }
    emitTopLevelArray(t, name) {
        super.emitTopLevelArray(t, name);
        const elementType = this.scalaType(t.items);
        this.emitLine([
            "given (using ev : ",
            elementType,
            "): Encoder[Map[String,",
            elementType,
            "]] = Encoder.encodeMap[String, ",
            elementType,
            "]"
        ]);
    }
    emitTopLevelMap(t, name) {
        super.emitTopLevelMap(t, name);
        const elementType = this.scalaType(t.values);
        this.ensureBlankLine();
        this.emitLine([
            "given (using ev : ",
            elementType,
            "): Encoder[Map[String, ",
            elementType,
            "]] = Encoder.encodeMap[String, ",
            elementType,
            "]"
        ]);
    }
    emitUnionDefinition(u, unionName) {
        function sortBy(t) {
            const kind = t.kind;
            if (kind === "class")
                return kind;
            return "_" + kind;
        }
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = removeNullFromUnion(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
            theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
            theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitItem(["type ", unionName, " = "]);
        theTypes.forEach((t, i) => {
            this.emitItem(i === 0 ? t : [" | ", t]);
        });
        const thisUnionType = theTypes.map(x => this.sourcelikeToString(x)).join(" | ");
        this.ensureBlankLine();
        if (!this.seenUnionTypes.some(y => y === thisUnionType)) {
            this.seenUnionTypes.push(thisUnionType);
            const sourceLikeTypes = [];
            this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
                sourceLikeTypes.push([this.scalaType(t), t]);
            });
            if (maybeNull !== null) {
                sourceLikeTypes.push([this.nameForUnionMember(u, maybeNull), maybeNull]);
            }
            this.emitLine(["given Decoder[", unionName, "] = {"]);
            this.indent(() => {
                this.emitLine(["List[Decoder[", unionName, "]]("]);
                this.indent(() => {
                    sourceLikeTypes.forEach(t => {
                        this.emitLine(["Decoder[", t[0], "].widen,"]);
                    });
                });
                this.emitLine(").reduceLeft(_ or _)");
            });
            this.emitLine(["}"]);
            this.ensureBlankLine();
            this.emitLine(["given Encoder[", unionName, "] = Encoder.instance {"]);
            this.indent(() => {
                sourceLikeTypes.forEach((t, i) => {
                    const paramTemp = `enc${i.toString()}`;
                    this.emitLine([
                        "case ",
                        paramTemp,
                        " : ",
                        t[0],
                        " => ",
                        this.circeEncoderForType(t[1], false, false, paramTemp)
                    ]);
                });
            });
            this.emitLine("}");
        }
    }
}
class Scala3TargetLanguage extends TargetLanguage {
    constructor() {
        super("Scala3", ["scala3"], "scala");
    }
    getOptions() {
        return [scala3Options.framework, scala3Options.packageName];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(scala3Options, untypedOptionValues);
        switch (options.framework) {
            case Framework$1.None:
                return new Scala3Renderer(this, renderContext, options);
            case Framework$1.Upickle:
                return new UpickleRenderer(this, renderContext, options);
            case Framework$1.Circe:
                return new CirceRenderer(this, renderContext, options);
            default:
                return assertNever(options.framework);
        }
    }
}

var Framework;
(function (Framework) {
    Framework["None"] = "None";
})(Framework || (Framework = {}));
const SmithyOptions = {
    framework: new EnumOption("framework", "Serialization framework", [["just-types", Framework.None]], undefined),
    packageName: new StringOption("package", "Package", "PACKAGE", "quicktype")
};
// Use backticks for param names with symbols
const invalidSymbols = [
    ":",
    "-",
    "+",
    "!",
    "@",
    "#",
    "%",
    "^",
    "&",
    "*",
    "(",
    ")",
    ">",
    "<",
    "/",
    ";",
    "'",
    '"',
    "{",
    "}",
    ":",
    "~",
    "`",
    "."
];
const keywords$1 = [
    "abstract",
    "case",
    "catch",
    "do",
    "else",
    "export",
    "false",
    "final",
    "finally",
    "for",
    "forSome",
    "if",
    "implicit",
    "import",
    "new",
    "override",
    "package",
    "private",
    "protected",
    "return",
    "sealed",
    "super",
    "this",
    "then",
    "throw",
    "trait",
    "try",
    "true",
    "val",
    "var",
    "while",
    "with",
    "yield",
    "Any",
    "Boolean",
    "Double",
    "Float",
    "Long",
    "Int",
    "Short",
    "System",
    "Byte",
    "String",
    "Array",
    "List",
    "Map",
    "Enum"
];
/**
 * Check if given parameter name should be wrapped in a backtick
 * @param paramName
 */
const shouldAddBacktick = (paramName) => {
    return (keywords$1.some(s => paramName === s) ||
        invalidSymbols.some(s => paramName.includes(s)) ||
        !isNaN(parseFloat(paramName)) ||
        !isNaN(parseInt(paramName.charAt(0))));
};
function isPartCharacter$1(codePoint) {
    return isLetterOrUnderscore(codePoint) || isNumeric(codePoint);
}
function isStartCharacter$1(codePoint) {
    return isPartCharacter$1(codePoint) && !isDigit(codePoint);
}
const legalizeName$1 = legalizeCharacters(isPartCharacter$1);
function scalaNameStyle(isUpper, original) {
    const words = splitIntoWords(original);
    return combineWords(words, legalizeName$1, isUpper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, isUpper ? allUpperWordStyle : allLowerWordStyle, allUpperWordStyle, "", isStartCharacter$1);
}
const upperNamingFunction = funPrefixNamer("upper", s => scalaNameStyle(true, s));
const lowerNamingFunction = funPrefixNamer("lower", s => scalaNameStyle(false, s));
class Smithy4sRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _scalaOptions) {
        super(targetLanguage, renderContext);
        this._scalaOptions = _scalaOptions;
    }
    forbiddenNamesForGlobalNamespace() {
        return keywords$1;
    }
    forbiddenForObjectProperties(_, _classNamed) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: false };
    }
    topLevelNameStyle(rawName) {
        return scalaNameStyle(true, rawName);
    }
    makeNamedTypeNamer() {
        return upperNamingFunction;
    }
    namerForObjectProperty() {
        return lowerNamingFunction;
    }
    makeUnionMemberNamer() {
        return funPrefixNamer("upper", s => scalaNameStyle(true, s) + "Value");
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("upper", s => s.replace(" ", "")); // TODO - add backticks where appropriate
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: " * ", beforeComment: "/**", afterComment: " */" });
    }
    emitBlock(line, f, delimiter = "curly") {
        const [open, close] = delimiter === "curly"
            ? ["{", "}"]
            : delimiter === "paren"
                ? ["(", ")"]
                : delimiter === "none"
                    ? ["", ""]
                    : ["{", "})"];
        this.emitLine(line, " ", open);
        this.indent(f);
        this.emitLine(close);
    }
    anySourceType(_) {
        return ["Document"];
    }
    // (asarazan): I've broken out the following two functions
    // because some renderers, such as kotlinx, can cope with `any`, while some get mad.
    arrayType(arrayType, _ = false) {
        // this.emitTopLevelArray(arrayType, new Name(arrayType.getCombinedName().toString() + "List"))
        return arrayType.getCombinedName().toString() + "List";
    }
    emitArrayType(_, smithyType) {
        this.emitLine(["list ", smithyType, " { member : ", "}"]);
    }
    mapType(mapType, _ = false) {
        return mapType.getCombinedName().toString() + "Map";
        // return [this.scalaType(mapType.values, withIssues), "Map"];
    }
    scalaType(t, withIssues = false, noOptional = false) {
        return matchType(t, _anyType => {
            return maybeAnnotated(withIssues, anyTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, _nullType => {
            // return "None.type"
            return maybeAnnotated(withIssues, nullTypeIssueAnnotation, this.anySourceType(!noOptional));
        }, _boolType => "Boolean", _integerType => "Long", _doubleType => "Double", _stringType => "String", arrayType => this.arrayType(arrayType, withIssues), classType => this.nameForNamedType(classType), mapType => this.mapType(mapType, withIssues), enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null) {
                return [this.scalaType(nullable, withIssues)];
            }
            return this.nameForNamedType(unionType);
        });
    }
    emitUsageHeader() {
        // To be overridden
    }
    emitHeader() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else {
            this.emitUsageHeader();
        }
        this.ensureBlankLine();
        this.emitLine('$version: "2"');
        this.emitLine("namespace ", this._scalaOptions.packageName);
        this.ensureBlankLine();
        this.emitLine("document NullValue");
        this.ensureBlankLine();
    }
    emitTopLevelArray(t, name) {
        const elementType = this.scalaType(t.items);
        this.emitLine(["list ", name, " { member : ", elementType, "}"]);
    }
    emitTopLevelMap(t, name) {
        const elementType = this.scalaType(t.values);
        this.emitLine(["map ", name, " { map[ key : String , value : ", elementType, "}"]);
    }
    emitEmptyClassDefinition(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("structure ", className, "{}");
    }
    emitClassDefinition(c, className) {
        if (c.getProperties().size === 0) {
            this.emitEmptyClassDefinition(c, className);
            return;
        }
        const scalaType = (p) => {
            if (p.isOptional) {
                return [this.scalaType(p.type, true, true)];
            }
            else {
                return [this.scalaType(p.type, true)];
            }
        };
        const emitLater = [];
        this.emitDescription(this.descriptionForType(c));
        this.emitLine("structure ", className, " {");
        this.indent(() => {
            let count = c.getProperties().size;
            let first = true;
            this.forEachClassProperty(c, "none", (_, jsonName, p) => {
                const nullable = p.type.kind === "union" && nullableFromUnion(p.type) !== null;
                const nullableOrOptional = p.isOptional || p.type.kind === "null" || nullable;
                const last = --count === 0;
                const meta = [];
                const laterType = p.type.kind === "array" || p.type.kind === "map";
                if (laterType) {
                    emitLater.push(p);
                }
                const description = this.descriptionForClassProperty(c, jsonName);
                if (description !== undefined) {
                    meta.push(() => this.emitDescription(description));
                }
                if (meta.length > 0 && !first) {
                    this.ensureBlankLine();
                }
                for (const emit of meta) {
                    emit();
                }
                const nameNeedsBackticks = jsonName.endsWith("_") || shouldAddBacktick(jsonName);
                const nameWithBackticks = nameNeedsBackticks ? "`" + jsonName + "`" : jsonName;
                this.emitLine(p.isOptional ? "" : nullableOrOptional ? "" : "@required ", nameWithBackticks, " : ", scalaType(p), last ? "" : ",");
                if (meta.length > 0 && !last) {
                    this.ensureBlankLine();
                }
                first = false;
            });
        });
        this.emitClassDefinitionMethods(emitLater);
    }
    emitClassDefinitionMethods(arrayTypes) {
        this.emitLine("}");
        arrayTypes.forEach(p => {
            function ignore(_) {
                return;
            }
            matchCompoundType(p.type, at => {
                this.emitLine([
                    "list ",
                    this.scalaType(at, true),
                    "{ member: ",
                    this.scalaType(at.items, true),
                    "}"
                ]);
            }, ignore, mt => {
                this.emitLine([
                    "map ",
                    this.scalaType(mt, true),
                    "{ key: String , value: ",
                    this.scalaType(mt.values, true),
                    "}"
                ]);
            }, ignore, ignore);
        });
    }
    emitEnumDefinition(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        this.ensureBlankLine();
        this.emitItem(["enum ", enumName, " { "]);
        let count = e.cases.size;
        this.forEachEnumCase(e, "none", (name, jsonName) => {
            // if (!(jsonName == "")) {
            /*                 const backticks =
                                    shouldAddBacktick(jsonName) ||
                                    jsonName.includes(" ") ||
                                    !isNaN(parseInt(jsonName.charAt(0)))
                                if (backticks) {this.emitItem("`")} else  */
            this.emitLine();
            this.emitItem([name, ' = "', jsonName, '"']);
            //                if (backticks) {this.emitItem("`")}
            if (--count > 0)
                this.emitItem([","]);
            // } else {
            // --count
            // }
        });
        this.ensureBlankLine();
        this.emitItem(["}"]);
    }
    emitUnionDefinition(u, unionName) {
        function sortBy(t) {
            const kind = t.kind;
            if (kind === "class")
                return kind;
            return "_" + kind;
        }
        const emitLater = [];
        this.emitDescription(this.descriptionForType(u));
        const [maybeNull, nonNulls] = removeNullFromUnion(u, sortBy);
        const theTypes = [];
        this.forEachUnionMember(u, nonNulls, "none", null, (_, t) => {
            const laterType = t.kind === "array" || t.kind === "map";
            if (laterType) {
                emitLater.push(t);
            }
            theTypes.push(this.scalaType(t));
        });
        if (maybeNull !== null) {
            theTypes.push(this.nameForUnionMember(u, maybeNull));
        }
        this.emitLine(["@untagged union ", unionName, " { "]);
        this.indent(() => {
            theTypes.forEach((t, i) => {
                this.emitLine([String.fromCharCode(i + 65), " : ", t]);
            });
        });
        this.emitLine("}");
        this.ensureBlankLine();
        emitLater.forEach(p => {
            function ignore(_) {
                return;
            }
            matchCompoundType(p, at => {
                this.emitLine([
                    "list ",
                    this.scalaType(at, true),
                    "{ member: ",
                    this.scalaType(at.items, true),
                    "}"
                ]);
            }, ignore, mt => {
                this.emitLine([
                    "map ",
                    this.scalaType(mt, true),
                    "{ key: String , value: ",
                    this.scalaType(mt.values, true),
                    "}"
                ]);
            }, ignore, ignore);
        });
    }
    emitSourceStructure() {
        this.emitHeader();
        // Top-level arrays, maps
        this.forEachTopLevel("leading", (t, name) => {
            if (t instanceof ArrayType) {
                this.emitTopLevelArray(t, name);
            }
            else if (t instanceof MapType) {
                this.emitTopLevelMap(t, name);
            }
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClassDefinition(c, n), (e, n) => this.emitEnumDefinition(e, n), (u, n) => this.emitUnionDefinition(u, n));
    }
}
class SmithyTargetLanguage extends TargetLanguage {
    constructor() {
        super("Smithy", ["Smithy"], "smithy");
    }
    getOptions() {
        return [SmithyOptions.framework, SmithyOptions.packageName];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        const options = getOptionValues(SmithyOptions, untypedOptionValues);
        switch (options.framework) {
            case Framework.None:
                return new Smithy4sRenderer(this, renderContext, options);
            default:
                return assertNever(options.framework);
        }
    }
}

const MAX_SAMELINE_PROPERTIES = 4;
const swiftOptions = {
    justTypes: new BooleanOption("just-types", "Plain types only", false),
    convenienceInitializers: new BooleanOption("initializers", "Generate initializers and mutators", true),
    explicitCodingKeys: new BooleanOption("coding-keys", "Explicit CodingKey values in Codable types", true),
    codingKeysProtocol: new StringOption("coding-keys-protocol", "CodingKeys implements protocols", "protocol1, protocol2...", "", "secondary"),
    alamofire: new BooleanOption("alamofire", "Alamofire extensions", false),
    namedTypePrefix: new StringOption("type-prefix", "Prefix for type names", "PREFIX", "", "secondary"),
    useClasses: new EnumOption("struct-or-class", "Structs or classes", [
        ["struct", false],
        ["class", true]
    ]),
    mutableProperties: new BooleanOption("mutable-properties", "Use var instead of let for object properties", false),
    acronymStyle: acronymOption(AcronymStyleOptions.Pascal),
    dense: new EnumOption("density", "Code density", [
        ["dense", true],
        ["normal", false]
    ], "dense", "secondary"),
    linux: new BooleanOption("support-linux", "Support Linux", false, "secondary"),
    objcSupport: new BooleanOption("objective-c-support", "Objects inherit from NSObject and @objcMembers is added to classes", false),
    optionalEnums: new BooleanOption("optional-enums", "If no matching case is found enum value is set to null", false),
    swift5Support: new BooleanOption("swift-5-support", "Renders output in a Swift 5 compatible mode", false),
    sendable: new BooleanOption("sendable", "Mark generated models as Sendable", false),
    multiFileOutput: new BooleanOption("multi-file-output", "Renders each top-level object in its own Swift file", false),
    accessLevel: new EnumOption("access-level", "Access level", [
        ["internal", "internal"],
        ["public", "public"]
    ], "internal", "secondary"),
    protocol: new EnumOption("protocol", "Make types implement protocol", [
        ["none", { equatable: false, hashable: false }],
        ["equatable", { equatable: true, hashable: false }],
        ["hashable", { equatable: false, hashable: true }]
    ], "none", "secondary")
};
// These are all recognized by Swift as ISO8601 date-times:
//
// 2018-08-14T02:45:50+00:00
// 2018-08-14T02:45:50+00
// 2018-08-14T02:45:50+1
// 2018-08-14T02:45:50+1111
// 2018-08-14T02:45:50+1111:1:33
// 2018-08-14T02:45:50-00
// 2018-08-14T02:45:50z
// 2018-00008-1T002:45:3Z
const swiftDateTimeRegex = /^\d+-\d+-\d+T\d+:\d+:\d+([zZ]|[+-]\d+(:\d+)?)$/;
class SwiftDateTimeRecognizer extends DefaultDateTimeRecognizer {
    isDateTime(str) {
        return swiftDateTimeRegex.exec(str) !== null;
    }
}
class SwiftTargetLanguage extends TargetLanguage {
    constructor() {
        super("Swift", ["swift", "swift4"], "swift");
    }
    getOptions() {
        return [
            swiftOptions.justTypes,
            swiftOptions.useClasses,
            swiftOptions.dense,
            swiftOptions.convenienceInitializers,
            swiftOptions.explicitCodingKeys,
            swiftOptions.codingKeysProtocol,
            swiftOptions.accessLevel,
            swiftOptions.alamofire,
            swiftOptions.linux,
            swiftOptions.namedTypePrefix,
            swiftOptions.protocol,
            swiftOptions.acronymStyle,
            swiftOptions.objcSupport,
            swiftOptions.optionalEnums,
            swiftOptions.sendable,
            swiftOptions.swift5Support,
            swiftOptions.multiFileOutput,
            swiftOptions.mutableProperties
        ];
    }
    get stringTypeMapping() {
        const mapping = new Map();
        mapping.set("date-time", "date-time");
        return mapping;
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    get supportsUnionsWithBothNumberTypes() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new SwiftRenderer(this, renderContext, getOptionValues(swiftOptions, untypedOptionValues));
    }
    get dateTimeRecognizer() {
        return new SwiftDateTimeRecognizer();
    }
}
const keywords = [
    "await",
    "associatedtype",
    "class",
    "deinit",
    "enum",
    "extension",
    "fileprivate",
    "func",
    "import",
    "init",
    "inout",
    "internal",
    "let",
    "open",
    "operator",
    "private",
    "protocol",
    "public",
    "static",
    "struct",
    "subscript",
    "typealias",
    "var",
    "break",
    "case",
    "continue",
    "default",
    "defer",
    "do",
    "else",
    "fallthrough",
    "for",
    "guard",
    "if",
    "in",
    "repeat",
    "return",
    "switch",
    "where",
    "while",
    "as",
    "Any",
    "catch",
    "false",
    "is",
    "nil",
    "rethrows",
    "super",
    "self",
    "Self",
    "throw",
    "throws",
    "true",
    "try",
    "_",
    "associativity",
    "convenience",
    "dynamic",
    "didSet",
    "final",
    "get",
    "infix",
    "indirect",
    "lazy",
    "left",
    "mutating",
    "nonmutating",
    "optional",
    "override",
    "postfix",
    "precedence",
    "prefix",
    "Protocol",
    "required",
    "right",
    "set",
    "Type",
    "unowned",
    "weak",
    "willSet",
    "String",
    "Int",
    "Double",
    "Bool",
    "Data",
    "Date",
    "URL",
    "CommandLine",
    "FileHandle",
    "JSONSerialization",
    "checkNull",
    "removeNSNull",
    "nilToNSNull",
    "convertArray",
    "convertOptional",
    "convertDict",
    "convertDouble",
    "jsonString",
    "jsonData"
];
function isPartCharacter(codePoint) {
    return isLetterOrUnderscore(codePoint) || isNumeric(codePoint);
}
function isStartCharacter(codePoint) {
    return isPartCharacter(codePoint) && !isDigit(codePoint);
}
const legalizeName = legalizeCharacters(isPartCharacter);
function swiftNameStyle(prefix, isUpper, original, acronymsStyle = allUpperWordStyle) {
    const words = splitIntoWords(original);
    const combined = combineWords(words, legalizeName, isUpper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, isUpper ? allUpperWordStyle : allLowerWordStyle, acronymsStyle, "", isStartCharacter);
    return addPrefixIfNecessary(prefix, combined);
}
function unicodeEscape(codePoint) {
    return "\\u{" + intToHex(codePoint, 0) + "}";
}
const stringEscape = utf32ConcatMap(escapeNonPrintableMapper(isPrintable, unicodeEscape));
class SwiftRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this._needAny = false;
        this._needNull = false;
        this.emitSupportFunctions4 = () => {
            this.startFile("JSONSchemaSupport");
            this.emitLineOnce("import Foundation");
            this.forEachTopLevel("leading", (t, name) => this.renderTopLevelAlias(t, name), t => this.namedTypeToNameForTopLevel(t) === undefined);
            if (this._options.convenienceInitializers) {
                this.ensureBlankLine();
                this.forEachTopLevel("leading-and-interposing", (t, name) => this.emitTopLevelMapAndArrayConvenienceInitializerExtensions(t, name));
            }
            if ((!this._options.justTypes && this._options.convenienceInitializers) || this._options.alamofire) {
                this.ensureBlankLine();
                this.emitMark("Helper functions for creating encoders and decoders", true);
                this.ensureBlankLine();
                this.emitNewEncoderDecoder();
            }
            if (this._options.alamofire) {
                this.ensureBlankLine();
                this.emitMark("Alamofire response handlers", true);
                this.ensureBlankLine();
                this.emitAlamofireExtension();
            }
            // This assumes that this method is called after declarations
            // are emitted.
            if (this._needAny || this._needNull) {
                this.ensureBlankLine();
                this.emitMark("Encode/decode helpers", true);
                this.ensureBlankLine();
                if (this._options.objcSupport) {
                    this.emitLine(this.objcMembersDeclaration, this.accessLevel, "class JSONNull: NSObject, Codable {");
                }
                else {
                    this.emitLine(this.accessLevel, "class JSONNull: Codable, Hashable {");
                }
                this.ensureBlankLine();
                this.emitMultiline(`    public static func == (lhs: JSONNull, rhs: JSONNull) -> Bool {
        return true
    }`);
                if (this._options.objcSupport === false) {
                    this.ensureBlankLine();
                    this.emitMultiline(`    public var hashValue: Int {
        return 0
    }`);
                    if (this._options.swift5Support) {
                        this.ensureBlankLine();
                        this.emitMultiline(`    public func hash(into hasher: inout Hasher) {
        // No-op
    }`);
                    }
                }
                this.ensureBlankLine();
                if (this._options.objcSupport) {
                    this.emitItem("    override ");
                }
                else {
                    this.emitItem("    ");
                }
                this.emitMultiline(`public init() {}
    
    public required init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if !container.decodeNil() {
            throw DecodingError.typeMismatch(JSONNull.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for JSONNull"))
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encodeNil()
    }
}`);
            }
            if (this._needAny) {
                this.ensureBlankLine();
                this.emitMultiline(`class JSONCodingKey: CodingKey {
    let key: String
    
    required init?(intValue: Int) {
        return nil
    }
    
    required init?(stringValue: String) {
        key = stringValue
    }
    
    var intValue: Int? {
        return nil
    }
    
    var stringValue: String {
        return key
    }
}`);
                this.ensureBlankLine();
                if (this._options.objcSupport) {
                    this.emitLine(this.objcMembersDeclaration, this.accessLevel, "class JSONAny: NSObject, Codable {");
                }
                else {
                    this.emitLine(this.accessLevel, "class JSONAny: Codable {");
                }
                this.ensureBlankLine();
                this.emitMultiline(`    ${this.accessLevel}let value: Any
    
    static func decodingError(forCodingPath codingPath: [CodingKey]) -> DecodingError {
        let context = DecodingError.Context(codingPath: codingPath, debugDescription: "Cannot decode JSONAny")
        return DecodingError.typeMismatch(JSONAny.self, context)
    }
    
    static func encodingError(forValue value: Any, codingPath: [CodingKey]) -> EncodingError {
        let context = EncodingError.Context(codingPath: codingPath, debugDescription: "Cannot encode JSONAny")
        return EncodingError.invalidValue(value, context)
    }

    static func decode(from container: SingleValueDecodingContainer) throws -> Any {
        if let value = try? container.decode(Bool.self) {
            return value
        }
        if let value = try? container.decode(Int64.self) {
            return value
        }
        if let value = try? container.decode(Double.self) {
            return value
        }
        if let value = try? container.decode(String.self) {
            return value
        }
        if container.decodeNil() {
            return JSONNull()
        }
        throw decodingError(forCodingPath: container.codingPath)
    }
    
    static func decode(from container: inout UnkeyedDecodingContainer) throws -> Any {
        if let value = try? container.decode(Bool.self) {
            return value
        }
        if let value = try? container.decode(Int64.self) {
            return value
        }
        if let value = try? container.decode(Double.self) {
            return value
        }
        if let value = try? container.decode(String.self) {
            return value
        }
        if let value = try? container.decodeNil() {
            if value {
                return JSONNull()
            }
        }
        if var container = try? container.nestedUnkeyedContainer() {
            return try decodeArray(from: &container)
        }
        if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self) {
            return try decodeDictionary(from: &container)
        }
        throw decodingError(forCodingPath: container.codingPath)
    }
    
    static func decode(from container: inout KeyedDecodingContainer<JSONCodingKey>, forKey key: JSONCodingKey) throws -> Any {
        if let value = try? container.decode(Bool.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(Int64.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(Double.self, forKey: key) {
            return value
        }
        if let value = try? container.decode(String.self, forKey: key) {
            return value
        }
        if let value = try? container.decodeNil(forKey: key) {
            if value {
                return JSONNull()
            }
        }
        if var container = try? container.nestedUnkeyedContainer(forKey: key) {
            return try decodeArray(from: &container)
        }
        if var container = try? container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key) {
            return try decodeDictionary(from: &container)
        }
        throw decodingError(forCodingPath: container.codingPath)
    }
    
    static func decodeArray(from container: inout UnkeyedDecodingContainer) throws -> [Any] {
        var arr: [Any] = []
        while !container.isAtEnd {
            let value = try decode(from: &container)
            arr.append(value)
        }
        return arr
    }

    static func decodeDictionary(from container: inout KeyedDecodingContainer<JSONCodingKey>) throws -> [String: Any] {
        var dict = [String: Any]()
        for key in container.allKeys {
            let value = try decode(from: &container, forKey: key)
            dict[key.stringValue] = value
        }
        return dict
    }
    
    static func encode(to container: inout UnkeyedEncodingContainer, array: [Any]) throws {
        for value in array {
            if let value = value as? Bool {
                try container.encode(value)
            } else if let value = value as? Int64 {
                try container.encode(value)
            } else if let value = value as? Double {
                try container.encode(value)
            } else if let value = value as? String {
                try container.encode(value)
            } else if value is JSONNull {
                try container.encodeNil()
            } else if let value = value as? [Any] {
                var container = container.nestedUnkeyedContainer()
                try encode(to: &container, array: value)
            } else if let value = value as? [String: Any] {
                var container = container.nestedContainer(keyedBy: JSONCodingKey.self)
                try encode(to: &container, dictionary: value)
            } else {
                throw encodingError(forValue: value, codingPath: container.codingPath)
            }
        }
    }
    
    static func encode(to container: inout KeyedEncodingContainer<JSONCodingKey>, dictionary: [String: Any]) throws {
        for (key, value) in dictionary {
            let key = JSONCodingKey(stringValue: key)!
            if let value = value as? Bool {
                try container.encode(value, forKey: key)
            } else if let value = value as? Int64 {
                try container.encode(value, forKey: key)
            } else if let value = value as? Double {
                try container.encode(value, forKey: key)
            } else if let value = value as? String {
                try container.encode(value, forKey: key)
            } else if value is JSONNull {
                try container.encodeNil(forKey: key)
            } else if let value = value as? [Any] {
                var container = container.nestedUnkeyedContainer(forKey: key)
                try encode(to: &container, array: value)
            } else if let value = value as? [String: Any] {
                var container = container.nestedContainer(keyedBy: JSONCodingKey.self, forKey: key)
                try encode(to: &container, dictionary: value)
            } else {
                throw encodingError(forValue: value, codingPath: container.codingPath)
            }
        }
    }

    static func encode(to container: inout SingleValueEncodingContainer, value: Any) throws {
        if let value = value as? Bool {
            try container.encode(value)
        } else if let value = value as? Int64 {
            try container.encode(value)
        } else if let value = value as? Double {
            try container.encode(value)
        } else if let value = value as? String {
            try container.encode(value)
        } else if value is JSONNull {
            try container.encodeNil()
        } else {
            throw encodingError(forValue: value, codingPath: container.codingPath)
        }
    }
    
    public required init(from decoder: Decoder) throws {
        if var arrayContainer = try? decoder.unkeyedContainer() {
            self.value = try JSONAny.decodeArray(from: &arrayContainer)
        } else if var container = try? decoder.container(keyedBy: JSONCodingKey.self) {
            self.value = try JSONAny.decodeDictionary(from: &container)
        } else {
            let container = try decoder.singleValueContainer()
            self.value = try JSONAny.decode(from: container)
        }
    }
    
    public func encode(to encoder: Encoder) throws {
        if let arr = self.value as? [Any] {
            var container = encoder.unkeyedContainer()
            try JSONAny.encode(to: &container, array: arr)
        } else if let dict = self.value as? [String: Any] {
            var container = encoder.container(keyedBy: JSONCodingKey.self)
            try JSONAny.encode(to: &container, dictionary: dict)
        } else {
            var container = encoder.singleValueContainer()
            try JSONAny.encode(to: &container, value: self.value)
        }
    }
}`);
            }
            this.endFile();
        };
    }
    forbiddenNamesForGlobalNamespace() {
        if (this._options.alamofire) {
            return ["DataRequest", ...keywords];
        }
        return keywords;
    }
    forbiddenForObjectProperties(_c, _classNamed) {
        return { names: ["fromURL", "json"], includeGlobalForbidden: true };
    }
    forbiddenForEnumCases(_e, _enumName) {
        return { names: [], includeGlobalForbidden: true };
    }
    forbiddenForUnionMembers(_u, _unionName) {
        return { names: [], includeGlobalForbidden: true };
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("upper", s => swiftNameStyle(this._options.namedTypePrefix, true, s, acronymStyle(this._options.acronymStyle)));
    }
    namerForObjectProperty() {
        return this.lowerNamingFunction;
    }
    makeUnionMemberNamer() {
        return this.lowerNamingFunction;
    }
    makeEnumCaseNamer() {
        return this.lowerNamingFunction;
    }
    isImplicitCycleBreaker(t) {
        const kind = t.kind;
        return kind === "array" || kind === "map";
    }
    emitDescriptionBlock(lines) {
        this.emitCommentLines(lines, { lineStart: "/// " });
    }
    emitBlock(line, f) {
        this.emitLine(line, " {");
        this.indent(f);
        this.emitLine("}");
    }
    emitBlockWithAccess(line, f) {
        this.emitBlock([this.accessLevel, line], f);
    }
    justTypesCase(justTypes, notJustTypes) {
        if (this._options.justTypes)
            return justTypes;
        else
            return notJustTypes;
    }
    get lowerNamingFunction() {
        return funPrefixNamer("lower", s => swiftNameStyle("", false, s, acronymStyle(this._options.acronymStyle)));
    }
    swiftPropertyType(p) {
        if (p.isOptional || (this._options.optionalEnums && p.type.kind === "enum")) {
            return [this.swiftType(p.type, true, true), "?"];
        }
        else {
            return this.swiftType(p.type, true);
        }
    }
    swiftType(t, withIssues = false, noOptional = false) {
        const optional = noOptional ? "" : "?";
        return matchType(t, _anyType => {
            this._needAny = true;
            return maybeAnnotated(withIssues, anyTypeIssueAnnotation, this.justTypesCase(["Any", optional], "JSONAny"));
        }, _nullType => {
            this._needNull = true;
            return maybeAnnotated(withIssues, nullTypeIssueAnnotation, this.justTypesCase("NSNull", ["JSONNull", optional]));
        }, _boolType => "Bool", _integerType => "Int", _doubleType => "Double", _stringType => "String", arrayType => ["[", this.swiftType(arrayType.items, withIssues), "]"], classType => this.nameForNamedType(classType), mapType => ["[String: ", this.swiftType(mapType.values, withIssues), "]"], enumType => this.nameForNamedType(enumType), unionType => {
            const nullable = nullableFromUnion(unionType);
            if (nullable !== null)
                return [this.swiftType(nullable, withIssues), optional];
            return this.nameForNamedType(unionType);
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return "Date";
            }
            else {
                return panic(`Transformed string type ${transformedStringType.kind} not supported`);
            }
        });
    }
    proposedUnionMemberNameForTypeKind(kind) {
        if (kind === "enum") {
            return "enumeration";
        }
        if (kind === "union") {
            return "one_of";
        }
        return null;
    }
    renderSingleFileHeaderComments() {
        this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
        this.emitLineOnce("// To parse the JSON, add this file to your project and do:");
        this.emitLineOnce("//");
        this.forEachTopLevel("none", (t, topLevelName) => {
            if (this._options.convenienceInitializers && !(t instanceof EnumType)) {
                this.emitLineOnce("//   let ", modifySource(camelCase, topLevelName), " = try ", topLevelName, "(json)");
            }
            else {
                this.emitLineOnce("//   let ", modifySource(camelCase, topLevelName), " = ", "try? JSONDecoder().decode(", topLevelName, ".self, from: jsonData)");
            }
        });
    }
    renderHeader(type, name) {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        else if (!this._options.justTypes) {
            if (this._options.multiFileOutput) {
                this.emitLineOnce("// This file was generated from JSON Schema using quicktype, do not modify it directly.");
                this.emitLineOnce("// To parse the JSON, add this file to your project and do:");
                this.emitLineOnce("//");
                if (this._options.convenienceInitializers && !(type instanceof EnumType)) {
                    this.emitLine("//   let ", modifySource(camelCase, name), " = try ", name, "(json)");
                }
                else {
                    this.emitLine("//   let ", modifySource(camelCase, name), " = ", "try? newJSONDecoder().decode(", name, ".self, from: jsonData)");
                }
            }
            if (this._options.alamofire) {
                this.emitLine("//");
                this.emitLine("// To parse values from Alamofire responses:");
                this.emitLine("//");
                this.emitLine("//   Alamofire.request(url).response", name, " { response in");
                this.emitLine("//     if let ", modifySource(camelCase, name), " = response.result.value {");
                this.emitLine("//       ...");
                this.emitLine("//     }");
                this.emitLine("//   }");
            }
            if (this._options.protocol.hashable || this._options.protocol.equatable) {
                this.emitLine("//");
                this.emitLine("// Hashable or Equatable:");
                this.emitLine("// The compiler will not be able to synthesize the implementation of Hashable or Equatable");
                this.emitLine("// for types that require the use of JSONAny, nor will the implementation of Hashable be");
                this.emitLine("// synthesized for types that have collections (such as arrays or dictionaries).");
            }
        }
        this.ensureBlankLine();
        this.emitLineOnce("import Foundation");
        if (!this._options.justTypes && this._options.alamofire) {
            this.emitLineOnce("import Alamofire");
        }
        if (this._options.optionalEnums) {
            this.emitLineOnce("import OptionallyDecodable // https://github.com/idrougge/OptionallyDecodable");
        }
        this.ensureBlankLine();
    }
    renderTopLevelAlias(t, name) {
        this.emitLine(this.accessLevel, "typealias ", name, " = ", this.swiftType(t, true));
    }
    getProtocolsArray(kind) {
        const protocols = [];
        // [Michael Fey (@MrRooni), 2019-4-24] Technically NSObject isn't a "protocol" in this instance, but this felt like the best place to slot in this superclass declaration.
        const isClass = kind === "class";
        if (isClass && this._options.objcSupport) {
            protocols.push("NSObject");
        }
        if (!this._options.justTypes) {
            protocols.push("Codable");
        }
        if (this._options.protocol.hashable) {
            protocols.push("Hashable");
        }
        if (this._options.protocol.equatable) {
            protocols.push("Equatable");
        }
        if (this._options.sendable && (!this._options.mutableProperties || !isClass) && !this._options.objcSupport) {
            protocols.push("Sendable");
        }
        return protocols;
    }
    getProtocolString(kind, baseClass = undefined) {
        let protocols = this.getProtocolsArray(kind);
        if (baseClass) {
            protocols.unshift(baseClass);
        }
        return protocols.length > 0 ? ": " + protocols.join(", ") : "";
    }
    getEnumPropertyGroups(c) {
        let groups = [];
        let group = [];
        this.forEachClassProperty(c, "none", (name, jsonName) => {
            const label = stringEscape(jsonName);
            const redundant = this.sourcelikeToString(name) === label;
            if (this._options.dense && redundant) {
                group.push({ name });
            }
            else {
                if (group.length > 0) {
                    groups.push(group);
                    group = [];
                }
                groups.push([{ name, label }]);
            }
        });
        if (group.length > 0) {
            groups.push(group);
        }
        return groups;
    }
    /// Access level with trailing space (e.g. "public "), or empty string
    get accessLevel() {
        return this._options.accessLevel === "internal"
            ? "" // internal is default, so we don't have to emit it
            : this._options.accessLevel + " ";
    }
    get objcMembersDeclaration() {
        if (this._options.objcSupport) {
            return "@objcMembers ";
        }
        return "";
    }
    /// startFile takes a file name, appends ".swift" to it and sets it as the current filename.
    startFile(basename) {
        if (this._options.multiFileOutput === false) {
            return;
        }
        assert(this._currentFilename === undefined, "Previous file wasn't finished: " + this._currentFilename);
        // FIXME: The filenames should actually be Sourcelikes, too
        this._currentFilename = `${this.sourcelikeToString(basename)}.swift`;
        this.initializeEmitContextForFilename(this._currentFilename);
    }
    /// endFile pushes the current file name onto the collection of finished files and then resets the current file name. These finished files are used in index.ts to write the output.
    endFile() {
        if (this._options.multiFileOutput === false) {
            return;
        }
        this.finishFile(defined(this._currentFilename));
        this._currentFilename = undefined;
    }
    propertyLinesDefinition(name, parameter) {
        const useMutableProperties = this._options.mutableProperties;
        return [
            this.accessLevel,
            useMutableProperties ? "var " : "let ",
            name,
            ": ",
            this.swiftPropertyType(parameter)
        ];
    }
    renderClassDefinition(c, className) {
        this.startFile(className);
        this.renderHeader(c, className);
        this.emitDescription(this.descriptionForType(c));
        this.emitMark(this.sourcelikeToString(className), true);
        const isClass = this._options.useClasses || this.isCycleBreakerType(c);
        const structOrClass = isClass ? "class" : "struct";
        if (isClass && this._options.objcSupport) {
            // [Michael Fey (@MrRooni), 2019-4-24] Swift 5 or greater, must come before the access declaration for the class.
            this.emitItem(this.objcMembersDeclaration);
        }
        this.emitBlockWithAccess([structOrClass, " ", className, this.getProtocolString(structOrClass)], () => {
            if (this._options.dense) {
                let lastProperty = undefined;
                let lastNames = [];
                const emitLastProperty = () => {
                    if (lastProperty === undefined)
                        return;
                    const useMutableProperties = this._options.mutableProperties;
                    let sources = [
                        [
                            this._options.optionalEnums && lastProperty.type.kind === "enum"
                                ? "@OptionallyDecodable "
                                : "",
                            this.accessLevel,
                            useMutableProperties || (this._options.optionalEnums && lastProperty.type.kind === "enum")
                                ? "var "
                                : "let "
                        ]
                    ];
                    lastNames.forEach((n, i) => {
                        if (i > 0)
                            sources.push(", ");
                        sources.push(n);
                    });
                    sources.push(": ");
                    sources.push(this.swiftPropertyType(lastProperty));
                    this.emitLine(sources);
                    lastProperty = undefined;
                    lastNames = [];
                };
                this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                    const description = this.descriptionForClassProperty(c, jsonName);
                    if ((lastProperty && !p.equals(lastProperty)) ||
                        lastNames.length >= MAX_SAMELINE_PROPERTIES ||
                        description !== undefined) {
                        emitLastProperty();
                    }
                    if (lastProperty === undefined) {
                        lastProperty = p;
                    }
                    lastNames.push(name);
                    if (description !== undefined) {
                        this.emitDescription(description);
                        emitLastProperty();
                    }
                });
                emitLastProperty();
            }
            else {
                this.forEachClassProperty(c, "none", (name, jsonName, p) => {
                    const description = this.descriptionForClassProperty(c, jsonName);
                    const propertyLines = this.propertyLinesDefinition(name, p);
                    this.emitDescription(description);
                    this.emitLine(propertyLines);
                });
            }
            if (!this._options.justTypes) {
                const groups = this.getEnumPropertyGroups(c);
                const allPropertiesRedundant = groups.every(group => {
                    return group.every(p => p.label === undefined);
                });
                if (!allPropertiesRedundant && c.getProperties().size > 0) {
                    this.ensureBlankLine();
                    let enumDeclaration = this.accessLevel;
                    enumDeclaration += "enum CodingKeys: String, CodingKey";
                    if (this._options.codingKeysProtocol && this._options.codingKeysProtocol.length > 0) {
                        enumDeclaration += ", ";
                        enumDeclaration += this._options.codingKeysProtocol;
                    }
                    this.emitBlock(enumDeclaration, () => {
                        for (const group of groups) {
                            const { name, label } = group[0];
                            if (this._options.explicitCodingKeys && label !== undefined) {
                                this.emitLine("case ", name, ' = "', label, '"');
                            }
                            else {
                                const names = collectionUtils.arrayIntercalate(", ", group.map(p => p.name));
                                this.emitLine("case ", names);
                            }
                        }
                    });
                }
            }
            // this main initializer must be defined within the class
            // declaration since it assigns let constants
            if (isClass ||
                // Public structs need explicit initializers
                // https://github.com/quicktype/quicktype/issues/899
                this._options.accessLevel === "public") {
                // Make an initializer that initalizes all fields
                this.ensureBlankLine();
                let initProperties = this.initializableProperties(c);
                let propertiesLines = [];
                for (let property of initProperties) {
                    if (propertiesLines.length > 0)
                        propertiesLines.push(", ");
                    propertiesLines.push(property.name, ": ", this.swiftPropertyType(property.parameter));
                }
                if (this.propertyCount(c) === 0 && this._options.objcSupport) {
                    this.emitBlockWithAccess(["override init()"], () => {
                        return "";
                    });
                }
                else {
                    this.emitBlockWithAccess(["init(", ...propertiesLines, ")"], () => {
                        for (let property of initProperties) {
                            this.emitLine("self.", property.name, " = ", property.name);
                        }
                    });
                }
            }
        });
        if (!this._options.justTypes) {
            // FIXME: We emit only the MARK line for top-level-enum.schema
            if (this._options.convenienceInitializers) {
                this.ensureBlankLine();
                this.emitMark(this.sourcelikeToString(className) + " convenience initializers and mutators");
                this.ensureBlankLine();
                this.emitConvenienceInitializersExtension(c, className);
                this.ensureBlankLine();
            }
        }
        this.endFile();
    }
    initializableProperties(c) {
        const properties = [];
        this.forEachClassProperty(c, "none", (name, jsonName, parameter, position) => {
            const property = { name, jsonName, parameter, position };
            properties.push(property);
        });
        return properties;
    }
    emitNewEncoderDecoder() {
        this.emitBlock("func newJSONDecoder() -> JSONDecoder", () => {
            this.emitLine("let decoder = JSONDecoder()");
            if (!this._options.linux) {
                this.emitBlock("if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *)", () => {
                    this.emitLine("decoder.dateDecodingStrategy = .iso8601");
                });
            }
            else {
                this.emitMultiline(`decoder.dateDecodingStrategy = .custom({ (decoder) -> Date in
    let container = try decoder.singleValueContainer()
    let dateStr = try container.decode(String.self)

    let formatter = DateFormatter()
    formatter.calendar = Calendar(identifier: .iso8601)
    formatter.locale = Locale(identifier: "en_US_POSIX")
    formatter.timeZone = TimeZone(secondsFromGMT: 0)
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXXXX"
    if let date = formatter.date(from: dateStr) {
        return date
    }
    formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
    if let date = formatter.date(from: dateStr) {
        return date
    }
    throw DecodingError.typeMismatch(Date.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Could not decode date"))
})`);
            }
            this.emitLine("return decoder");
        });
        this.ensureBlankLine();
        this.emitBlock("func newJSONEncoder() -> JSONEncoder", () => {
            this.emitLine("let encoder = JSONEncoder()");
            if (!this._options.linux) {
                this.emitBlock("if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *)", () => {
                    this.emitLine("encoder.dateEncodingStrategy = .iso8601");
                });
            }
            else {
                this.emitMultiline(`let formatter = DateFormatter()
formatter.calendar = Calendar(identifier: .iso8601)
formatter.locale = Locale(identifier: "en_US_POSIX")
formatter.timeZone = TimeZone(secondsFromGMT: 0)
formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXXX"
encoder.dateEncodingStrategy = .formatted(formatter)`);
            }
            this.emitLine("return encoder");
        });
    }
    emitConvenienceInitializersExtension(c, className) {
        const isClass = this._options.useClasses || this.isCycleBreakerType(c);
        const convenience = isClass ? "convenience " : "";
        this.emitBlockWithAccess(["extension ", className], () => {
            if (isClass) {
                this.emitBlock("convenience init(data: Data) throws", () => {
                    if (this.propertyCount(c) > 0) {
                        this.emitLine("let me = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
                    }
                    else {
                        this.emitLine("let _ = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
                    }
                    let args = [];
                    this.forEachClassProperty(c, "none", name => {
                        if (args.length > 0)
                            args.push(", ");
                        args.push(name, ": ", "me.", name);
                    });
                    this.emitLine("self.init(", ...args, ")");
                });
            }
            else {
                this.emitBlock("init(data: Data) throws", () => {
                    this.emitLine("self = try newJSONDecoder().decode(", this.swiftType(c), ".self, from: data)");
                });
            }
            this.ensureBlankLine();
            this.emitBlock([convenience, "init(_ json: String, using encoding: String.Encoding = .utf8) throws"], () => {
                this.emitBlock("guard let data = json.data(using: encoding) else", () => {
                    this.emitLine('throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)');
                });
                this.emitLine("try self.init(data: data)");
            });
            this.ensureBlankLine();
            this.emitBlock([convenience, "init(fromURL url: URL) throws"], () => {
                this.emitLine("try self.init(data: try Data(contentsOf: url))");
            });
            this.ensureBlankLine();
            this.emitConvenienceMutator(c, className);
            // Convenience serializers
            this.ensureBlankLine();
            this.emitBlock("func jsonData() throws -> Data", () => {
                this.emitLine("return try newJSONEncoder().encode(self)");
            });
            this.ensureBlankLine();
            this.emitBlock("func jsonString(encoding: String.Encoding = .utf8) throws -> String?", () => {
                this.emitLine("return String(data: try self.jsonData(), encoding: encoding)");
            });
        });
    }
    renderEnumDefinition(e, enumName) {
        this.startFile(enumName);
        this.emitLineOnce("import Foundation");
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        const protocolString = this.getProtocolString("enum", "String");
        if (this._options.justTypes) {
            this.emitBlockWithAccess(["enum ", enumName, protocolString], () => {
                this.forEachEnumCase(e, "none", name => {
                    this.emitLine("case ", name);
                });
            });
        }
        else {
            this.emitBlockWithAccess(["enum ", enumName, protocolString], () => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    this.emitLine("case ", name, ' = "', stringEscape(jsonName), '"');
                });
            });
        }
        this.endFile();
    }
    renderUnionDefinition(u, unionName) {
        this.startFile(unionName);
        this.emitLineOnce("import Foundation");
        this.ensureBlankLine();
        function sortBy(t) {
            const kind = t.kind;
            if (kind === "class")
                return kind;
            return "_" + kind;
        }
        const renderUnionCase = (t) => {
            this.emitBlock(["if let x = try? container.decode(", this.swiftType(t), ".self)"], () => {
                this.emitLine("self = .", this.nameForUnionMember(u, t), "(x)");
                this.emitLine("return");
            });
        };
        this.emitDescription(this.descriptionForType(u));
        const indirect = this.isCycleBreakerType(u) ? "indirect " : "";
        const [maybeNull, nonNulls] = removeNullFromUnion(u, sortBy);
        this.emitBlockWithAccess([indirect, "enum ", unionName, this.getProtocolString("enum")], () => {
            this.forEachUnionMember(u, nonNulls, "none", null, (name, t) => {
                this.emitLine("case ", name, "(", this.swiftType(t), ")");
            });
            if (maybeNull !== null) {
                this.emitLine("case ", this.nameForUnionMember(u, maybeNull));
            }
            if (!this._options.justTypes) {
                this.ensureBlankLine();
                this.emitBlockWithAccess("init(from decoder: Decoder) throws", () => {
                    this.emitLine("let container = try decoder.singleValueContainer()");
                    const boolMember = u.findMember("bool");
                    if (boolMember !== undefined)
                        renderUnionCase(boolMember);
                    const integerMember = u.findMember("integer");
                    if (integerMember !== undefined)
                        renderUnionCase(integerMember);
                    for (const t of nonNulls) {
                        if (t.kind === "bool" || t.kind === "integer")
                            continue;
                        renderUnionCase(t);
                    }
                    if (maybeNull !== null) {
                        this.emitBlock("if container.decodeNil()", () => {
                            this.emitLine("self = .", this.nameForUnionMember(u, maybeNull));
                            this.emitLine("return");
                        });
                    }
                    this.emitDecodingError(unionName);
                });
                this.ensureBlankLine();
                this.emitBlockWithAccess("func encode(to encoder: Encoder) throws", () => {
                    this.emitLine("var container = encoder.singleValueContainer()");
                    this.emitLine("switch self {");
                    this.forEachUnionMember(u, nonNulls, "none", null, (name, _) => {
                        this.emitLine("case .", name, "(let x):");
                        this.indent(() => this.emitLine("try container.encode(x)"));
                    });
                    if (maybeNull !== null) {
                        this.emitLine("case .", this.nameForUnionMember(u, maybeNull), ":");
                        this.indent(() => this.emitLine("try container.encodeNil()"));
                    }
                    this.emitLine("}");
                });
            }
        });
        this.endFile();
    }
    emitTopLevelMapAndArrayConvenienceInitializerExtensions(t, name) {
        let extensionSource;
        if (t instanceof ArrayType) {
            extensionSource = ["Array where Element == ", name, ".Element"];
        }
        else if (t instanceof MapType) {
            extensionSource = ["Dictionary where Key == String, Value == ", this.swiftType(t.values)];
        }
        else {
            return;
        }
        this.emitBlockWithAccess(["extension ", extensionSource], () => {
            this.emitBlock(["init(data: Data) throws"], () => {
                this.emitLine("self = try newJSONDecoder().decode(", name, ".self, from: data)");
            });
            this.ensureBlankLine();
            this.emitBlock("init(_ json: String, using encoding: String.Encoding = .utf8) throws", () => {
                this.emitBlock("guard let data = json.data(using: encoding) else", () => {
                    this.emitLine('throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)');
                });
                this.emitLine("try self.init(data: data)");
            });
            this.ensureBlankLine();
            this.emitBlock("init(fromURL url: URL) throws", () => {
                this.emitLine("try self.init(data: try Data(contentsOf: url))");
            });
            this.ensureBlankLine();
            this.emitBlock("func jsonData() throws -> Data", () => {
                this.emitLine("return try newJSONEncoder().encode(self)");
            });
            this.ensureBlankLine();
            this.emitBlock("func jsonString(encoding: String.Encoding = .utf8) throws -> String?", () => {
                this.emitLine("return String(data: try self.jsonData(), encoding: encoding)");
            });
        });
    }
    emitDecodingError(name) {
        this.emitLine("throw DecodingError.typeMismatch(", name, '.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for ', name, '"))');
    }
    emitConvenienceMutator(c, className) {
        this.emitLine("func with(");
        this.indent(() => {
            this.forEachClassProperty(c, "none", (name, _, p, position) => {
                this.emitLine(name, ": ", this.swiftPropertyType(p), "? = nil", position !== "only" && position !== "last" ? "," : "");
            });
        });
        this.emitBlock([") -> ", className], () => {
            this.emitLine("return ", className, "(");
            this.indent(() => {
                this.forEachClassProperty(c, "none", (name, _, _p, position) => {
                    this.emitLine(name, ": ", name, " ?? self.", name, position !== "only" && position !== "last" ? "," : "");
                });
            });
            this.emitLine(")");
        });
    }
    emitMark(line, horizontalLine = false) {
        this.emitLine("// MARK:", horizontalLine ? " - " : " ", line);
    }
    emitSourceStructure() {
        if (this._options.multiFileOutput === false) {
            this.renderSingleFileHeaderComments();
        }
        this.forEachNamedType("leading-and-interposing", (c, className) => this.renderClassDefinition(c, className), (e, enumName) => this.renderEnumDefinition(e, enumName), (u, unionName) => this.renderUnionDefinition(u, unionName));
        if (!this._options.justTypes) {
            this.emitSupportFunctions4();
        }
    }
    emitAlamofireExtension() {
        this.ensureBlankLine();
        this.emitBlockWithAccess("extension DataRequest", () => {
            this
                .emitMultiline(`fileprivate func decodableResponseSerializer<T: Decodable>() -> DataResponseSerializer<T> {
    return DataResponseSerializer { _, response, data, error in
        guard error == nil else { return .failure(error!) }
        
        guard let data = data else {
            return .failure(AFError.responseSerializationFailed(reason: .inputDataNil))
        }
        
        return Result { try newJSONDecoder().decode(T.self, from: data) }
    }
}

@discardableResult
fileprivate func responseDecodable<T: Decodable>(queue: DispatchQueue? = nil, completionHandler: @escaping (DataResponse<T>) -> Void) -> Self {
    return response(queue: queue, responseSerializer: decodableResponseSerializer(), completionHandler: completionHandler)
}`);
            this.ensureBlankLine();
            this.forEachTopLevel("leading-and-interposing", (_, name) => {
                this.emitLine("@discardableResult");
                this.emitBlock([
                    "func response",
                    name,
                    "(queue: DispatchQueue? = nil, completionHandler: @escaping (DataResponse<",
                    name,
                    ">) -> Void) -> Self"
                ], () => {
                    this.emitLine("return responseDecodable(queue: queue, completionHandler: completionHandler)");
                });
            });
        });
    }
}

const typeScriptEffectSchemaOptions = {
    justSchema: new BooleanOption("just-schema", "Schema only", false)
};
class TypeScriptEffectSchemaTargetLanguage extends TargetLanguage {
    getOptions() {
        return [];
    }
    constructor(displayName = "TypeScript Effect Schema", names = ["typescript-effect-schema"], extension = "ts") {
        super(displayName, names, extension);
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptEffectSchemaRenderer(this, renderContext, getOptionValues(typeScriptEffectSchemaOptions, untypedOptionValues));
    }
}
class TypeScriptEffectSchemaRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
        this.emittedObjects = new Set();
    }
    forbiddenNamesForGlobalNamespace() {
        return ["Class", "Date", "Object", "String", "Array", "JSON", "Error"];
    }
    nameStyle(original, upper) {
        const acronyms = acronymStyle(AcronymStyleOptions.Camel);
        const words = splitIntoWords(original);
        return combineWords(words, legalizeName$a, upper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, upper ? (s) => capitalize(acronyms(s)) : allLowerWordStyle, acronyms, "", isLetterOrUnderscore);
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("types", s => this.nameStyle(s, true));
    }
    makeUnionMemberNamer() {
        return funPrefixNamer("properties", s => this.nameStyle(s, true));
    }
    namerForObjectProperty() {
        return funPrefixNamer("properties", s => this.nameStyle(s, true));
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("enum-cases", s => this.nameStyle(s, false));
    }
    importStatement(lhs, moduleName) {
        return ["import ", lhs, " from ", moduleName, ";"];
    }
    emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("* as S", '"@effect/schema/Schema"'));
    }
    typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        return p.isOptional ? ["S.optional(", typeMap, ")"] : typeMap;
    }
    typeMapTypeFor(t, required = true) {
        if (t.kind === "class" || t.kind === "object" || t.kind === "enum") {
            const name = this.nameForNamedType(t);
            if (this.emittedObjects.has(name)) {
                return [name];
            }
            return ["S.suspend(() => ", name, ")"];
        }
        const match = matchType(t, _anyType => "S.Any", _nullType => "S.Null", _boolType => "S.Boolean", _integerType => "S.Number", _doubleType => "S.Number", _stringType => "S.String", arrayType => ["S.Array(", this.typeMapTypeFor(arrayType.items, false), ")"], _classType => panic("Should already be handled."), _mapType => ["S.Record(S.String, ", this.typeMapTypeFor(_mapType.values, false), ")"], _enumType => panic("Should already be handled."), unionType => {
            const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
            return ["S.Union(", ...collectionUtils.arrayIntercalate(", ", children), ")"];
        }, _transformedStringType => {
            return "S.String";
        });
        if (required) {
            return [match];
        }
        return match;
    }
    emitObject(name, t) {
        this.emittedObjects.add(name);
        this.ensureBlankLine();
        this.emitLine("\nexport class ", name, " extends S.Class<", name, '>("', name, '")({');
        this.indent(() => {
            this.forEachClassProperty(t, "none", (_, jsonName, property) => {
                this.emitLine(`"${utf16StringEscape(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
            });
        });
        this.emitLine("}) {}");
    }
    emitEnum(e, enumName) {
        this.emittedObjects.add(enumName);
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("\nexport const ", enumName, " = ", "S.Literal(");
        this.indent(() => this.forEachEnumCase(e, "none", (_, jsonName) => {
            this.emitLine('"', stringEscape$7(jsonName), '",');
        }));
        this.emitLine(");");
        if (!this._options.justSchema) {
            this.emitLine("export type ", enumName, " = S.Schema.Type<typeof ", enumName, ">;");
        }
    }
    walkObjectNames(objectType) {
        const names = [];
        const recurse = (type) => {
            if (type.kind === "object" || type.kind === "class") {
                names.push(this.nameForNamedType(type));
                this.forEachClassProperty(type, "none", (_, __, prop) => {
                    recurse(prop.type);
                });
            }
            else if (type instanceof ArrayType) {
                recurse(type.items);
            }
            else if (type instanceof MapType) {
                recurse(type.values);
            }
            else if (type instanceof EnumType) {
                for (const t of type.getChildren()) {
                    recurse(t);
                }
            }
        };
        this.forEachClassProperty(objectType, "none", (_, __, prop) => {
            recurse(prop.type);
        });
        return names;
    }
    emitSchemas() {
        this.ensureBlankLine();
        this.forEachEnum("leading-and-interposing", (u, enumName) => {
            this.emitEnum(u, enumName);
        });
        const order = [];
        const mapKey = [];
        const mapValue = [];
        this.forEachObject("none", (type, name) => {
            mapKey.push(name);
            mapValue.push(type);
        });
        mapKey.forEach((_, index) => {
            // assume first
            let ordinal = 0;
            // pull out all names
            const source = mapValue[index];
            const names = this.walkObjectNames(source);
            // must be behind all these names
            names.forEach(name => {
                const depName = name;
                // find this name's ordinal, if it has already been added
                order.forEach(orderItem => {
                    const depIndex = orderItem;
                    if (mapKey[depIndex] === depName) {
                        // this is the index of the dependency, so make sure we come after it
                        ordinal = Math.max(ordinal, depIndex + 1);
                    }
                });
            });
            // insert index
            order.splice(ordinal, 0, index);
        });
        // now emit ordered source
        order.forEach(i => this.emitGatheredSource(this.gatherSource(() => this.emitObject(mapKey[i], mapValue[i]))));
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        this.emitImports();
        this.emitSchemas();
    }
}

const tsFlowOptions = Object.assign({}, javaScriptOptions, {
    justTypes: new BooleanOption("just-types", "Interfaces only", false),
    nicePropertyNames: new BooleanOption("nice-property-names", "Transform property names to be JavaScripty", false),
    declareUnions: new BooleanOption("explicit-unions", "Explicitly name unions", false),
    preferUnions: new BooleanOption("prefer-unions", "Use union type instead of enum", false),
    preferTypes: new BooleanOption("prefer-types", "Use types instead of interfaces", false),
    preferConstValues: new BooleanOption("prefer-const-values", "Use string instead of enum for string enums with single value", false),
    readonly: new BooleanOption("readonly", "Use readonly type members", false)
});
const tsFlowTypeAnnotations = {
    any: ": any",
    anyArray: ": any[]",
    anyMap: ": { [k: string]: any }",
    string: ": string",
    stringArray: ": string[]",
    boolean: ": boolean"
};
class TypeScriptFlowBaseTargetLanguage extends JavaScriptTargetLanguage {
    getOptions() {
        return [
            tsFlowOptions.justTypes,
            tsFlowOptions.nicePropertyNames,
            tsFlowOptions.declareUnions,
            tsFlowOptions.runtimeTypecheck,
            tsFlowOptions.runtimeTypecheckIgnoreUnknownProperties,
            tsFlowOptions.acronymStyle,
            tsFlowOptions.converters,
            tsFlowOptions.rawType,
            tsFlowOptions.preferUnions,
            tsFlowOptions.preferTypes,
            tsFlowOptions.preferConstValues,
            tsFlowOptions.readonly
        ];
    }
    get supportsOptionalClassProperties() {
        return true;
    }
}
class TypeScriptTargetLanguage extends TypeScriptFlowBaseTargetLanguage {
    constructor() {
        super("TypeScript", ["typescript", "ts", "tsx"], "ts");
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptRenderer(this, renderContext, getOptionValues(tsFlowOptions, untypedOptionValues));
    }
}
function quotePropertyName(original) {
    const escaped = utf16StringEscape(original);
    const quoted = `"${escaped}"`;
    if (original.length === 0) {
        return quoted;
    }
    else if (!isES3IdentifierStart(original.codePointAt(0))) {
        return quoted;
    }
    else if (escaped !== original) {
        return quoted;
    }
    else if (legalizeName$a(original) !== original) {
        return quoted;
    }
    else {
        return original;
    }
}
class TypeScriptFlowBaseRenderer extends JavaScriptRenderer {
    constructor(targetLanguage, renderContext, _tsFlowOptions) {
        super(targetLanguage, renderContext, _tsFlowOptions);
        this._tsFlowOptions = _tsFlowOptions;
    }
    namerForObjectProperty() {
        if (this._tsFlowOptions.nicePropertyNames) {
            return funPrefixNamer("properties", s => this.nameStyle(s, false));
        }
        else {
            return super.namerForObjectProperty();
        }
    }
    sourceFor(t) {
        if (this._tsFlowOptions.preferConstValues && t.kind === "enum" && t instanceof EnumType && t.cases.size === 1) {
            const item = t.cases.values().next().value;
            return singleWord(`"${utf16StringEscape(item)}"`);
        }
        if (["class", "object", "enum"].includes(t.kind)) {
            return singleWord(this.nameForNamedType(t));
        }
        return matchType(t, _anyType => singleWord("any"), _nullType => singleWord("null"), _boolType => singleWord("boolean"), _integerType => singleWord("number"), _doubleType => singleWord("number"), _stringType => singleWord("string"), arrayType => {
            const itemType = this.sourceFor(arrayType.items);
            if ((arrayType.items instanceof UnionType && !this._tsFlowOptions.declareUnions) ||
                arrayType.items instanceof ArrayType) {
                return singleWord(["Array<", itemType.source, ">"]);
            }
            else {
                return singleWord([parenIfNeeded(itemType), "[]"]);
            }
        }, _classType => panic("We handled this above"), mapType => singleWord(["{ [key: string]: ", this.sourceFor(mapType.values).source, " }"]), _enumType => panic("We handled this above"), unionType => {
            if (!this._tsFlowOptions.declareUnions || nullableFromUnion(unionType) !== null) {
                const children = Array.from(unionType.getChildren()).map(c => parenIfNeeded(this.sourceFor(c)));
                return multiWord(" | ", ...children);
            }
            else {
                return singleWord(this.nameForNamedType(unionType));
            }
        }, transformedStringType => {
            if (transformedStringType.kind === "date-time") {
                return singleWord("Date");
            }
            return singleWord("string");
        });
    }
    emitClassBlockBody(c) {
        this.emitPropertyTable(c, (name, _jsonName, p) => {
            const t = p.type;
            let propertyName = name;
            propertyName = modifySource(quotePropertyName, name);
            if (this._tsFlowOptions.readonly) {
                propertyName = modifySource(_propertyName => "readonly " + _propertyName, propertyName);
            }
            return [
                [propertyName, p.isOptional ? "?" : "", ": "],
                [this.sourceFor(t).source, ";"]
            ];
        });
        const additionalProperties = c.getAdditionalProperties();
        if (additionalProperties) {
            this.emitTable([["[property: string]", ": ", this.sourceFor(additionalProperties).source, ";"]]);
        }
    }
    emitClass(c, className) {
        this.emitDescription(this.descriptionForType(c));
        this.emitClassBlock(c, className);
    }
    emitUnion(u, unionName) {
        if (!this._tsFlowOptions.declareUnions) {
            return;
        }
        this.emitDescription(this.descriptionForType(u));
        const children = multiWord(" | ", ...Array.from(u.getChildren()).map(c => parenIfNeeded(this.sourceFor(c))));
        this.emitLine("export type ", unionName, " = ", children.source, ";");
    }
    emitTypes() {
        // emit primitive top levels
        this.forEachTopLevel("none", (t, name) => {
            if (!t.isPrimitive()) {
                return;
            }
            this.ensureBlankLine();
            this.emitDescription(this.descriptionForType(t));
            this.emitLine("type ", name, " = ", this.sourceFor(t).source, ";");
        });
        this.forEachNamedType("leading-and-interposing", (c, n) => this.emitClass(c, n), (e, n) => this.emitEnum(e, n), (u, n) => this.emitUnion(u, n));
    }
    emitUsageComments() {
        if (this._tsFlowOptions.justTypes)
            return;
        super.emitUsageComments();
    }
    deserializerFunctionLine(t, name) {
        const jsonType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["function to", name, "(json: ", jsonType, "): ", this.sourceFor(t).source];
    }
    serializerFunctionLine(t, name) {
        const camelCaseName = modifySource(camelCase, name);
        const returnType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["function ", camelCaseName, "ToJson(value: ", this.sourceFor(t).source, "): ", returnType];
    }
    get moduleLine() {
        return undefined;
    }
    get castFunctionLines() {
        return ["function cast<T>(val: any, typ: any): T", "function uncast<T>(val: T, typ: any): any"];
    }
    get typeAnnotations() {
        throw new Error("not implemented");
    }
    emitConvertModule() {
        if (this._tsFlowOptions.justTypes)
            return;
        super.emitConvertModule();
    }
    emitConvertModuleHelpers() {
        if (this._tsFlowOptions.justTypes)
            return;
        super.emitConvertModuleHelpers();
    }
    emitModuleExports() {
        if (this._tsFlowOptions.justTypes) {
            return;
        }
        else {
            super.emitModuleExports();
        }
    }
}
class TypeScriptRenderer extends TypeScriptFlowBaseRenderer {
    forbiddenNamesForGlobalNamespace() {
        return ["Array", "Date"];
    }
    deserializerFunctionLine(t, name) {
        const jsonType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["public static to", name, "(json: ", jsonType, "): ", this.sourceFor(t).source];
    }
    serializerFunctionLine(t, name) {
        const camelCaseName = modifySource(camelCase, name);
        const returnType = this._tsFlowOptions.rawType === "json" ? "string" : "any";
        return ["public static ", camelCaseName, "ToJson(value: ", this.sourceFor(t).source, "): ", returnType];
    }
    get moduleLine() {
        return "export class Convert";
    }
    get typeAnnotations() {
        return Object.assign({ never: ": never" }, tsFlowTypeAnnotations);
    }
    emitModuleExports() {
        return;
    }
    emitUsageImportComment() {
        const topLevelNames = [];
        this.forEachTopLevel("none", (_t, name) => {
            topLevelNames.push(", ", name);
        }, isNamedType);
        this.emitLine("//   import { Convert", topLevelNames, ' } from "./file";');
    }
    emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        // enums with only one value are emitted as constants
        if (this._tsFlowOptions.preferConstValues && e.cases.size === 1)
            return;
        if (this._tsFlowOptions.preferUnions) {
            let items = "";
            e.cases.forEach(item => {
                if (items === "") {
                    items += `"${utf16StringEscape(item)}"`;
                    return;
                }
                items += ` | "${utf16StringEscape(item)}"`;
            });
            this.emitLine("export type ", enumName, " = ", items, ";");
        }
        else {
            this.emitBlock(["export enum ", enumName, " "], "", () => {
                this.forEachEnumCase(e, "none", (name, jsonName) => {
                    this.emitLine(name, ` = "${utf16StringEscape(jsonName)}",`);
                });
            });
        }
    }
    emitClassBlock(c, className) {
        this.emitBlock(this._tsFlowOptions.preferTypes
            ? ["export type ", className, " = "]
            : ["export interface ", className, " "], "", () => {
            this.emitClassBlockBody(c);
        });
    }
    emitSourceStructure() {
        super.emitSourceStructure();
    }
}
class FlowTargetLanguage extends TypeScriptFlowBaseTargetLanguage {
    constructor() {
        super("Flow", ["flow"], "js");
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new FlowRenderer(this, renderContext, getOptionValues(tsFlowOptions, untypedOptionValues));
    }
}
class FlowRenderer extends TypeScriptFlowBaseRenderer {
    forbiddenNamesForGlobalNamespace() {
        return ["Class", "Date", "Object", "String", "Array", "JSON", "Error"];
    }
    get typeAnnotations() {
        return Object.assign({ never: "" }, tsFlowTypeAnnotations);
    }
    emitEnum(e, enumName) {
        this.emitDescription(this.descriptionForType(e));
        const lines = [];
        this.forEachEnumCase(e, "none", (_, jsonName) => {
            const maybeOr = lines.length === 0 ? "  " : "| ";
            lines.push([maybeOr, '"', utf16StringEscape(jsonName), '"']);
        });
        defined(lines[lines.length - 1]).push(";");
        this.emitLine("export type ", enumName, " =");
        this.indent(() => {
            for (const line of lines) {
                this.emitLine(line);
            }
        });
    }
    emitClassBlock(c, className) {
        this.emitBlock(["export type ", className, " = "], ";", () => {
            this.emitClassBlockBody(c);
        });
    }
    emitSourceStructure() {
        this.emitLine("// @flow");
        this.ensureBlankLine();
        super.emitSourceStructure();
    }
}

const typeScriptZodOptions = {
    justSchema: new BooleanOption("just-schema", "Schema only", false)
};
class TypeScriptZodTargetLanguage extends TargetLanguage {
    getOptions() {
        return [];
    }
    constructor(displayName = "TypeScript Zod", names = ["typescript-zod"], extension = "ts") {
        super(displayName, names, extension);
    }
    get stringTypeMapping() {
        const mapping = new Map();
        const dateTimeType = "date-time";
        mapping.set("date-time", dateTimeType);
        return mapping;
    }
    get supportsOptionalClassProperties() {
        return true;
    }
    makeRenderer(renderContext, untypedOptionValues) {
        return new TypeScriptZodRenderer(this, renderContext, getOptionValues(typeScriptZodOptions, untypedOptionValues));
    }
}
class TypeScriptZodRenderer extends ConvenienceRenderer {
    constructor(targetLanguage, renderContext, _options) {
        super(targetLanguage, renderContext);
        this._options = _options;
    }
    forbiddenNamesForGlobalNamespace() {
        return ["Class", "Date", "Object", "String", "Array", "JSON", "Error"];
    }
    nameStyle(original, upper) {
        const acronyms = acronymStyle(AcronymStyleOptions.Camel);
        const words = splitIntoWords(original);
        return combineWords(words, legalizeName$a, upper ? firstUpperWordStyle : allLowerWordStyle, firstUpperWordStyle, upper ? (s) => capitalize(acronyms(s)) : allLowerWordStyle, acronyms, "", isLetterOrUnderscore);
    }
    makeNamedTypeNamer() {
        return funPrefixNamer("types", s => this.nameStyle(s, true));
    }
    makeUnionMemberNamer() {
        return funPrefixNamer("properties", s => this.nameStyle(s, true));
    }
    namerForObjectProperty() {
        return funPrefixNamer("properties", s => this.nameStyle(s, true));
    }
    makeEnumCaseNamer() {
        return funPrefixNamer("enum-cases", s => this.nameStyle(s, false));
    }
    importStatement(lhs, moduleName) {
        return ["import ", lhs, " from ", moduleName, ";"];
    }
    emitImports() {
        this.ensureBlankLine();
        this.emitLine(this.importStatement("* as z", '"zod"'));
    }
    typeMapTypeForProperty(p) {
        const typeMap = this.typeMapTypeFor(p.type);
        return p.isOptional ? [typeMap, ".optional()"] : typeMap;
    }
    typeMapTypeFor(t, required = true) {
        if (["class", "object", "enum"].includes(t.kind)) {
            return [this.nameForNamedType(t), "Schema"];
        }
        const match = matchType(t, _anyType => "z.any()", _nullType => "z.null()", _boolType => "z.boolean()", _integerType => "z.number()", _doubleType => "z.number()", _stringType => "z.string()", arrayType => ["z.array(", this.typeMapTypeFor(arrayType.items, false), ")"], _classType => panic("Should already be handled."), _mapType => ["z.record(z.string(), ", this.typeMapTypeFor(_mapType.values, false), ")"], _enumType => panic("Should already be handled."), unionType => {
            const children = Array.from(unionType.getChildren()).map((type) => this.typeMapTypeFor(type, false));
            return ["z.union([", ...collectionUtils.arrayIntercalate(", ", children), "])"];
        }, _transformedStringType => {
            if (_transformedStringType.kind === "date-time") {
                return "z.coerce.date()";
            }
            return "z.string()";
        });
        if (required) {
            return [match];
        }
        return match;
    }
    emitObject(name, t) {
        this.ensureBlankLine();
        this.emitLine("\nexport const ", name, "Schema = ", "z.object({");
        this.indent(() => {
            this.forEachClassProperty(t, "none", (_, jsonName, property) => {
                this.emitLine(`"${utf16StringEscape(jsonName)}"`, ": ", this.typeMapTypeForProperty(property), ",");
            });
        });
        this.emitLine("});");
        if (!this._options.justSchema) {
            this.emitLine("export type ", name, " = z.infer<typeof ", name, "Schema>;");
        }
    }
    emitEnum(e, enumName) {
        this.ensureBlankLine();
        this.emitDescription(this.descriptionForType(e));
        this.emitLine("\nexport const ", enumName, "Schema = ", "z.enum([");
        this.indent(() => this.forEachEnumCase(e, "none", (_, jsonName) => {
            this.emitLine('"', stringEscape$7(jsonName), '",');
        }));
        this.emitLine("]);");
        if (!this._options.justSchema) {
            this.emitLine("export type ", enumName, " = z.infer<typeof ", enumName, "Schema>;");
        }
    }
    /** Static function that extracts underlying type refs for types that form part of the
     * definition of the passed type - used to ensure that these appear in generated source
     * before types that reference them.
     *
     * Primitive types don't need defining and enums are output before other types, hence,
     * these are ignored.
     */
    static extractUnderlyingTyperefs(type) {
        let typeRefs = [];
        // Ignore enums and primitives
        if (!type.isPrimitive() && type.kind != "enum") {
            // need to extract constituent types for unions and intersections (which both extend SetOperationType)
            // and can ignore the union/intersection itself
            if (type instanceof SetOperationType) {
                type.members.forEach(member => {
                    // recurse as the underlying type could itself be a union, instersection or array etc.
                    typeRefs.push(...TypeScriptZodRenderer.extractUnderlyingTyperefs(member));
                });
            }
            // need to extract additional properties for object, class and map types (which all extend ObjectType)
            if (type instanceof ObjectType) {
                const addType = type.getAdditionalProperties();
                if (addType) {
                    // recurse as the underlying type could itself be a union, instersection or array etc.
                    typeRefs.push(...TypeScriptZodRenderer.extractUnderlyingTyperefs(addType));
                }
            }
            // need to extract items types for ArrayType
            if (type instanceof ArrayType) {
                const itemsType = type.items;
                if (itemsType) {
                    // recurse as the underlying type could itself be a union, instersection or array etc.
                    typeRefs.push(...TypeScriptZodRenderer.extractUnderlyingTyperefs(itemsType));
                }
            }
            // Finally return the reference to a class as that will need to be defined (where objects, maps, unions, intersections and arrays do not)
            if (type instanceof ClassType) {
                typeRefs.push(type.typeRef);
            }
        }
        return typeRefs;
    }
    emitSchemas() {
        this.ensureBlankLine();
        this.forEachEnum("leading-and-interposing", (u, enumName) => {
            this.emitEnum(u, enumName);
        });
        // All children must be defined before this type to avoid forward references in generated code
        // Build a model that will tell us if a referenced type has been defined then make multiple
        // passes over the defined objects to put them into the correct order for output in the
        // generated sourcecode
        const order = [];
        const mapType = [];
        const mapTypeRef = [];
        const mapName = [];
        const mapChildTypeRefs = [];
        this.forEachObject("none", (type, name) => {
            mapType.push(type);
            mapTypeRef.push(type.typeRef);
            mapName.push(name);
            const children = type.getChildren();
            let childTypeRefs = [];
            children.forEach(child => {
                childTypeRefs = childTypeRefs.concat(TypeScriptZodRenderer.extractUnderlyingTyperefs(child));
            });
            mapChildTypeRefs.push(childTypeRefs);
        });
        // Items to process on this pass
        let indices = [];
        mapType.forEach((_, index) => {
            indices.push(index);
        });
        // items to process on the next pass
        let deferredIndices = [];
        // defensive: make sure we don't loop forever, even complex sets shouldn't require many passes
        const MAX_PASSES = 999;
        let passNum = 0;
        do {
            indices.forEach(index => {
                // must be behind all these children
                const childTypeRefs = mapChildTypeRefs[index];
                let foundAllChildren = true;
                childTypeRefs.forEach(childRef => {
                    // defensive: first check if there is a definition for the referenced type (there should be)
                    if (mapTypeRef.includes(childRef)) {
                        let found = false;
                        // find this childs's ordinal, if it has already been added
                        // faster to go through what we've defined so far than all definitions
                        // FIXME: refactor this
                        // eslint-disable-next-line @typescript-eslint/prefer-for-of
                        for (let j = 0; j < order.length; j++) {
                            const childIndex = order[j];
                            if (mapTypeRef[childIndex] === childRef) {
                                found = true;
                                break;
                            }
                        }
                        foundAllChildren = foundAllChildren && found;
                    }
                    else {
                        console.error("A child type reference was not found amongst all Object definitions! TypeRef: " + childRef);
                    }
                });
                if (foundAllChildren) {
                    // insert index into order as we are safe to define this type
                    order.push(index);
                }
                else {
                    // defer to a subsequent pass as we need to define other types
                    deferredIndices.push(index);
                }
            });
            indices = deferredIndices;
            deferredIndices = [];
            passNum++;
            if (passNum > MAX_PASSES) {
                // giving up
                order.push(...deferredIndices);
                console.warn("Exceeded maximum number of passes when determining output order, output may contain forward references");
            }
        } while (indices.length > 0 && passNum <= MAX_PASSES);
        // now emit ordered source
        order.forEach(i => this.emitGatheredSource(this.gatherSource(() => this.emitObject(mapName[i], mapType[i]))));
    }
    emitSourceStructure() {
        if (this.leadingComments !== undefined) {
            this.emitComments(this.leadingComments);
        }
        this.emitImports();
        this.emitSchemas();
    }
}

const all = [
    new CSharpTargetLanguage(),
    new GoTargetLanguage(),
    new RustTargetLanguage(),
    new CrystalTargetLanguage(),
    new CJSONTargetLanguage(),
    new CPlusPlusTargetLanguage(),
    new ObjectiveCTargetLanguage(),
    new JavaTargetLanguage(),
    new TypeScriptTargetLanguage(),
    new JavaScriptTargetLanguage(),
    new JavaScriptPropTypesTargetLanguage(),
    new FlowTargetLanguage(),
    new SwiftTargetLanguage(),
    new Scala3TargetLanguage(),
    new SmithyTargetLanguage(),
    new KotlinTargetLanguage(),
    new ElmTargetLanguage(),
    new JSONSchemaTargetLanguage(),
    new RubyTargetLanguage(),
    new DartTargetLanguage(),
    new PythonTargetLanguage("Python", ["python", "py"], "py"),
    new PikeTargetLanguage(),
    new HaskellTargetLanguage(),
    new TypeScriptZodTargetLanguage(),
    new TypeScriptEffectSchemaTargetLanguage(),
    new ElixirTargetLanguage(),
    new PhpTargetLanguage()
];
function languageNamed(name, targetLanguages) {
    if (targetLanguages === undefined) {
        targetLanguages = all;
    }
    const maybeTargetLanguage = collectionUtils.iterableFind(targetLanguages, l => l.names.includes(name) || l.displayName === name);
    if (maybeTargetLanguage !== undefined)
        return maybeTargetLanguage;
    return collectionUtils.iterableFind(targetLanguages, l => l.extension === name);
}

var Tag;
(function (Tag) {
    Tag[Tag["Null"] = 1] = "Null";
    Tag[Tag["False"] = 2] = "False";
    Tag[Tag["True"] = 3] = "True";
    Tag[Tag["Integer"] = 4] = "Integer";
    Tag[Tag["Double"] = 5] = "Double";
    Tag[Tag["InternedString"] = 6] = "InternedString";
    Tag[Tag["UninternedString"] = 7] = "UninternedString";
    Tag[Tag["Object"] = 8] = "Object";
    Tag[Tag["Array"] = 9] = "Array";
    Tag[Tag["StringFormat"] = 10] = "StringFormat";
    Tag[Tag["TransformedString"] = 11] = "TransformedString";
})(Tag || (Tag = {}));
const TAG_BITS = 4;
const TAG_MASK = (1 << TAG_BITS) - 1;
function makeValue(t, index) {
    return t | (index << TAG_BITS);
}
function getIndex(v, tag) {
    assert(valueTag(v) === tag, "Trying to get index for value with invalid tag");
    return v >> TAG_BITS;
}
function valueTag(v) {
    return v & TAG_MASK;
}
class CompressedJSON {
    constructor(dateTimeRecognizer, handleRefs) {
        this.dateTimeRecognizer = dateTimeRecognizer;
        this.handleRefs = handleRefs;
        this._contextStack = [];
        this._strings = [];
        this._stringIndexes = {};
        this._objects = [];
        this._arrays = [];
        this.getObjectForValue = (v) => {
            return this._objects[getIndex(v, Tag.Object)];
        };
        this.getArrayForValue = (v) => {
            return this._arrays[getIndex(v, Tag.Array)];
        };
        this.internArray = (arr) => {
            const index = this._arrays.length;
            this._arrays.push(arr);
            return makeValue(Tag.Array, index);
        };
    }
    parseSync(_input) {
        return panic("parseSync not implemented in CompressedJSON");
    }
    getStringForValue(v) {
        const tag = valueTag(v);
        assert(tag === Tag.InternedString || tag === Tag.TransformedString);
        return this._strings[getIndex(v, tag)];
    }
    getStringFormatTypeKind(v) {
        const kind = this._strings[getIndex(v, Tag.StringFormat)];
        if (!isPrimitiveStringTypeKind(kind) || kind === "string") {
            return panic("Not a transformed string type kind");
        }
        return kind;
    }
    get context() {
        return defined(this._ctx);
    }
    internString(s) {
        if (Object.prototype.hasOwnProperty.call(this._stringIndexes, s)) {
            return this._stringIndexes[s];
        }
        const index = this._strings.length;
        this._strings.push(s);
        this._stringIndexes[s] = index;
        return index;
    }
    makeString(s) {
        const value = makeValue(Tag.InternedString, this.internString(s));
        assert(typeof value === "number", `Interned string value is not a number: ${value}`);
        return value;
    }
    internObject(obj) {
        const index = this._objects.length;
        this._objects.push(obj);
        return makeValue(Tag.Object, index);
    }
    get isExpectingRef() {
        return this._ctx !== undefined && this._ctx.currentKey === "$ref";
    }
    commitValue(value) {
        assert(typeof value === "number", `CompressedJSON value is not a number: ${value}`);
        if (this._ctx === undefined) {
            assert(this._rootValue === undefined, "Committing value but nowhere to commit to - root value still there.");
            this._rootValue = value;
        }
        else if (this._ctx.currentObject !== undefined) {
            if (this._ctx.currentKey === undefined) {
                return panic("Must have key and can't have string when committing");
            }
            this._ctx.currentObject.push(this.makeString(this._ctx.currentKey), value);
            this._ctx.currentKey = undefined;
        }
        else if (this._ctx.currentArray !== undefined) {
            this._ctx.currentArray.push(value);
        }
        else {
            return panic("Committing value but nowhere to commit to");
        }
    }
    commitNull() {
        this.commitValue(makeValue(Tag.Null, 0));
    }
    commitBoolean(v) {
        this.commitValue(makeValue(v ? Tag.True : Tag.False, 0));
    }
    commitNumber(isDouble) {
        const numberTag = isDouble ? Tag.Double : Tag.Integer;
        this.commitValue(makeValue(numberTag, 0));
    }
    commitString(s) {
        let value = undefined;
        if (this.handleRefs && this.isExpectingRef) {
            value = this.makeString(s);
        }
        else {
            const format = inferTransformedStringTypeKindForString(s, this.dateTimeRecognizer);
            if (format !== undefined) {
                if (defined(transformedStringTypeTargetTypeKindsMap.get(format)).attributesProducer !== undefined) {
                    value = makeValue(Tag.TransformedString, this.internString(s));
                }
                else {
                    value = makeValue(Tag.StringFormat, this.internString(format));
                }
            }
            else if (s.length <= 64) {
                value = this.makeString(s);
            }
            else {
                value = makeValue(Tag.UninternedString, 0);
            }
        }
        this.commitValue(value);
    }
    finish() {
        const value = this._rootValue;
        if (value === undefined) {
            return panic("Finished without root document");
        }
        assert(this._ctx === undefined && this._contextStack.length === 0, "Finished with contexts present");
        this._rootValue = undefined;
        return value;
    }
    pushContext() {
        if (this._ctx !== undefined) {
            this._contextStack.push(this._ctx);
        }
        this._ctx = {
            currentObject: undefined,
            currentArray: undefined,
            currentKey: undefined,
            currentNumberIsDouble: false
        };
    }
    pushObjectContext() {
        this.pushContext();
        defined(this._ctx).currentObject = [];
    }
    setPropertyKey(key) {
        const ctx = this.context;
        ctx.currentKey = key;
    }
    finishObject() {
        const obj = this.context.currentObject;
        if (obj === undefined) {
            return panic("Object ended but not started");
        }
        this.popContext();
        this.commitValue(this.internObject(obj));
    }
    pushArrayContext() {
        this.pushContext();
        defined(this._ctx).currentArray = [];
    }
    finishArray() {
        const arr = this.context.currentArray;
        if (arr === undefined) {
            return panic("Array ended but not started");
        }
        this.popContext();
        this.commitValue(this.internArray(arr));
    }
    popContext() {
        assert(this._ctx !== undefined, "Popping context when there isn't one");
        this._ctx = this._contextStack.pop();
    }
    equals(other) {
        return this === other;
    }
    hashCode() {
        let hashAccumulator = collectionUtils.hashCodeInit;
        for (const s of this._strings) {
            hashAccumulator = collectionUtils.addHashCode(hashAccumulator, collectionUtils.hashString(s));
        }
        for (const s of Object.getOwnPropertyNames(this._stringIndexes).sort()) {
            hashAccumulator = collectionUtils.addHashCode(hashAccumulator, collectionUtils.hashString(s));
            hashAccumulator = collectionUtils.addHashCode(hashAccumulator, this._stringIndexes[s]);
        }
        for (const o of this._objects) {
            for (const v of o) {
                hashAccumulator = collectionUtils.addHashCode(hashAccumulator, v);
            }
        }
        for (const o of this._arrays) {
            for (const v of o) {
                hashAccumulator = collectionUtils.addHashCode(hashAccumulator, v);
            }
        }
        return hashAccumulator;
    }
}
class CompressedJSONFromString extends CompressedJSON {
    parse(input) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.parseSync(input);
        });
    }
    parseSync(input) {
        const json = JSON.parse(input);
        this.process(json);
        return this.finish();
    }
    process(json) {
        if (json === null) {
            this.commitNull();
        }
        else if (typeof json === "boolean") {
            this.commitBoolean(json);
        }
        else if (typeof json === "string") {
            this.commitString(json);
        }
        else if (typeof json === "number") {
            const isDouble = json !== Math.floor(json) || json < Number.MIN_SAFE_INTEGER || json > Number.MAX_SAFE_INTEGER;
            this.commitNumber(isDouble);
        }
        else if (Array.isArray(json)) {
            this.pushArrayContext();
            for (const v of json) {
                this.process(v);
            }
            this.finishArray();
        }
        else if (typeof json === "object") {
            this.pushObjectContext();
            for (const key of Object.getOwnPropertyNames(json)) {
                this.setPropertyKey(key);
                this.process(json[key]);
            }
            this.finishObject();
        }
        else {
            return panic("Invalid JSON object");
        }
    }
}

function addAttributes(accumulatorAttributes, newAttributes) {
    if (accumulatorAttributes === undefined)
        return newAttributes;
    return combineTypeAttributes("union", accumulatorAttributes, newAttributes);
}
function setAttributes(attributeMap, kind, newAttributes) {
    attributeMap.set(kind, addAttributes(attributeMap.get(kind), newAttributes));
}
function addAttributesToBuilder(builder, kind, newAttributes) {
    let arr = builder.get(kind);
    if (arr === undefined) {
        arr = [];
        builder.set(kind, arr);
    }
    arr.push(newAttributes);
}
function buildTypeAttributeMap(builder) {
    return collectionUtils.mapMap(builder, arr => combineTypeAttributes("union", arr));
}
function moveAttributes(map, fromKind, toKind) {
    const fromAttributes = defined(map.get(fromKind));
    map.delete(fromKind);
    setAttributes(map, toKind, fromAttributes);
}
class UnionAccumulator {
    constructor(_conflateNumbers) {
        this._conflateNumbers = _conflateNumbers;
        this._nonStringTypeAttributes = new Map();
        this._stringTypeAttributes = new Map();
        this.arrayData = [];
        this.objectData = [];
        this._enumCases = new Set();
        this._lostTypeAttributes = false;
    }
    have(kind) {
        return (this._nonStringTypeAttributes.has(kind) || this._stringTypeAttributes.has(kind));
    }
    addNone(_attributes) {
        // FIXME: Add them to all members?  Or add them to the union, which means we'd have
        // to change getMemberKinds() to also return the attributes for the union itself,
        // or add a new method that does that.
        this._lostTypeAttributes = true;
    }
    addAny(attributes) {
        addAttributesToBuilder(this._nonStringTypeAttributes, "any", attributes);
        this._lostTypeAttributes = true;
    }
    addPrimitive(kind, attributes) {
        assert(kind !== "any", "any must be added with addAny");
        addAttributesToBuilder(this._nonStringTypeAttributes, kind, attributes);
    }
    addFullStringType(attributes, stringTypes) {
        let stringTypesAttributes = undefined;
        if (stringTypes === undefined) {
            stringTypes = stringTypesTypeAttributeKind.tryGetInAttributes(attributes);
        }
        else {
            stringTypesAttributes = stringTypesTypeAttributeKind.makeAttributes(stringTypes);
        }
        if (stringTypes === undefined) {
            stringTypes = StringTypes.unrestricted;
            stringTypesAttributes = stringTypesTypeAttributeKind.makeAttributes(stringTypes);
        }
        const maybeEnumAttributes = this._nonStringTypeAttributes.get("enum");
        if (stringTypes.isRestricted) {
            assert(maybeEnumAttributes === undefined, "We can't add both an enum as well as a restricted string type to a union builder");
        }
        addAttributesToBuilder(this._stringTypeAttributes, "string", attributes);
        if (stringTypesAttributes !== undefined) {
            addAttributesToBuilder(this._stringTypeAttributes, "string", stringTypesAttributes);
        }
    }
    addStringType(kind, attributes, stringTypes) {
        if (kind === "string") {
            this.addFullStringType(attributes, stringTypes);
            return;
        }
        addAttributesToBuilder(this._stringTypeAttributes, kind, attributes);
        if (stringTypes !== undefined) {
            addAttributesToBuilder(this._stringTypeAttributes, kind, stringTypesTypeAttributeKind.makeAttributes(stringTypes));
        }
    }
    addArray(t, attributes) {
        this.arrayData.push(t);
        addAttributesToBuilder(this._nonStringTypeAttributes, "array", attributes);
    }
    addObject(t, attributes) {
        this.objectData.push(t);
        addAttributesToBuilder(this._nonStringTypeAttributes, "object", attributes);
    }
    addEnum(cases, attributes) {
        const maybeStringAttributes = this._stringTypeAttributes.get("string");
        if (maybeStringAttributes !== undefined) {
            addAttributesToBuilder(this._stringTypeAttributes, "string", attributes);
            return;
        }
        addAttributesToBuilder(this._nonStringTypeAttributes, "enum", attributes);
        collectionUtils.setUnionInto(this._enumCases, cases);
    }
    addStringCases(cases, attributes) {
        this.addFullStringType(attributes, StringTypes.fromCases(cases));
    }
    addStringCase(s, count, attributes) {
        this.addFullStringType(attributes, StringTypes.fromCase(s, count));
    }
    get enumCases() {
        return this._enumCases;
    }
    getMemberKinds() {
        assert(!(this.have("enum") && this.have("string")), "We can't have both strings and enums in the same union");
        let merged = collectionUtils.mapMerge(buildTypeAttributeMap(this._nonStringTypeAttributes), buildTypeAttributeMap(this._stringTypeAttributes));
        if (merged.size === 0) {
            return new Map([["none", emptyTypeAttributes]]);
        }
        if (this._nonStringTypeAttributes.has("any")) {
            assert(this._lostTypeAttributes, "This had to be set when we added 'any'");
            const allAttributes = combineTypeAttributes("union", Array.from(merged.values()));
            return new Map([["any", allAttributes]]);
        }
        if (this._conflateNumbers && this.have("integer") && this.have("double")) {
            moveAttributes(merged, "integer", "double");
        }
        if (this.have("map")) {
            moveAttributes(merged, "map", "class");
        }
        return merged;
    }
    get lostTypeAttributes() {
        return this._lostTypeAttributes;
    }
}
class FauxUnion {
    getAttributes() {
        return emptyTypeAttributes;
    }
}
function attributesForTypes$1(types) {
    // These two maps are the reverse of each other.  unionsForType is all the unions
    // that are ancestors of that type, when going from one of the given types, only
    // following unions.
    const unionsForType = new Map();
    const typesForUnion = new Map();
    // All the unions we've seen, starting from types, stopping when we hit non-unions.
    const unions = new Set();
    // All the unions that are equivalent to the single root type.  If more than one type
    // is given, this will be empty.
    let unionsEquivalentToRoot = new Set();
    function traverse(t, path, isEquivalentToRoot) {
        if (t instanceof UnionType) {
            unions.add(t);
            if (isEquivalentToRoot) {
                unionsEquivalentToRoot = unionsEquivalentToRoot.add(t);
            }
            isEquivalentToRoot = isEquivalentToRoot && t.members.size === 1;
            path.push(t);
            for (const m of t.members) {
                traverse(m, path, isEquivalentToRoot);
            }
            path.pop();
        }
        else {
            collectionUtils.mapUpdateInto(unionsForType, t, s => (s === undefined ? new Set(path) : collectionUtils.setUnionInto(s, path)));
            for (const u of path) {
                collectionUtils.mapUpdateInto(typesForUnion, u, s => (s === undefined ? new Set([t]) : s.add(t)));
            }
        }
    }
    const rootPath = [new FauxUnion()];
    const typesArray = Array.from(types);
    for (const t of typesArray) {
        traverse(t, rootPath, typesArray.length === 1);
    }
    const resultAttributes = collectionUtils.mapMap(unionsForType, (unionForType, t) => {
        const singleAncestors = Array.from(unionForType).filter(u => defined(typesForUnion.get(u)).size === 1);
        assert(singleAncestors.every(u => defined(typesForUnion.get(u)).has(t)), "We messed up bookkeeping");
        const inheritedAttributes = singleAncestors.map(u => u.getAttributes());
        return combineTypeAttributes("union", [t.getAttributes()].concat(inheritedAttributes));
    });
    const unionAttributes = Array.from(unions).map(u => {
        const t = typesForUnion.get(u);
        if (t !== undefined && t.size === 1) {
            return emptyTypeAttributes;
        }
        const attributes = u.getAttributes();
        if (unionsEquivalentToRoot.has(u)) {
            return attributes;
        }
        return makeTypeAttributesInferred(attributes);
    });
    return [resultAttributes, combineTypeAttributes("union", unionAttributes)];
}
// FIXME: Move this to UnifyClasses.ts?
class TypeRefUnionAccumulator extends UnionAccumulator {
    // There is a method analogous to this in the IntersectionAccumulator.  It might
    // make sense to find a common interface.
    addType(t, attributes) {
        matchTypeExhaustive(t, _noneType => this.addNone(attributes), _anyType => this.addAny(attributes), _nullType => this.addPrimitive("null", attributes), _boolType => this.addPrimitive("bool", attributes), _integerType => this.addPrimitive("integer", attributes), _doubleType => this.addPrimitive("double", attributes), _stringType => this.addStringType("string", attributes), arrayType => this.addArray(arrayType.items.typeRef, attributes), classType => this.addObject(classType.typeRef, attributes), mapType => this.addObject(mapType.typeRef, attributes), objectType => this.addObject(objectType.typeRef, attributes), 
        // FIXME: We're not carrying counts, so this is not correct if we do enum
        // inference.  JSON Schema input uses this case, however, without enum
        // inference, which is fine, but still a bit ugly.
        enumType => this.addEnum(enumType.cases, attributes), _unionType => {
            return panic("The unions should have been eliminated in attributesForTypesInUnion");
        }, transformedStringType => this.addStringType(transformedStringType.kind, attributes));
    }
    addTypes(types) {
        const [attributesMap, unionAttributes] = attributesForTypes$1(types);
        for (const [t, attributes] of attributesMap) {
            this.addType(t, attributes);
        }
        return unionAttributes;
    }
}
class UnionBuilder {
    constructor(typeBuilder) {
        this.typeBuilder = typeBuilder;
    }
    makeTypeOfKind(typeProvider, kind, typeAttributes, forwardingRef) {
        switch (kind) {
            case "string":
                return this.typeBuilder.getStringType(typeAttributes, undefined, forwardingRef);
            case "enum":
                return this.typeBuilder.getEnumType(typeAttributes, typeProvider.enumCases, forwardingRef);
            case "object":
                return this.makeObject(typeProvider.objectData, typeAttributes, forwardingRef);
            case "array":
                return this.makeArray(typeProvider.arrayData, typeAttributes, forwardingRef);
            default:
                if (isPrimitiveTypeKind(kind)) {
                    return this.typeBuilder.getPrimitiveType(kind, typeAttributes, forwardingRef);
                }
                if (kind === "union" || kind === "class" || kind === "map" || kind === "intersection") {
                    return panic(`getMemberKinds() shouldn't return ${kind}`);
                }
                return assertNever(kind);
        }
    }
    buildUnion(typeProvider, unique, typeAttributes, forwardingRef) {
        const kinds = typeProvider.getMemberKinds();
        if (typeProvider.lostTypeAttributes) {
            this.typeBuilder.setLostTypeAttributes();
        }
        // FIXME: We don't reconstitute type attributes here, so it's possible that
        // we get type refs for the wrong graphs if the transformation making rewrite
        // makes unions that have to be unified here.  That's a bug anyway, at least
        // right now, it's just a very bad way of surfacing that error.
        if (kinds.size === 1) {
            const [[kind, memberAttributes]] = Array.from(kinds);
            const allAttributes = combineTypeAttributes("union", typeAttributes, increaseTypeAttributesDistance(memberAttributes));
            const t = this.makeTypeOfKind(typeProvider, kind, allAttributes, forwardingRef);
            return t;
        }
        const union = unique
            ? this.typeBuilder.getUniqueUnionType(typeAttributes, undefined, forwardingRef)
            : undefined;
        const types = [];
        for (const [kind, memberAttributes] of kinds) {
            types.push(this.makeTypeOfKind(typeProvider, kind, memberAttributes, undefined));
        }
        const typesSet = new Set(types);
        if (union !== undefined) {
            this.typeBuilder.setSetOperationMembers(union, typesSet);
            return union;
        }
        else {
            return this.typeBuilder.getUnionType(typeAttributes, typesSet, forwardingRef);
        }
    }
}

function forEachArrayInNestedValueArray(va, f) {
    if (va.length === 0) {
        return;
    }
    if (Array.isArray(va[0])) {
        for (const x of va) {
            forEachArrayInNestedValueArray(x, f);
        }
    }
    else {
        f(va);
    }
}
function forEachValueInNestedValueArray(va, f) {
    forEachArrayInNestedValueArray(va, a => {
        for (const x of a) {
            f(x);
        }
    });
}
class InferenceUnionBuilder extends UnionBuilder {
    constructor(typeBuilder, _typeInference, _fixed) {
        super(typeBuilder);
        this._typeInference = _typeInference;
        this._fixed = _fixed;
    }
    makeObject(objects, typeAttributes, forwardingRef) {
        return this._typeInference.inferClassType(typeAttributes, objects, this._fixed, forwardingRef);
    }
    makeArray(arrays, typeAttributes, forwardingRef) {
        return this.typeBuilder.getArrayType(typeAttributes, this._typeInference.inferType(emptyTypeAttributes, arrays, this._fixed, forwardingRef));
    }
}
class TypeInference {
    constructor(_cjson, _typeBuilder, _inferMaps, _inferEnums) {
        this._cjson = _cjson;
        this._typeBuilder = _typeBuilder;
        this._inferMaps = _inferMaps;
        this._inferEnums = _inferEnums;
    }
    addValuesToAccumulator(valueArray, accumulator) {
        forEachValueInNestedValueArray(valueArray, value => {
            const t = valueTag(value);
            switch (t) {
                case Tag.Null:
                    accumulator.addPrimitive("null", emptyTypeAttributes);
                    break;
                case Tag.False:
                case Tag.True:
                    accumulator.addPrimitive("bool", emptyTypeAttributes);
                    break;
                case Tag.Integer:
                    accumulator.addPrimitive("integer", emptyTypeAttributes);
                    break;
                case Tag.Double:
                    accumulator.addPrimitive("double", emptyTypeAttributes);
                    break;
                case Tag.InternedString:
                    if (this._inferEnums) {
                        const s = this._cjson.getStringForValue(value);
                        {
                            accumulator.addStringCase(s, 1, emptyTypeAttributes);
                        }
                    }
                    else {
                        accumulator.addStringType("string", emptyTypeAttributes);
                    }
                    break;
                case Tag.UninternedString:
                    accumulator.addStringType("string", emptyTypeAttributes);
                    break;
                case Tag.Object:
                    accumulator.addObject(this._cjson.getObjectForValue(value), emptyTypeAttributes);
                    break;
                case Tag.Array:
                    accumulator.addArray(this._cjson.getArrayForValue(value), emptyTypeAttributes);
                    break;
                case Tag.StringFormat: {
                    const kind = this._cjson.getStringFormatTypeKind(value);
                    accumulator.addStringType("string", emptyTypeAttributes, new StringTypes(new Map(), new Set([kind])));
                    break;
                }
                case Tag.TransformedString: {
                    const s = this._cjson.getStringForValue(value);
                    const kind = inferTransformedStringTypeKindForString(s, this._cjson.dateTimeRecognizer);
                    if (kind === undefined) {
                        return panic("TransformedString does not have a kind");
                    }
                    const producer = defined(transformedStringTypeTargetTypeKindsMap.get(kind)).attributesProducer;
                    if (producer === undefined) {
                        return panic("TransformedString does not have attribute producer");
                    }
                    accumulator.addStringType("string", producer(s), new StringTypes(new Map(), new Set([kind])));
                    break;
                }
                default:
                    return assertNever(t);
            }
        });
    }
    inferType(typeAttributes, valueArray, fixed, forwardingRef) {
        const accumulator = this.accumulatorForArray(valueArray);
        return this.makeTypeFromAccumulator(accumulator, typeAttributes, fixed, forwardingRef);
    }
    resolveRef(ref, topLevel) {
        if (!ref.startsWith("#/")) {
            return messageError("InferenceJSONReferenceNotRooted", { reference: ref });
        }
        const parts = ref.split("/").slice(1);
        const graph = this._typeBuilder.typeGraph;
        let tref = topLevel;
        for (const part of parts) {
            let t = derefTypeRef(tref, graph);
            if (t instanceof UnionType) {
                const nullable = nullableFromUnion(t);
                if (nullable === null) {
                    // FIXME: handle unions
                    return messageError("InferenceJSONReferenceToUnion", { reference: ref });
                }
                t = nullable;
            }
            if (t instanceof ClassType) {
                const cp = t.getProperties().get(part);
                if (cp === undefined) {
                    return messageError("InferenceJSONReferenceWrongProperty", { reference: ref });
                }
                tref = cp.typeRef;
            }
            else if (t instanceof MapType) {
                tref = t.values.typeRef;
            }
            else if (t instanceof ArrayType) {
                if (/^[0-9]+$/.exec(part) === null) {
                    return messageError("InferenceJSONReferenceInvalidArrayIndex", { reference: ref });
                }
                tref = t.items.typeRef;
            }
            else {
                return messageError("InferenceJSONReferenceWrongProperty", { reference: ref });
            }
        }
        return tref;
    }
    inferTopLevelType(typeAttributes, valueArray, fixed) {
        assert(this._refIntersections === undefined, "Didn't reset ref intersections - nested invocations?");
        if (this._cjson.handleRefs) {
            this._refIntersections = [];
        }
        const topLevel = this.inferType(typeAttributes, valueArray, fixed);
        if (this._cjson.handleRefs) {
            for (const [tref, refs] of defined(this._refIntersections)) {
                const resolved = refs.map(r => this.resolveRef(r, topLevel));
                this._typeBuilder.setSetOperationMembers(tref, new Set(resolved));
            }
            this._refIntersections = undefined;
        }
        return topLevel;
    }
    accumulatorForArray(valueArray) {
        const accumulator = new UnionAccumulator(true);
        this.addValuesToAccumulator(valueArray, accumulator);
        return accumulator;
    }
    makeTypeFromAccumulator(accumulator, typeAttributes, fixed, forwardingRef) {
        const unionBuilder = new InferenceUnionBuilder(this._typeBuilder, this, fixed);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
    }
    inferClassType(typeAttributes, objects, fixed, forwardingRef) {
        const propertyNames = [];
        const propertyValues = {};
        forEachArrayInNestedValueArray(objects, arr => {
            for (let i = 0; i < arr.length; i += 2) {
                const key = this._cjson.getStringForValue(arr[i]);
                const value = arr[i + 1];
                if (!Object.prototype.hasOwnProperty.call(propertyValues, key)) {
                    propertyNames.push(key);
                    propertyValues[key] = [];
                }
                propertyValues[key].push(value);
            }
        });
        if (this._cjson.handleRefs && propertyNames.length === 1 && propertyNames[0] === "$ref") {
            const values = propertyValues.$ref;
            if (values.every(v => valueTag(v) === Tag.InternedString)) {
                const allRefs = values.map(v => this._cjson.getStringForValue(v));
                // FIXME: Add is-ref attribute
                const tref = this._typeBuilder.getUniqueIntersectionType(typeAttributes, undefined);
                defined(this._refIntersections).push([tref, allRefs]);
                return tref;
            }
        }
        if (this._inferMaps && propertyNames.length > 500) {
            const accumulator = new UnionAccumulator(true);
            for (const key of propertyNames) {
                this.addValuesToAccumulator(propertyValues[key], accumulator);
            }
            const values = this.makeTypeFromAccumulator(accumulator, emptyTypeAttributes, fixed);
            return this._typeBuilder.getMapType(typeAttributes, values, forwardingRef);
        }
        const properties = new Map();
        for (const key of propertyNames) {
            const values = propertyValues[key];
            const t = this.inferType(emptyTypeAttributes, values, false);
            const isOptional = values.length < objects.length;
            properties.set(key, this._typeBuilder.makeClassProperty(t, isOptional));
        }
        if (fixed) {
            return this._typeBuilder.getUniqueClassType(typeAttributes, true, properties, forwardingRef);
        }
        else {
            return this._typeBuilder.getClassType(typeAttributes, properties, forwardingRef);
        }
    }
}

function messageParseError(name, description, e) {
    return messageError("MiscJSONParseError", {
        description: collectionUtils.withDefault(description, "input"),
        address: name,
        message: errorMessage(e)
    });
}
class JSONInput {
    constructor(_compressedJSON) {
        this._compressedJSON = _compressedJSON;
        this.kind = "json";
        this.needIR = true;
        this.needSchemaProcessing = false;
        this._topLevels = new Map();
    }
    addSample(topLevelName, sample) {
        let topLevel = this._topLevels.get(topLevelName);
        if (topLevel === undefined) {
            topLevel = { samples: [], description: undefined };
            this._topLevels.set(topLevelName, topLevel);
        }
        topLevel.samples.push(sample);
    }
    setDescription(topLevelName, description) {
        let topLevel = this._topLevels.get(topLevelName);
        if (topLevel === undefined) {
            return panic("Trying to set description for a top-level that doesn't exist");
        }
        topLevel.description = description;
    }
    addSamples(name, values, description) {
        for (const value of values) {
            this.addSample(name, value);
            if (description !== undefined) {
                this.setDescription(name, description);
            }
        }
    }
    addSource(source) {
        return __awaiter(this, void 0, void 0, function* () {
            const { name, samples, description } = source;
            try {
                const values = yield collectionUtils.arrayMapSync(samples, (s) => __awaiter(this, void 0, void 0, function* () { return yield this._compressedJSON.parse(s); }));
                this.addSamples(name, values, description);
            }
            catch (e) {
                return messageParseError(name, description, e);
            }
        });
    }
    addSourceSync(source) {
        const { name, samples, description } = source;
        try {
            const values = samples.map(s => this._compressedJSON.parseSync(s));
            this.addSamples(name, values, description);
        }
        catch (e) {
            return messageParseError(name, description, e);
        }
    }
    singleStringSchemaSource() {
        return undefined;
    }
    addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        return __awaiter(this, void 0, void 0, function* () {
            this.addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
        });
    }
    addTypesSync(_ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        const inference = new TypeInference(this._compressedJSON, typeBuilder, inferMaps, inferEnums);
        for (const [name, { samples, description }] of this._topLevels) {
            const tref = inference.inferTopLevelType(makeNamesTypeAttributes(name, false), samples, fixedTopLevels);
            typeBuilder.addTopLevel(name, tref);
            if (description !== undefined) {
                const attributes = descriptionTypeAttributeKind.makeAttributes(new Set([description]));
                typeBuilder.addAttributes(tref, attributes);
            }
        }
    }
}
function jsonInputForTargetLanguage(targetLanguage, languages, handleJSONRefs = false) {
    if (typeof targetLanguage === "string") {
        targetLanguage = defined(languageNamed(targetLanguage, languages));
    }
    const compressedJSON = new CompressedJSONFromString(targetLanguage.dateTimeRecognizer, handleJSONRefs);
    return new JSONInput(compressedJSON);
}
class InputData {
    constructor() {
        // FIXME: Make into a Map, indexed by kind.
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this._inputs = new Set();
    }
    addInput(input) {
        this._inputs = this._inputs.add(input);
    }
    getOrAddInput(kind, makeInput) {
        let input = collectionUtils.iterableFind(this._inputs, i => i.kind === kind);
        if (input === undefined) {
            input = makeInput();
            this.addInput(input);
        }
        return input;
    }
    addSource(kind, source, makeInput) {
        return __awaiter(this, void 0, void 0, function* () {
            const input = this.getOrAddInput(kind, makeInput);
            yield input.addSource(source);
        });
    }
    addSourceSync(kind, source, makeInput) {
        const input = this.getOrAddInput(kind, makeInput);
        input.addSourceSync(source);
    }
    addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const input of this._inputs) {
                yield input.addTypes(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
            }
        });
    }
    addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels) {
        for (const input of this._inputs) {
            input.addTypesSync(ctx, typeBuilder, inferMaps, inferEnums, fixedTopLevels);
        }
    }
    get needIR() {
        return collectionUtils.iterableSome(this._inputs, i => i.needIR);
    }
    get needSchemaProcessing() {
        return collectionUtils.iterableSome(this._inputs, i => i.needSchemaProcessing);
    }
    singleStringSchemaSource() {
        const schemaStrings = collectionUtils.setFilterMap(this._inputs, i => i.singleStringSchemaSource());
        if (schemaStrings.size > 1) {
            return panic("We have more than one input with a string schema source");
        }
        return collectionUtils.iterableFirst(schemaStrings);
    }
}

function transformationAttributes(graph, reconstitutedTargetType, transformer, debugPrintTransformations) {
    const transformation = new Transformation(graph, reconstitutedTargetType, transformer);
    if (debugPrintTransformations) {
        console.log(`transformation for ${typeRefIndex(reconstitutedTargetType)}:`);
        transformation.debugPrint();
        console.log("reverse:");
        transformation.reverse.debugPrint();
    }
    return transformationTypeAttributeKind.makeAttributes(transformation);
}
function makeEnumTransformer(graph, enumType, stringType, continuation) {
    const sortedCases = Array.from(enumType.cases).sort();
    const caseTransformers = sortedCases.map(c => new StringMatchTransformer(graph, stringType, new StringProducerTransformer(graph, stringType, continuation, c), c));
    return new ChoiceTransformer(graph, stringType, caseTransformers);
}
function replaceUnion$1(union, builder, forwardingRef, transformedTypes, debugPrintTransformations) {
    const graph = builder.typeGraph;
    assert(union.members.size > 0, "We can't have empty unions");
    // Type attributes that we lost during reconstitution.
    let additionalAttributes = emptyTypeAttributes;
    function reconstituteMember(t) {
        // Special handling for some transformed string type kinds: The type in
        // the union must be the target type, so if one already exists, use that
        // one, otherwise make a new one.
        if (isPrimitiveStringTypeKind(t.kind)) {
            const targetTypeKind = targetTypeKindForTransformedStringTypeKind(t.kind);
            if (targetTypeKind !== undefined) {
                const targetTypeMember = union.findMember(targetTypeKind);
                additionalAttributes = combineTypeAttributes("union", additionalAttributes, t.getAttributes());
                if (targetTypeMember !== undefined) {
                    return builder.reconstituteType(targetTypeMember);
                }
                return builder.getPrimitiveType(targetTypeKind);
            }
        }
        return builder.reconstituteType(t);
    }
    const reconstitutedMembersByKind = collectionUtils.mapMapEntries(union.members.entries(), m => [m.kind, reconstituteMember(m)]);
    const reconstitutedMemberSet = new Set(reconstitutedMembersByKind.values());
    const haveUnion = reconstitutedMemberSet.size > 1;
    if (!haveUnion) {
        builder.setLostTypeAttributes();
    }
    const reconstitutedTargetType = haveUnion
        ? builder.getUnionType(union.getAttributes(), reconstitutedMemberSet)
        : defined(collectionUtils.iterableFirst(reconstitutedMemberSet));
    function memberForKind(kind) {
        return defined(reconstitutedMembersByKind.get(kind));
    }
    function consumer(memberTypeRef) {
        if (!haveUnion)
            return undefined;
        return new UnionInstantiationTransformer(graph, memberTypeRef);
    }
    function transformerForKind(kind) {
        const member = union.findMember(kind);
        if (member === undefined)
            return undefined;
        const memberTypeRef = memberForKind(kind);
        return new DecodingTransformer(graph, memberTypeRef, consumer(memberTypeRef));
    }
    let maybeStringType = undefined;
    function getStringType() {
        if (maybeStringType === undefined) {
            maybeStringType = builder.getStringType(emptyTypeAttributes, StringTypes.unrestricted);
        }
        return maybeStringType;
    }
    function transformerForStringType(t) {
        const memberRef = memberForKind(t.kind);
        if (t.kind === "string") {
            const minMax = minMaxLengthForType(t);
            if (minMax === undefined) {
                return consumer(memberRef);
            }
            const [min, max] = minMax;
            return new MinMaxLengthCheckTransformer(graph, getStringType(), consumer(memberRef), min, max);
        }
        else if (t instanceof EnumType && transformedTypes.has(t)) {
            return makeEnumTransformer(graph, t, getStringType(), consumer(memberRef));
        }
        else {
            return new ParseStringTransformer(graph, getStringType(), consumer(memberRef));
        }
    }
    const stringTypes = collectionUtils.arraySortByInto(Array.from(union.stringTypeMembers), t => t.kind);
    let transformerForString;
    if (stringTypes.length === 0) {
        transformerForString = undefined;
    }
    else if (stringTypes.length === 1) {
        const t = stringTypes[0];
        transformerForString = new DecodingTransformer(graph, getStringType(), transformerForStringType(t));
    }
    else {
        transformerForString = new DecodingTransformer(graph, getStringType(), new ChoiceTransformer(graph, getStringType(), stringTypes.map(t => defined(transformerForStringType(t)))));
    }
    const transformerForClass = transformerForKind("class");
    const transformerForMap = transformerForKind("map");
    assert(transformerForClass === undefined || transformerForMap === undefined, "Can't have both class and map in a transformed union");
    const transformerForObject = transformerForClass !== null && transformerForClass !== void 0 ? transformerForClass : transformerForMap;
    const transformer = new DecodingChoiceTransformer(graph, builder.getPrimitiveType("any"), transformerForKind("null"), transformerForKind("integer"), transformerForKind("double"), transformerForKind("bool"), transformerForString, transformerForKind("array"), transformerForObject);
    const attributes = transformationAttributes(graph, reconstitutedTargetType, transformer, debugPrintTransformations);
    return builder.getPrimitiveType("any", combineTypeAttributes("union", attributes, additionalAttributes), forwardingRef);
}
function replaceArray(arrayType, builder, forwardingRef, debugPrintTransformations) {
    const anyType = builder.getPrimitiveType("any");
    const anyArrayType = builder.getArrayType(emptyTypeAttributes, anyType);
    const reconstitutedItems = builder.reconstituteType(arrayType.items);
    const transformer = new ArrayDecodingTransformer(builder.typeGraph, anyArrayType, undefined, reconstitutedItems, new DecodingTransformer(builder.typeGraph, anyType, undefined));
    const reconstitutedArray = builder.getArrayType(builder.reconstituteTypeAttributes(arrayType.getAttributes()), reconstitutedItems);
    const attributes = transformationAttributes(builder.typeGraph, reconstitutedArray, transformer, debugPrintTransformations);
    return builder.getArrayType(attributes, anyType, forwardingRef);
}
function replaceEnum(enumType, builder, forwardingRef, debugPrintTransformations) {
    const stringType = builder.getStringType(emptyTypeAttributes, StringTypes.unrestricted);
    const transformer = new DecodingTransformer(builder.typeGraph, stringType, makeEnumTransformer(builder.typeGraph, enumType, stringType));
    const reconstitutedEnum = builder.getEnumType(enumType.getAttributes(), enumType.cases);
    const attributes = transformationAttributes(builder.typeGraph, reconstitutedEnum, transformer, debugPrintTransformations);
    return builder.getStringType(attributes, StringTypes.unrestricted, forwardingRef);
}
function replaceNumber(t, builder, forwardingRef, debugPrintTransformations) {
    const stringType = builder.getStringType(emptyTypeAttributes, StringTypes.unrestricted);
    const [min, max] = defined(minMaxValueForType(t));
    const transformer = new DecodingTransformer(builder.typeGraph, stringType, new MinMaxValueTransformer(builder.typeGraph, stringType, undefined, min, max));
    const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
    const attributes = transformationAttributes(builder.typeGraph, builder.getPrimitiveType("double", reconstitutedAttributes, undefined), transformer, debugPrintTransformations);
    return builder.getPrimitiveType("double", attributes, forwardingRef);
}
function replaceString(t, builder, forwardingRef, debugPrintTransformations) {
    const [min, max] = defined(minMaxLengthForType(t));
    const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
    const stringType = builder.getStringType(emptyTypeAttributes, StringTypes.unrestricted);
    const transformer = new DecodingTransformer(builder.typeGraph, stringType, new MinMaxLengthCheckTransformer(builder.typeGraph, stringType, undefined, min, max));
    const attributes = transformationAttributes(builder.typeGraph, builder.getStringType(reconstitutedAttributes, undefined), transformer, debugPrintTransformations);
    return builder.getStringType(attributes, StringTypes.unrestricted, forwardingRef);
}
function replaceTransformedStringType(t, kind, builder, forwardingRef, debugPrintTransformations) {
    const reconstitutedAttributes = builder.reconstituteTypeAttributes(t.getAttributes());
    const targetTypeKind = collectionUtils.withDefault(targetTypeKindForTransformedStringTypeKind(kind), kind);
    const stringType = builder.getStringType(emptyTypeAttributes, StringTypes.unrestricted);
    const transformer = new DecodingTransformer(builder.typeGraph, stringType, new ParseStringTransformer(builder.typeGraph, stringType, undefined));
    const attributes = transformationAttributes(builder.typeGraph, builder.getPrimitiveType(targetTypeKind, reconstitutedAttributes), transformer, debugPrintTransformations);
    return builder.getStringType(attributes, StringTypes.unrestricted, forwardingRef);
}
function makeTransformations(ctx, graph, targetLanguage) {
    const transformedTypes = collectionUtils.setFilter(graph.allTypesUnordered(), t => {
        if (targetLanguage.needsTransformerForType(t))
            return true;
        if (!(t instanceof UnionType))
            return false;
        const stringMembers = t.stringTypeMembers;
        if (stringMembers.size <= 1)
            return false;
        return collectionUtils.iterableSome(stringMembers, m => targetLanguage.needsTransformerForType(m));
    });
    function replace(setOfOneUnion, builder, forwardingRef) {
        const t = defined(collectionUtils.iterableFirst(setOfOneUnion));
        if (t instanceof UnionType) {
            return replaceUnion$1(t, builder, forwardingRef, transformedTypes, ctx.debugPrintTransformations);
        }
        if (t instanceof ArrayType) {
            return replaceArray(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (t instanceof EnumType) {
            return replaceEnum(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (t.kind === "string") {
            return replaceString(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (isNumberTypeKind(t.kind)) {
            return replaceNumber(t, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        if (isPrimitiveStringTypeKind(t.kind)) {
            return replaceTransformedStringType(t, t.kind, builder, forwardingRef, ctx.debugPrintTransformations);
        }
        return panic(`Cannot make transformation for type ${t.kind}`);
    }
    const groups = Array.from(transformedTypes).map(t => [t]);
    return graph.rewrite("make-transformations", ctx.stringTypeMapping, false, groups, ctx.debugPrintReconstitution, replace);
}

function getCliqueProperties(clique, builder, makePropertyType) {
    let lostTypeAttributes = false;
    let propertyNames = new Set();
    for (const o of clique) {
        collectionUtils.setUnionInto(propertyNames, o.getProperties().keys());
    }
    let properties = Array.from(propertyNames).map(name => [name, new Set(), false]);
    let additionalProperties = undefined;
    for (const o of clique) {
        let additional = o.getAdditionalProperties();
        if (additional !== undefined) {
            if (additionalProperties === undefined) {
                additionalProperties = new Set();
            }
            if (additional !== undefined) {
                additionalProperties.add(additional);
            }
        }
        // FIXME: refactor this
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < properties.length; i++) {
            let [name, types, isOptional] = properties[i];
            const maybeProperty = o.getProperties().get(name);
            if (maybeProperty === undefined) {
                isOptional = true;
                if (additional !== undefined && additional.kind !== "any") {
                    types.add(additional);
                }
            }
            else {
                if (maybeProperty.isOptional) {
                    isOptional = true;
                }
                types.add(maybeProperty.type);
            }
            properties[i][2] = isOptional;
        }
    }
    const unifiedAdditionalProperties = additionalProperties === undefined ? undefined : makePropertyType(additionalProperties);
    const unifiedPropertiesArray = properties.map(([name, types, isOptional]) => {
        return [name, builder.makeClassProperty(makePropertyType(types), isOptional)];
    });
    const unifiedProperties = new Map(unifiedPropertiesArray);
    return [unifiedProperties, unifiedAdditionalProperties, lostTypeAttributes];
}
function countProperties(clique) {
    let hasProperties = false;
    let hasAdditionalProperties = false;
    let hasNonAnyAdditionalProperties = false;
    for (const o of clique) {
        if (o.getProperties().size > 0) {
            hasProperties = true;
        }
        const additional = o.getAdditionalProperties();
        if (additional !== undefined) {
            hasAdditionalProperties = true;
            if (additional.kind !== "any") {
                hasNonAnyAdditionalProperties = true;
            }
        }
    }
    return { hasProperties, hasAdditionalProperties, hasNonAnyAdditionalProperties };
}
class UnifyUnionBuilder extends UnionBuilder {
    constructor(typeBuilder, _makeObjectTypes, _makeClassesFixed, _unifyTypes) {
        super(typeBuilder);
        this._makeObjectTypes = _makeObjectTypes;
        this._makeClassesFixed = _makeClassesFixed;
        this._unifyTypes = _unifyTypes;
    }
    makeObject(objectRefs, typeAttributes, forwardingRef) {
        const maybeTypeRef = this.typeBuilder.lookupTypeRefs(objectRefs, forwardingRef);
        if (maybeTypeRef !== undefined) {
            assert(forwardingRef === undefined || maybeTypeRef === forwardingRef, "The forwarding ref must be consumed");
            this.typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
            return maybeTypeRef;
        }
        if (objectRefs.length === 1) {
            return this.typeBuilder.reconstituteTypeRef(objectRefs[0], typeAttributes, forwardingRef);
        }
        const objectTypes = objectRefs.map(r => assertIsObject(derefTypeRef(r, this.typeBuilder)));
        const { hasProperties, hasAdditionalProperties, hasNonAnyAdditionalProperties } = countProperties(objectTypes);
        if (!this._makeObjectTypes && (hasNonAnyAdditionalProperties || (!hasProperties && hasAdditionalProperties))) {
            const propertyTypes = new Set();
            for (const o of objectTypes) {
                collectionUtils.setUnionInto(propertyTypes, Array.from(o.getProperties().values()).map(cp => cp.typeRef));
            }
            const additionalPropertyTypes = new Set(objectTypes
                .filter(o => o.getAdditionalProperties() !== undefined)
                .map(o => defined(o.getAdditionalProperties()).typeRef));
            collectionUtils.setUnionInto(propertyTypes, additionalPropertyTypes);
            return this.typeBuilder.getMapType(typeAttributes, this._unifyTypes(Array.from(propertyTypes)));
        }
        else {
            const [properties, additionalProperties, lostTypeAttributes] = getCliqueProperties(objectTypes, this.typeBuilder, types => {
                assert(types.size > 0, "Property has no type");
                return this._unifyTypes(Array.from(types).map(t => t.typeRef));
            });
            if (lostTypeAttributes) {
                this.typeBuilder.setLostTypeAttributes();
            }
            if (this._makeObjectTypes) {
                return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
            }
            else {
                assert(additionalProperties === undefined, "We have additional properties but want to make a class");
                return this.typeBuilder.getUniqueClassType(typeAttributes, this._makeClassesFixed, properties, forwardingRef);
            }
        }
    }
    makeArray(arrays, typeAttributes, forwardingRef) {
        const ref = this.typeBuilder.getArrayType(typeAttributes, this._unifyTypes(arrays), forwardingRef);
        return ref;
    }
}
function unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers) {
    return new UnifyUnionBuilder(typeBuilder, makeObjectTypes, makeClassesFixed, trefs => unifyTypes(new Set(trefs.map(tref => derefTypeRef(tref, typeBuilder))), emptyTypeAttributes, typeBuilder, unionBuilderForUnification(typeBuilder, makeObjectTypes, makeClassesFixed, conflateNumbers), conflateNumbers));
}
// typeAttributes must not be reconstituted yet.
// FIXME: The UnionBuilder might end up not being used.
function unifyTypes(types, typeAttributes, typeBuilder, unionBuilder, conflateNumbers, maybeForwardingRef) {
    typeAttributes = typeBuilder.reconstituteTypeAttributes(typeAttributes);
    if (types.size === 0) {
        return panic("Cannot unify empty set of types");
    }
    else if (types.size === 1) {
        const first = defined(collectionUtils.iterableFirst(types));
        if (!(first instanceof UnionType)) {
            return typeBuilder.reconstituteTypeRef(first.typeRef, typeAttributes, maybeForwardingRef);
        }
    }
    const typeRefs = Array.from(types).map(t => t.typeRef);
    const maybeTypeRef = typeBuilder.lookupTypeRefs(typeRefs, maybeForwardingRef);
    if (maybeTypeRef !== undefined) {
        typeBuilder.addAttributes(maybeTypeRef, typeAttributes);
        return maybeTypeRef;
    }
    const accumulator = new TypeRefUnionAccumulator(conflateNumbers);
    const nestedAttributes = typeBuilder.reconstituteTypeAttributes(accumulator.addTypes(types));
    typeAttributes = combineTypeAttributes("union", typeAttributes, nestedAttributes);
    return typeBuilder.withForwardingRef(maybeForwardingRef, forwardingRef => {
        typeBuilder.registerUnion(typeRefs, forwardingRef);
        return unionBuilder.buildUnion(accumulator, false, typeAttributes, forwardingRef);
    });
}

const REQUIRED_OVERLAP$1 = 3 / 4;
// FIXME: Allow some type combinations to unify, like different enums,
// enums with strings, integers with doubles, maps with objects of
// the correct type.
function typeSetsCanBeCombined(s1, s2) {
    return setOperationCasesEqual(s1, s2, true, (a, b) => a.structurallyCompatible(b, true));
}
function canBeCombined(c1, c2, onlyWithSameProperties) {
    const p1 = c1.getProperties();
    const p2 = c2.getProperties();
    if (onlyWithSameProperties) {
        if (p1.size !== p2.size) {
            return false;
        }
    }
    else {
        if (p1.size < p2.size * REQUIRED_OVERLAP$1 || p2.size < p1.size * REQUIRED_OVERLAP$1) {
            return false;
        }
    }
    let larger;
    let smaller;
    if (p1.size > p2.size) {
        larger = p1;
        smaller = p2;
    }
    else {
        larger = p2;
        smaller = p1;
    }
    let maxFaults;
    if (onlyWithSameProperties) {
        maxFaults = 0;
    }
    else {
        const minOverlap = Math.ceil(larger.size * REQUIRED_OVERLAP$1);
        maxFaults = smaller.size - minOverlap;
    }
    assert(maxFaults >= 0, "Max faults negative");
    const commonProperties = [];
    let faults = 0;
    for (const [name] of smaller) {
        if (larger.has(name)) {
            commonProperties.push(name);
        }
        else {
            faults += 1;
            if (faults > maxFaults)
                break;
        }
    }
    if (faults > maxFaults)
        return false;
    for (const name of commonProperties) {
        let ts = smaller.get(name);
        let tl = larger.get(name);
        if (ts === undefined || tl === undefined) {
            return panic(`Both classes should have property ${name}`);
        }
        const tsCases = nonNullTypeCases(ts.type);
        const tlCases = nonNullTypeCases(tl.type);
        if (tsCases.size > 0 && tlCases.size > 0 && !typeSetsCanBeCombined(tsCases, tlCases)) {
            return false;
        }
    }
    return true;
}
function tryAddToClique(c, clique, onlyWithSameProperties) {
    for (const prototype of clique.prototypes) {
        if (prototype.structurallyCompatible(c)) {
            clique.members.push(c);
            return true;
        }
    }
    for (const prototype of clique.prototypes) {
        if (canBeCombined(prototype, c, onlyWithSameProperties)) {
            clique.prototypes.push(c);
            clique.members.push(c);
            return true;
        }
    }
    return false;
}
function findSimilarityCliques(graph, onlyWithSameProperties, includeFixedClasses) {
    const classCandidates = Array.from(graph.allNamedTypesSeparated().objects).filter(o => o instanceof ClassType && (!o.isFixed));
    const cliques = [];
    for (const c of classCandidates) {
        let cliqueIndex = undefined;
        for (let i = 0; i < cliques.length; i++) {
            if (tryAddToClique(c, cliques[i], onlyWithSameProperties)) {
                cliqueIndex = i;
                break;
            }
        }
        if (cliqueIndex === undefined) {
            // New clique
            cliqueIndex = cliques.length;
            cliques.push({ members: [c], prototypes: [c] });
        }
        // Move the clique we just added to to the front, in the hope that
        // some cliques are more often added to than others, and they'll
        // move to the front.
        const tmp = cliques[0];
        cliques[0] = cliques[cliqueIndex];
        cliques[cliqueIndex] = tmp;
    }
    return cliques.map(clique => clique.members).filter(cl => cl.length > 1);
}
function combineClasses(ctx, graph, alphabetizeProperties, conflateNumbers, onlyWithSameProperties, debugPrintReconstitution) {
    const cliques = ctx.time("  find similarity cliques", () => findSimilarityCliques(graph, onlyWithSameProperties));
    function makeCliqueClass(clique, builder, forwardingRef) {
        assert(clique.size > 0, "Clique can't be empty");
        const attributes = combineTypeAttributesOfTypes("union", clique);
        return unifyTypes(clique, attributes, builder, unionBuilderForUnification(builder, false, false, conflateNumbers), conflateNumbers, forwardingRef);
    }
    return graph.rewrite("combine classes", ctx.stringTypeMapping, alphabetizeProperties, cliques, debugPrintReconstitution, makeCliqueClass);
}

const MIN_LENGTH_FOR_ENUM = 10;
const MIN_LENGTH_FOR_OVERLAP = 5;
const REQUIRED_OVERLAP = 3 / 4;
function isOwnEnum({ numValues, cases }) {
    return numValues >= MIN_LENGTH_FOR_ENUM && cases.size < Math.sqrt(numValues);
}
function enumCasesOverlap(newCases, existingCases, newAreSubordinate) {
    const smaller = newAreSubordinate ? newCases.size : Math.min(newCases.size, existingCases.size);
    const overlap = collectionUtils.setIntersect(newCases, existingCases).size;
    return overlap >= smaller * REQUIRED_OVERLAP;
}
function isAlwaysEmptyString(cases) {
    return cases.length === 1 && cases[0] === "";
}
function expandStrings(ctx, graph, inference) {
    const stringTypeMapping = ctx.stringTypeMapping;
    const allStrings = Array.from(graph.allTypesUnordered()).filter(t => t.kind === "string" && stringTypesForType(t).isRestricted);
    function makeEnumInfo(t) {
        const stringTypes = stringTypesForType(t);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted)
            return undefined;
        const cases = defined(mappedStringTypes.cases);
        if (cases.size === 0)
            return undefined;
        const numValues = collectionUtils.iterableReduce(cases.values(), 0, (a, b) => a + b);
        if (inference !== "all") {
            const keys = Array.from(cases.keys());
            if (isAlwaysEmptyString(keys))
                return undefined;
            const someCaseIsNotNumber = collectionUtils.iterableSome(keys, key => /^[-+]?[0-9]+(\.[0-9]+)?$/.test(key) === false);
            if (!someCaseIsNotNumber)
                return undefined;
        }
        return { cases: new Set(cases.keys()), numValues };
    }
    const enumInfos = new Map();
    const enumSets = [];
    if (inference !== "none") {
        for (const t of allStrings) {
            const enumInfo = makeEnumInfo(t);
            if (enumInfo === undefined)
                continue;
            enumInfos.set(t, enumInfo);
        }
        // FIXME: refactor this
        // eslint-disable-next-line no-inner-declarations
        function findOverlap(newCases, newAreSubordinate) {
            return enumSets.findIndex(s => enumCasesOverlap(newCases, s, newAreSubordinate));
        }
        // First, make case sets for all the enums that stand on their own.  If
        // we find some overlap (searching eagerly), make unions.
        for (const t of Array.from(enumInfos.keys())) {
            const enumInfo = defined(enumInfos.get(t));
            const cases = enumInfo.cases;
            if (inference === "all") {
                enumSets.push(cases);
            }
            else {
                if (!isOwnEnum(enumInfo))
                    continue;
                const index = findOverlap(cases, false);
                if (index >= 0) {
                    // console.log(
                    //     `unifying ${JSON.stringify(Array.from(cases))} with ${JSON.stringify(
                    //         Array.from(enumSets[index])
                    //     )}`
                    // );
                    enumSets[index] = collectionUtils.setUnion(enumSets[index], cases);
                }
                else {
                    // console.log(`adding new ${JSON.stringify(Array.from(cases))}`);
                    enumSets.push(cases);
                }
            }
            // Remove the ones we're done with.
            enumInfos.delete(t);
        }
        if (inference === "all") {
            assert(enumInfos.size === 0);
        }
        // Now see if we can unify the rest with some a set we found in the
        // previous step.
        for (const [, enumInfo] of enumInfos.entries()) {
            if (enumInfo.numValues < MIN_LENGTH_FOR_OVERLAP)
                continue;
            const index = findOverlap(enumInfo.cases, true);
            if (index >= 0) {
                // console.log(
                //     `late unifying ${JSON.stringify(Array.from(enumInfo.cases))} with ${JSON.stringify(
                //         Array.from(enumSets[index])
                //     )}`
                // );
                enumSets[index] = collectionUtils.setUnion(enumSets[index], enumInfo.cases);
            }
        }
    }
    function replaceString(group, builder, forwardingRef) {
        assert(group.size === 1);
        const t = defined(collectionUtils.iterableFirst(group));
        const stringTypes = stringTypesForType(t);
        const attributes = collectionUtils.mapFilter(t.getAttributes(), a => a !== stringTypes);
        const mappedStringTypes = stringTypes.applyStringTypeMapping(stringTypeMapping);
        if (!mappedStringTypes.isRestricted) {
            return builder.getStringType(attributes, StringTypes.unrestricted, forwardingRef);
        }
        const setMatches = inference === "all" ? collectionUtils.areEqual : collectionUtils.setIsSuperset;
        const types = [];
        const cases = defined(mappedStringTypes.cases);
        if (cases.size > 0) {
            const keys = new Set(cases.keys());
            const fullCases = enumSets.find(s => setMatches(s, keys));
            if (inference !== "none" && !isAlwaysEmptyString(Array.from(keys)) && fullCases !== undefined) {
                types.push(builder.getEnumType(emptyTypeAttributes, fullCases));
            }
            else {
                return builder.getStringType(attributes, StringTypes.unrestricted, forwardingRef);
            }
        }
        const transformations = mappedStringTypes.transformations;
        // FIXME: This is probably wrong, or at least overly conservative.  This is for the case
        // where some attributes are identity ones, i.e. where we can't merge the primitive types,
        // like it happens in the line after the `if`.  The case where this occured was with URI
        // attributes: we had two separate string types with different URI attributes, but because
        // both are rewritten via `getPrimitiveType` below without any attributes, they end up
        // being the same string type.
        if (types.length === 0 && transformations.size === 1) {
            const kind = defined(collectionUtils.iterableFirst(transformations));
            return builder.getPrimitiveType(kind, attributes, forwardingRef);
        }
        types.push(...Array.from(transformations).map(k => builder.getPrimitiveType(k)));
        assert(types.length > 0, "We got an empty string type");
        return builder.getUnionType(attributes, new Set(types), forwardingRef);
    }
    return graph.rewrite("expand strings", stringTypeMapping, false, allStrings.map(t => [t]), ctx.debugPrintReconstitution, replaceString);
}

// A union needs replacing if it contains more than one string type, one of them being
// a basic string type.
function unionNeedsReplacing(u) {
    const stringMembers = u.stringTypeMembers;
    if (stringMembers.size <= 1)
        return undefined;
    const stringType = u.findMember("string");
    if (stringType === undefined)
        return undefined;
    assert(!stringTypesForType(stringType).isRestricted, "We must only flatten strings if we have no restriced strings");
    return stringMembers;
}
// Replaces all string types in an enum with the basic string type.
function replaceUnion(group, builder, forwardingRef) {
    assert(group.size === 1);
    const u = defined(collectionUtils.iterableFirst(group));
    const stringMembers = defined(unionNeedsReplacing(u));
    const stringAttributes = combineTypeAttributesOfTypes("union", stringMembers);
    const types = [];
    for (const t of u.members) {
        if (stringMembers.has(t))
            continue;
        types.push(builder.reconstituteType(t));
    }
    if (types.length === 0) {
        return builder.getStringType(combineTypeAttributes("union", stringAttributes, u.getAttributes()), undefined, forwardingRef);
    }
    types.push(builder.getStringType(stringAttributes, undefined));
    return builder.getUnionType(u.getAttributes(), new Set(types), forwardingRef);
}
function flattenStrings(graph, stringTypeMapping, debugPrintReconstitution) {
    const allUnions = graph.allNamedTypesSeparated().unions;
    const unionsToReplace = Array.from(allUnions)
        .filter(unionNeedsReplacing)
        .map(t => [t]);
    return graph.rewrite("flatten strings", stringTypeMapping, false, unionsToReplace, debugPrintReconstitution, replaceUnion);
}

function flattenUnions(graph, stringTypeMapping, conflateNumbers, makeObjectTypes, debugPrintReconstitution) {
    let needsRepeat = false;
    function replace(types, builder, forwardingRef) {
        const unionBuilder = new UnifyUnionBuilder(builder, makeObjectTypes, true, trefs => {
            assert(trefs.length > 0, "Must have at least one type to build union");
            trefs = trefs.map(tref => builder.reconstituteType(derefTypeRef(tref, graph)));
            if (trefs.length === 1) {
                return trefs[0];
            }
            needsRepeat = true;
            return builder.getUnionType(emptyTypeAttributes, new Set(trefs));
        });
        return unifyTypes(types, emptyTypeAttributes, builder, unionBuilder, conflateNumbers, forwardingRef);
    }
    const allUnions = collectionUtils.setFilter(graph.allTypesUnordered(), t => t instanceof UnionType);
    const nonCanonicalUnions = collectionUtils.setFilter(allUnions, u => !u.isCanonical);
    let foundIntersection = false;
    const groups = makeGroupsToFlatten(nonCanonicalUnions, members => {
        messageAssert(members.size > 0, "IRNoEmptyUnions", {});
        if (!collectionUtils.iterableSome(members, m => m instanceof IntersectionType))
            return true;
        // FIXME: This is stupid.  `flattenUnions` returns true when no more union
        // flattening is necessary, but `resolveIntersections` can introduce new
        // unions that might require flattening, so now `flattenUnions` needs to take
        // that into account.  Either change `resolveIntersections` such that it
        // doesn't introduce non-canonical unions (by using `unifyTypes`), or have
        // some other way to tell whether more work is needed that doesn't require
        // the two passes to know about each other.
        foundIntersection = true;
        return false;
    });
    graph = graph.rewrite("flatten unions", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
    // console.log(`flattened ${nonCanonicalUnions.size} of ${unions.size} unions`);
    return [graph, !needsRepeat && !foundIntersection];
}

const encodedMarkovChain = "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";

function makeTrie() {
    const arr = [];
    for (let i = 0; i < 128; i++) {
        arr.push(null);
    }
    return { count: 0, arr };
}
function lookup(t, seq, i) {
    if (i >= seq.length) {
        return t;
    }
    let first = seq.charCodeAt(i);
    if (first >= 128) {
        first = 0;
    }
    const n = t.arr[first];
    if (n === null) {
        return undefined;
    }
    if (typeof n === "object") {
        return lookup(n, seq, i + 1);
    }
    else {
        return n / t.count;
    }
}
function increment(t, seq, i) {
    let first = seq.charCodeAt(i);
    if (first >= 128) {
        first = 0;
    }
    if (i >= seq.length - 1) {
        if (typeof t !== "object") {
            return panic("Malformed trie");
        }
        let n = t.arr[first];
        if (n === null) {
            n = 0;
        }
        else if (typeof n === "object") {
            return panic("Malformed trie");
        }
        t.arr[first] = n + 1;
        t.count += 1;
        return;
    }
    let st = t.arr[first];
    if (st === null) {
        t.arr[first] = st = makeTrie();
    }
    if (typeof st !== "object") {
        return panic("Malformed trie");
    }
    increment(st, seq, i + 1);
}
function train(lines, depth) {
    const trie = makeTrie();
    for (const l of lines) {
        for (let i = depth; i <= l.length; i++) {
            increment(trie, l.slice(i - depth, i), 0);
        }
    }
    return { trie, depth };
}
function load() {
    return JSON.parse(inflateBase64(encodedMarkovChain));
}
function evaluateFull(mc, word) {
    const { trie, depth } = mc;
    if (word.length < depth) {
        return [1, []];
    }
    let p = 1;
    const scores = [];
    for (let i = depth; i <= word.length; i++) {
        let cp = lookup(trie, word.slice(i - depth, i), 0);
        if (typeof cp === "object") {
            return panic("Did we mess up the depth?");
        }
        if (cp === undefined) {
            cp = 0.0001;
        }
        scores.push(cp);
        p = p * cp;
    }
    return [Math.pow(p, 1 / (word.length - depth + 1)), scores];
}
function evaluate(mc, word) {
    return evaluateFull(mc, word)[0];
}

const mapSizeThreshold = 20;
const stringMapSizeThreshold = 50;
let markovChain = undefined;
function nameProbability(name) {
    if (markovChain === undefined) {
        markovChain = load();
    }
    return evaluate(markovChain, name);
}
function shouldBeMap(properties) {
    // Only classes with a certain number of properties are inferred
    // as maps.
    const numProperties = properties.size;
    if (numProperties < 2)
        return undefined;
    // If all property names are digit-only, we always make a map, no
    // questions asked.
    if (collectionUtils.iterableEvery(properties.keys(), n => /^[0-9]+$/.test(n))) {
        return collectionUtils.setMap(properties.values(), cp => cp.type);
    }
    // If all properties are strings or null then an object must have at least
    // `stringMapSizeThreshold` to qualify as a map.
    if (numProperties < stringMapSizeThreshold &&
        collectionUtils.iterableEvery(properties.values(), cp => isPrimitiveStringTypeKind(cp.type.kind) || cp.type.kind === "null")) {
        return undefined;
    }
    if (numProperties < mapSizeThreshold) {
        const names = Array.from(properties.keys());
        const probabilities = names.map(nameProbability);
        const product = probabilities.reduce((a, b) => a * b, 1);
        const probability = Math.pow(product, 1 / numProperties);
        // The idea behind this is to have a probability around 0.0025 for
        // n=1, up to around 1.0 for n=20.  I.e. when we only have a few
        // properties, they need to look really weird to infer a map, but
        // when we have more we'll accept more ordinary names.  The details
        // of the formula are immaterial because I pulled it out of my ass.
        // FIXME: Use different exponents and start values depending on
        // the property type kind.  For string properties, for example, we
        // should be more conservative, with class properties more
        // aggressive.  An exponent of 6 is probably good for string
        // properties, and maybe a start value of 0.002, whereas for classes
        // we want maybe 0.004 and 5, or maybe something even more
        // trigger-happy.
        const exponent = 5;
        const scale = Math.pow(22, exponent);
        const limit = Math.pow(numProperties + 2, exponent) / scale + (0.0025 - Math.pow(3, exponent) / scale);
        if (probability > limit)
            return undefined;
    }
    // FIXME: simplify this - it's no longer necessary with the new
    // class properties.
    // We need to handle three cases for maps (and the fourth case
    // where we leave the class as is):
    //
    // 1. All property types are null.
    // 2. Some property types are null or nullable.
    // 3. No property types are null or nullable.
    let firstNonNullCases = undefined;
    const allCases = new Set();
    let canBeMap = true;
    // Check that all the property types are the same, modulo nullability.
    for (const [, p] of properties) {
        // The set of types first property can be, minus null.
        const nn = removeNullFromType(p.type)[1];
        if (nn.size > 0) {
            if (firstNonNullCases !== undefined) {
                // The set of non-null cases for all other properties must
                // be the the same, otherwise we won't infer a map.
                if (!setOperationCasesEqual(nn, firstNonNullCases, true, (a, b) => a.structurallyCompatible(b, true))) {
                    canBeMap = false;
                    break;
                }
            }
            else {
                firstNonNullCases = nn;
            }
        }
        allCases.add(p.type);
    }
    if (!canBeMap) {
        return undefined;
    }
    return allCases;
}
function inferMaps(graph, stringTypeMapping, conflateNumbers, debugPrintReconstitution) {
    function replaceClass(setOfOneClass, builder, forwardingRef) {
        const c = defined(collectionUtils.iterableFirst(setOfOneClass));
        const properties = c.getProperties();
        const shouldBe = shouldBeMap(properties);
        if (shouldBe === undefined) {
            return panic(`We shouldn't be replacing class ${c.getCombinedName()} with a map`);
        }
        // Now reconstitute all the types in the new graph.  TypeGraphs are
        // immutable, so any change in the graph actually means building a new
        // graph, and the types in the new graph are different objects.
        // Reconstituting a type means generating the "same" type in the new
        // type graph.  Except we don't get Type objects but TypeRef objects,
        // which is a type-to-be.
        return builder.getMapType(c.getAttributes(), unifyTypes(shouldBe, c.getAttributes(), builder, unionBuilderForUnification(builder, false, false, conflateNumbers), conflateNumbers), forwardingRef);
    }
    const classesToReplace = Array.from(graph.allNamedTypesSeparated().objects).filter(o => {
        if (!(o instanceof ClassType))
            return false;
        return !o.isFixed && shouldBeMap(o.getProperties()) !== undefined;
    });
    return graph.rewrite("infer maps", stringTypeMapping, false, classesToReplace.map(c => [c]), debugPrintReconstitution, replaceClass);
}

function replaceObjectType(graph, stringTypeMapping, _conflateNumbers, leaveFullObjects, debugPrintReconstitution) {
    function replace(setOfOneType, builder, forwardingRef) {
        const o = defined(collectionUtils.iterableFirst(setOfOneType));
        const attributes = o.getAttributes();
        const properties = o.getProperties();
        const additionalProperties = o.getAdditionalProperties();
        function reconstituteProperties() {
            return collectionUtils.mapMap(properties, cp => builder.makeClassProperty(builder.reconstituteTypeRef(cp.typeRef), cp.isOptional));
        }
        function makeClass() {
            return builder.getUniqueClassType(attributes, true, reconstituteProperties(), forwardingRef);
        }
        function reconstituteAdditionalProperties() {
            return builder.reconstituteType(defined(additionalProperties));
        }
        if (additionalProperties === undefined) {
            return makeClass();
        }
        if (properties.size === 0) {
            return builder.getMapType(attributes, reconstituteAdditionalProperties(), forwardingRef);
        }
        if (additionalProperties.kind === "any") {
            // FIXME: Warn that we're losing additional property semantics.
            builder.setLostTypeAttributes();
            return makeClass();
        }
        // FIXME: Warn that we're losing class semantics.
        const propertyTypes = collectionUtils.setMap(properties.values(), cp => cp.type).add(additionalProperties);
        let union = builder.lookupTypeRefs(Array.from(propertyTypes).map(t => t.typeRef));
        if (union === undefined) {
            const reconstitutedTypes = collectionUtils.setMap(propertyTypes, t => builder.reconstituteType(t));
            union = builder.getUniqueUnionType(emptyTypeAttributes, new Set(reconstitutedTypes));
            // This is the direct unification alternative.  Weirdly enough, it is a tiny
            // bit slower.  It gives the same results.
            /*
            union = unifyTypes(
                propertyTypes,
                combineTypeAttributes(propertyTypes.toArray().map(t => t.getAttributes())),
                builder,
                unionBuilderForUnification(builder, false, false, false, conflateNumbers),
                conflateNumbers
            );
            */
        }
        return builder.getMapType(attributes, union, forwardingRef);
    }
    const allObjectTypes = collectionUtils.setFilter(graph.allTypesUnordered(), t => t.kind === "object");
    const objectTypesToReplace = leaveFullObjects
        ? collectionUtils.setFilter(allObjectTypes, o => o.getProperties().size === 0 || o.getAdditionalProperties() === undefined)
        : allObjectTypes;
    const groups = Array.from(objectTypesToReplace).map(t => [t]);
    return graph.rewrite("replace object type", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
}

/* eslint-disable @typescript-eslint/brace-style */
function canResolve(t) {
    const members = setOperationMembersRecursively(t, undefined)[0];
    if (members.size <= 1)
        return true;
    return collectionUtils.iterableEvery(members, m => !(m instanceof UnionType) || m.isCanonical);
}
function attributesForTypes(types) {
    return collectionUtils.mapMapEntries(types.entries(), t => [t.kind, t.getAttributes()]);
}
class IntersectionAccumulator {
    constructor() {
        this._primitiveAttributes = new Map();
        this._arrayAttributes = emptyTypeAttributes;
        // We start out with all object types allowed, which means
        // _additionalPropertyTypes is empty - no restrictions - and
        // _classProperties is empty - no defined properties so far.
        //
        // If _additionalPropertyTypes is undefined, no additional
        // properties are allowed anymore.  If _classProperties is
        // undefined, no object types are allowed, in which case
        // _additionalPropertyTypes must also be undefined;
        this._objectProperties = new Map();
        this._objectAttributes = emptyTypeAttributes;
        this._additionalPropertyTypes = new Set();
        this._lostTypeAttributes = false;
    }
    updatePrimitiveTypes(members) {
        const types = collectionUtils.setFilter(members, t => isPrimitiveTypeKind(t.kind));
        const attributes = attributesForTypes(types);
        collectionUtils.mapMergeWithInto(this._primitiveAttributes, (a, b) => combineTypeAttributes("intersect", a, b), attributes);
        const kinds = collectionUtils.setMap(types, t => t.kind);
        if (this._primitiveTypes === undefined) {
            this._primitiveTypes = new Set(kinds);
            return;
        }
        const haveNumber = collectionUtils.iterableFind(this._primitiveTypes, isNumberTypeKind) !== undefined &&
            collectionUtils.iterableFind(kinds, isNumberTypeKind) !== undefined;
        this._primitiveTypes = collectionUtils.setIntersect(this._primitiveTypes, kinds);
        if (haveNumber && collectionUtils.iterableFind(this._primitiveTypes, isNumberTypeKind) === undefined) {
            // One set has integer, the other has double.  The intersection
            // of that is integer.
            this._primitiveTypes = this._primitiveTypes.add("integer");
        }
    }
    updateArrayItemTypes(members) {
        const maybeArray = collectionUtils.iterableFind(members, t => t instanceof ArrayType);
        if (maybeArray === undefined) {
            this._arrayItemTypes = false;
            return;
        }
        this._arrayAttributes = combineTypeAttributes("intersect", this._arrayAttributes, maybeArray.getAttributes());
        if (this._arrayItemTypes === undefined) {
            this._arrayItemTypes = new Set();
        }
        else if (this._arrayItemTypes !== false) {
            this._arrayItemTypes.add(maybeArray.items);
        }
    }
    updateObjectProperties(members) {
        const maybeObject = collectionUtils.iterableFind(members, t => t instanceof ObjectType);
        if (maybeObject === undefined) {
            this._objectProperties = undefined;
            this._additionalPropertyTypes = undefined;
            return;
        }
        this._objectAttributes = combineTypeAttributes("intersect", this._objectAttributes, maybeObject.getAttributes());
        const objectAdditionalProperties = maybeObject.getAdditionalProperties();
        if (this._objectProperties === undefined) {
            assert(this._additionalPropertyTypes === undefined);
            return;
        }
        const allPropertyNames = collectionUtils.setUnionInto(new Set(this._objectProperties.keys()), maybeObject.getProperties().keys());
        for (const name of allPropertyNames) {
            const existing = defined(this._objectProperties).get(name);
            const newProperty = maybeObject.getProperties().get(name);
            if (existing !== undefined && newProperty !== undefined) {
                const cp = new GenericClassProperty(existing.typeData.add(newProperty.type), existing.isOptional && newProperty.isOptional);
                defined(this._objectProperties).set(name, cp);
            }
            else if (existing !== undefined && objectAdditionalProperties !== undefined) {
                const cp = new GenericClassProperty(existing.typeData.add(objectAdditionalProperties), existing.isOptional);
                defined(this._objectProperties).set(name, cp);
            }
            else if (existing !== undefined) {
                defined(this._objectProperties).delete(name);
            }
            else if (newProperty !== undefined && this._additionalPropertyTypes !== undefined) {
                // FIXME: This is potentially slow
                const types = new Set(this._additionalPropertyTypes).add(newProperty.type);
                defined(this._objectProperties).set(name, new GenericClassProperty(types, newProperty.isOptional));
            }
            else if (newProperty !== undefined) {
                defined(this._objectProperties).delete(name);
            }
            else {
                return mustNotHappen();
            }
        }
        if (this._additionalPropertyTypes !== undefined && objectAdditionalProperties !== undefined) {
            this._additionalPropertyTypes.add(objectAdditionalProperties);
        }
        else if (this._additionalPropertyTypes !== undefined || objectAdditionalProperties !== undefined) {
            this._additionalPropertyTypes = undefined;
            this._lostTypeAttributes = true;
        }
    }
    addUnionSet(members) {
        this.updatePrimitiveTypes(members);
        this.updateArrayItemTypes(members);
        this.updateObjectProperties(members);
    }
    addType(t) {
        let attributes = t.getAttributes();
        matchTypeExhaustive(t, _noneType => {
            return panic("There shouldn't be a none type");
        }, _anyType => {
            return panic("The any type should have been filtered out in setOperationMembersRecursively");
        }, nullType => this.addUnionSet([nullType]), boolType => this.addUnionSet([boolType]), integerType => this.addUnionSet([integerType]), doubleType => this.addUnionSet([doubleType]), stringType => this.addUnionSet([stringType]), arrayType => this.addUnionSet([arrayType]), _classType => panic("We should never see class types in intersections"), _mapType => panic("We should never see map types in intersections"), objectType => this.addUnionSet([objectType]), _enumType => panic("We should never see enum types in intersections"), unionType => {
            attributes = combineTypeAttributes("intersect", [attributes].concat(Array.from(unionType.members).map(m => m.getAttributes())));
            this.addUnionSet(unionType.members);
        }, transformedStringType => this.addUnionSet([transformedStringType]));
        return makeTypeAttributesInferred(attributes);
    }
    get arrayData() {
        if (this._arrayItemTypes === undefined || this._arrayItemTypes === false) {
            return panic("This should not be called if the type can't be an array");
        }
        return this._arrayItemTypes;
    }
    get objectData() {
        if (this._objectProperties === undefined) {
            assert(this._additionalPropertyTypes === undefined);
            return undefined;
        }
        return [this._objectProperties, this._additionalPropertyTypes];
    }
    get enumCases() {
        return panic("We don't support enums in intersections");
    }
    getMemberKinds() {
        const kinds = collectionUtils.mapMap(defined(this._primitiveTypes).entries(), k => defined(this._primitiveAttributes.get(k)));
        const maybeDoubleAttributes = this._primitiveAttributes.get("double");
        // If double was eliminated, add its attributes to integer
        if (maybeDoubleAttributes !== undefined && !kinds.has("double") && kinds.has("integer")) {
            // FIXME: How can this ever happen???  Where do we "eliminate" double?
            collectionUtils.mapUpdateInto(kinds, "integer", a => {
                return combineTypeAttributes("intersect", defined(a), maybeDoubleAttributes);
            });
        }
        if (this._arrayItemTypes !== undefined && this._arrayItemTypes !== false) {
            kinds.set("array", this._arrayAttributes);
        }
        else if (this._arrayAttributes.size > 0) {
            this._lostTypeAttributes = true;
        }
        if (this._objectProperties !== undefined) {
            kinds.set("object", this._objectAttributes);
        }
        else if (this._objectAttributes.size > 0) {
            this._lostTypeAttributes = true;
        }
        return kinds;
    }
    get lostTypeAttributes() {
        return this._lostTypeAttributes;
    }
}
class IntersectionUnionBuilder extends UnionBuilder {
    constructor() {
        super(...arguments);
        this._createdNewIntersections = false;
    }
    makeIntersection(members, attributes) {
        const reconstitutedMembers = collectionUtils.setMap(members, t => this.typeBuilder.reconstituteTypeRef(t.typeRef));
        const first = defined(collectionUtils.iterableFirst(reconstitutedMembers));
        if (reconstitutedMembers.size === 1) {
            this.typeBuilder.addAttributes(first, attributes);
            return first;
        }
        this._createdNewIntersections = true;
        return this.typeBuilder.getUniqueIntersectionType(attributes, reconstitutedMembers);
    }
    get createdNewIntersections() {
        return this._createdNewIntersections;
    }
    makeObject(maybeData, typeAttributes, forwardingRef) {
        if (maybeData === undefined) {
            return panic("Either properties or additional properties must be given to make an object type");
        }
        const [propertyTypes, maybeAdditionalProperties] = maybeData;
        const properties = collectionUtils.mapMap(propertyTypes, cp => this.typeBuilder.makeClassProperty(this.makeIntersection(cp.typeData, emptyTypeAttributes), cp.isOptional));
        const additionalProperties = maybeAdditionalProperties === undefined
            ? undefined
            : this.makeIntersection(maybeAdditionalProperties, emptyTypeAttributes);
        return this.typeBuilder.getUniqueObjectType(typeAttributes, properties, additionalProperties, forwardingRef);
    }
    makeArray(arrays, typeAttributes, forwardingRef) {
        // FIXME: attributes
        const itemsType = this.makeIntersection(arrays, emptyTypeAttributes);
        const tref = this.typeBuilder.getArrayType(typeAttributes, itemsType, forwardingRef);
        return tref;
    }
}
function resolveIntersections(graph, stringTypeMapping, debugPrintReconstitution) {
    let needsRepeat = false;
    function replace(types, builder, forwardingRef) {
        const intersections = collectionUtils.setFilter(types, t => t instanceof IntersectionType);
        const [members, intersectionAttributes] = setOperationMembersRecursively(Array.from(intersections), "intersect");
        if (members.size === 0) {
            const t = builder.getPrimitiveType("any", intersectionAttributes, forwardingRef);
            return t;
        }
        if (members.size === 1) {
            return builder.reconstituteType(defined(collectionUtils.iterableFirst(members)), intersectionAttributes, forwardingRef);
        }
        const accumulator = new IntersectionAccumulator();
        const extraAttributes = makeTypeAttributesInferred(combineTypeAttributes("intersect", Array.from(members).map(t => accumulator.addType(t))));
        const attributes = combineTypeAttributes("intersect", intersectionAttributes, extraAttributes);
        const unionBuilder = new IntersectionUnionBuilder(builder);
        const tref = unionBuilder.buildUnion(accumulator, true, attributes, forwardingRef);
        if (unionBuilder.createdNewIntersections) {
            needsRepeat = true;
        }
        return tref;
    }
    // FIXME: We need to handle intersections that resolve to the same set of types.
    // See for example the intersections-nested.schema example.
    const allIntersections = collectionUtils.setFilter(graph.allTypesUnordered(), t => t instanceof IntersectionType);
    const resolvableIntersections = collectionUtils.setFilter(allIntersections, canResolve);
    const groups = makeGroupsToFlatten(resolvableIntersections, undefined);
    graph = graph.rewrite("resolve intersections", stringTypeMapping, false, groups, debugPrintReconstitution, replace);
    // console.log(`resolved ${resolvableIntersections.size} of ${intersections.size} intersections`);
    return [graph, !needsRepeat && allIntersections.size === resolvableIntersections.size];
}

function getTargetLanguage(nameOrInstance) {
    if (typeof nameOrInstance === "object") {
        return nameOrInstance;
    }
    const language = languageNamed(nameOrInstance);
    if (language !== undefined) {
        return language;
    }
    return messageError("DriverUnknownOutputLanguage", { lang: nameOrInstance });
}
const inferenceFlagsObject = {
    /** Whether to infer map types from JSON data */
    inferMaps: {
        description: "Detect maps",
        negationDescription: "Don't infer maps, always use classes",
        explanation: "Infer maps when object keys look like map keys.",
        order: 1
    },
    /** Whether to infer enum types from JSON data */
    inferEnums: {
        description: "Detect enums",
        negationDescription: "Don't infer enums, always use strings",
        explanation: "If string values occur within a relatively small domain,\ninfer them as enum values.",
        order: 2
    },
    /** Whether to convert UUID strings to UUID objects */
    inferUuids: {
        description: "Detect UUIDs",
        negationDescription: "Don't convert UUIDs to UUID objects",
        explanation: "Detect UUIDs like '123e4567-e89b-12d3-a456-426655440000' (partial support).",
        stringType: "uuid",
        order: 3
    },
    /** Whether to assume that JSON strings that look like dates are dates */
    inferDateTimes: {
        description: "Detect dates & times",
        negationDescription: "Don't infer dates or times",
        explanation: "Infer dates from strings (partial support).",
        stringType: "date-time",
        order: 4
    },
    /** Whether to convert stringified integers to integers */
    inferIntegerStrings: {
        description: "Detect integers in strings",
        negationDescription: "Don't convert stringified integers to integers",
        explanation: 'Automatically convert stringified integers to integers.\nFor example, "1" is converted to 1.',
        stringType: "integer-string",
        order: 5
    },
    /** Whether to convert stringified booleans to boolean values */
    inferBooleanStrings: {
        description: "Detect booleans in strings",
        negationDescription: "Don't convert stringified booleans to booleans",
        explanation: 'Automatically convert stringified booleans to booleans.\nFor example, "true" is converted to true.',
        stringType: "bool-string",
        order: 6
    },
    /** Combine similar classes.  This doesn't apply to classes from a schema, only from inference. */
    combineClasses: {
        description: "Merge similar classes",
        negationDescription: "Don't combine similar classes",
        explanation: "Combine classes with significantly overlapping properties,\ntreating contingent properties as nullable.",
        order: 7
    },
    /** Whether to treat $ref as references within JSON */
    ignoreJsonRefs: {
        description: "Don't treat $ref as a reference in JSON",
        negationDescription: "Treat $ref as a reference in JSON",
        explanation: "Like in JSON Schema, allow objects like\n'{ $ref: \"#/foo/bar\" }' to refer\nto another part of the input.",
        order: 8
    }
};
const inferenceFlagNames = Object.getOwnPropertyNames(inferenceFlagsObject);
const inferenceFlags = inferenceFlagsObject;
const defaultOptions = {
    lang: "ts",
    inputData: new InputData(),
    alphabetizeProperties: false,
    allPropertiesOptional: false,
    fixedTopLevels: false,
    noRender: false,
    leadingComments: undefined,
    rendererOptions: {},
    indentation: undefined,
    outputFilename: "stdout",
    debugPrintGraph: false,
    checkProvenance: false,
    debugPrintReconstitution: false,
    debugPrintGatherNames: false,
    debugPrintTransformations: false,
    debugPrintTimes: false,
    debugPrintSchemaResolving: false
};
function makeDefaultInferenceFlags() {
    const flags = {};
    for (const flag of inferenceFlagNames) {
        flags[flag] = true;
    }
    return flags;
}
const defaultInferenceFlags = makeDefaultInferenceFlags();
class Run {
    constructor(options) {
        // We must not overwrite defaults with undefined values, which
        // we sometimes get.
        this._options = Object.assign({}, defaultOptions, defaultInferenceFlags);
        for (const k of Object.getOwnPropertyNames(options)) {
            const v = options[k];
            if (v !== undefined) {
                this._options[k] = v;
            }
        }
    }
    get stringTypeMapping() {
        const targetLanguage = getTargetLanguage(this._options.lang);
        const mapping = new Map(targetLanguage.stringTypeMapping);
        for (const flag of inferenceFlagNames) {
            const stringType = inferenceFlags[flag].stringType;
            if (!this._options[flag] && stringType !== undefined) {
                mapping.set(stringType, "string");
            }
        }
        return mapping;
    }
    get debugPrintReconstitution() {
        return this._options.debugPrintReconstitution === true;
    }
    get debugPrintTransformations() {
        return this._options.debugPrintTransformations;
    }
    get debugPrintSchemaResolving() {
        return this._options.debugPrintSchemaResolving;
    }
    timeSync(name, f) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            const result = yield f();
            const end = Date.now();
            if (this._options.debugPrintTimes) {
                console.log(`${name} took ${end - start}ms`);
            }
            return result;
        });
    }
    time(name, f) {
        const start = Date.now();
        const result = f();
        const end = Date.now();
        if (this._options.debugPrintTimes) {
            console.log(`${name} took ${end - start}ms`);
        }
        return result;
    }
    makeGraphInputs() {
        const targetLanguage = getTargetLanguage(this._options.lang);
        const stringTypeMapping = this.stringTypeMapping;
        const conflateNumbers = !targetLanguage.supportsUnionsWithBothNumberTypes;
        const typeBuilder = new TypeBuilder(0, stringTypeMapping, this._options.alphabetizeProperties, this._options.allPropertiesOptional, this._options.checkProvenance, false);
        return { targetLanguage, stringTypeMapping, conflateNumbers, typeBuilder };
    }
    makeGraph(allInputs) {
        return __awaiter(this, void 0, void 0, function* () {
            const graphInputs = this.makeGraphInputs();
            yield this.timeSync("read input", () => __awaiter(this, void 0, void 0, function* () {
                return yield allInputs.addTypes(this, graphInputs.typeBuilder, this._options.inferMaps, this._options.inferEnums, this._options.fixedTopLevels);
            }));
            return this.processGraph(allInputs, graphInputs);
        });
    }
    makeGraphSync(allInputs) {
        const graphInputs = this.makeGraphInputs();
        this.time("read input", () => allInputs.addTypesSync(this, graphInputs.typeBuilder, this._options.inferMaps, this._options.inferEnums, this._options.fixedTopLevels));
        return this.processGraph(allInputs, graphInputs);
    }
    processGraph(allInputs, graphInputs) {
        const { targetLanguage, stringTypeMapping, conflateNumbers, typeBuilder } = graphInputs;
        let graph = typeBuilder.finish();
        if (this._options.debugPrintGraph) {
            graph.setPrintOnRewrite();
            graph.printGraph();
        }
        const debugPrintReconstitution = this.debugPrintReconstitution;
        if (typeBuilder.didAddForwardingIntersection || !this._options.ignoreJsonRefs) {
            this.time("remove indirection intersections", () => (graph = removeIndirectionIntersections(graph, stringTypeMapping, debugPrintReconstitution)));
        }
        let unionsDone = false;
        if (allInputs.needSchemaProcessing || !this._options.ignoreJsonRefs) {
            let intersectionsDone = false;
            do {
                const graphBeforeRewrites = graph;
                if (!intersectionsDone) {
                    this.time("resolve intersections", () => ([graph, intersectionsDone] = resolveIntersections(graph, stringTypeMapping, debugPrintReconstitution)));
                }
                if (!unionsDone) {
                    this.time("flatten unions", () => ([graph, unionsDone] = flattenUnions(graph, stringTypeMapping, conflateNumbers, true, debugPrintReconstitution)));
                }
                if (graph === graphBeforeRewrites) {
                    assert(intersectionsDone && unionsDone, "Graph didn't change but we're not done");
                }
            } while (!intersectionsDone || !unionsDone);
        }
        this.time("replace object type", () => (graph = replaceObjectType(graph, stringTypeMapping, conflateNumbers, targetLanguage.supportsFullObjectType, debugPrintReconstitution)));
        do {
            this.time("flatten unions", () => ([graph, unionsDone] = flattenUnions(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution)));
        } while (!unionsDone);
        if (this._options.combineClasses) {
            const combinedGraph = this.time("combine classes", () => combineClasses(this, graph, this._options.alphabetizeProperties, true, false, debugPrintReconstitution));
            if (combinedGraph === graph) {
                graph = combinedGraph;
            }
            else {
                this.time("combine classes cleanup", () => (graph = combineClasses(this, combinedGraph, this._options.alphabetizeProperties, false, true, debugPrintReconstitution)));
            }
        }
        if (this._options.inferMaps) {
            for (;;) {
                const newGraph = this.time("infer maps", () => inferMaps(graph, stringTypeMapping, true, debugPrintReconstitution));
                if (newGraph === graph) {
                    break;
                }
                graph = newGraph;
            }
        }
        const enumInference = allInputs.needSchemaProcessing ? "all" : this._options.inferEnums ? "infer" : "none";
        this.time("expand strings", () => (graph = expandStrings(this, graph, enumInference)));
        this.time("flatten unions", () => ([graph, unionsDone] = flattenUnions(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution)));
        assert(unionsDone, "We should only have to flatten unions once after expanding strings");
        if (allInputs.needSchemaProcessing) {
            this.time("flatten strings", () => (graph = flattenStrings(graph, stringTypeMapping, debugPrintReconstitution)));
        }
        this.time("none to any", () => (graph = noneToAny(graph, stringTypeMapping, debugPrintReconstitution)));
        if (!targetLanguage.supportsOptionalClassProperties) {
            this.time("optional to nullable", () => (graph = optionalToNullable(graph, stringTypeMapping, debugPrintReconstitution)));
        }
        this.time("fixed point", () => (graph = graph.rewriteFixedPoint(false, debugPrintReconstitution)));
        this.time("make transformations", () => (graph = makeTransformations(this, graph, targetLanguage)));
        this.time("flatten unions", () => ([graph, unionsDone] = flattenUnions(graph, stringTypeMapping, conflateNumbers, false, debugPrintReconstitution)));
        assert(unionsDone, "We should only have to flatten unions once after making transformations");
        // Sometimes we combine classes in ways that will the order come out
        // differently compared to what it would be from the equivalent schema,
        // so we always just garbage collect to get a defined order and be done
        // with it.
        // FIXME: We don't actually have to do this if any of the above graph
        // rewrites did anything.  We could just check whether the current graph
        // is different from the one we started out with.
        this.time("GC", () => (graph = graph.garbageCollect(this._options.alphabetizeProperties, debugPrintReconstitution)));
        if (this._options.debugPrintGraph) {
            console.log("\n# gather names");
        }
        this.time("gather names", () => gatherNames(graph, !allInputs.needSchemaProcessing, this._options.debugPrintGatherNames));
        if (this._options.debugPrintGraph) {
            graph.printGraph();
        }
        return graph;
    }
    makeSimpleTextResult(lines) {
        return new Map([[this._options.outputFilename, { lines, annotations: [] }]]);
    }
    preRun() {
        // FIXME: This makes quicktype not quite reentrant
        initTypeNames();
        const targetLanguage = getTargetLanguage(this._options.lang);
        const inputData = this._options.inputData;
        const needIR = inputData.needIR || !targetLanguage.names.includes("schema");
        const schemaString = needIR ? undefined : inputData.singleStringSchemaSource();
        if (schemaString !== undefined) {
            const lines = JSON.stringify(JSON.parse(schemaString), undefined, 4).split("\n");
            lines.push("");
            const srr = { lines, annotations: [] };
            return new Map([[this._options.outputFilename, srr]]);
        }
        return [inputData, targetLanguage];
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const preRunResult = this.preRun();
            if (!Array.isArray(preRunResult)) {
                return preRunResult;
            }
            const [inputData, targetLanguage] = preRunResult;
            const graph = yield this.makeGraph(inputData);
            return this.renderGraph(targetLanguage, graph);
        });
    }
    runSync() {
        const preRunResult = this.preRun();
        if (!Array.isArray(preRunResult)) {
            return preRunResult;
        }
        const [inputData, targetLanguage] = preRunResult;
        const graph = this.makeGraphSync(inputData);
        return this.renderGraph(targetLanguage, graph);
    }
    renderGraph(targetLanguage, graph) {
        if (this._options.noRender) {
            return this.makeSimpleTextResult(["Done.", ""]);
        }
        return targetLanguage.renderGraphAndSerialize(graph, this._options.outputFilename, this._options.alphabetizeProperties, this._options.leadingComments, this._options.rendererOptions, this._options.indentation);
    }
}
/**
 * Run quicktype and produce one or more output files.
 *
 * @param options Partial options.  For options that are not defined, the
 * defaults will be used.
 */
function quicktypeMultiFile(options) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield new Run(options).run();
    });
}
function quicktypeMultiFileSync(options) {
    return new Run(options).runSync();
}
function offsetLocation(loc, lineOffset) {
    return { line: loc.line + lineOffset, column: loc.column };
}
function offsetSpan(span, lineOffset) {
    return { start: offsetLocation(span.start, lineOffset), end: offsetLocation(span.end, lineOffset) };
}
/**
 * Combines a multi-file render result into a single output.  All the files
 * are concatenated and prefixed with a `//`-style comment giving the
 * filename.
 */
function combineRenderResults(result) {
    if (result.size <= 1) {
        const first = collectionUtils.mapFirst(result);
        if (first === undefined) {
            return { lines: [], annotations: [] };
        }
        return first;
    }
    let lines = [];
    let annotations = [];
    for (const [filename, srr] of result) {
        const offset = lines.length + 2;
        lines = lines.concat([`// ${filename}`, ""], srr.lines);
        annotations = annotations.concat(srr.annotations.map(ann => ({ annotation: ann.annotation, span: offsetSpan(ann.span, offset) })));
    }
    return { lines, annotations };
}
/**
 * Run quicktype like `quicktypeMultiFile`, but if there are multiple
 * output files they will all be squashed into one output, with comments at the
 * start of each file.
 *
 * @param options Partial options.  For options that are not defined, the
 * defaults will be used.
 */
function quicktype(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield quicktypeMultiFile(options);
        return combineRenderResults(result);
    });
}

/* eslint-disable @typescript-eslint/no-explicit-any */
function bufferStream(opts) {
    opts = Object.assign({}, opts);
    const array = opts.array;
    let encoding = opts.encoding;
    const buffer = encoding === "buffer";
    let objectMode = false;
    if (array) {
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        objectMode = !(encoding || buffer);
    }
    else {
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        encoding = encoding || "utf8";
    }
    if (buffer) {
        encoding = undefined;
    }
    let len = 0;
    const ret = [];
    const stream = new readableStream.PassThrough({
        objectMode
    });
    if (encoding) {
        stream.setEncoding(encoding);
    }
    stream.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
            len = ret.length;
        }
        else {
            len += chunk.length;
        }
    });
    stream.getBufferedValue = () => {
        if (array) {
            return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
    };
    stream.getBufferedLength = () => len;
    return stream;
}

function getStream(inputStream, opts = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!inputStream) {
            return yield Promise.reject(new Error("Expected a stream"));
        }
        opts = Object.assign({ maxBuffer: Infinity }, opts);
        const maxBuffer = (_a = opts.maxBuffer) !== null && _a !== void 0 ? _a : Infinity;
        let stream;
        let clean;
        const p = new Promise((resolve, reject) => {
            const error = (err) => {
                if (err) {
                    // null check
                    err.bufferedData = stream.getBufferedValue();
                }
                reject(err);
            };
            stream = bufferStream(opts);
            inputStream.once("error", error);
            inputStream.pipe(stream);
            stream.on("data", () => {
                if (stream.getBufferedLength() > maxBuffer) {
                    reject(new Error("maxBuffer exceeded"));
                }
            });
            stream.once("error", error);
            stream.on("end", resolve);
            clean = () => {
                // some streams doesn't implement the `stream.Readable` interface correctly
                if (inputStream.unpipe) {
                    inputStream.unpipe(stream);
                }
            };
        });
        return yield p.then(clean, clean).then(() => stream.getBufferedValue());
    });
}

// src/index.ts
var isNode = (
  // @ts-expect-error
  typeof process !== "undefined" && // @ts-expect-error
  process.versions != null && // @ts-expect-error
  process.versions.node != null
);
typeof window !== "undefined" && window.name === "nodejs" || typeof navigator !== "undefined" && "userAgent" in navigator && typeof navigator.userAgent === "string" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom"));
(
  // @ts-expect-error
  typeof Deno !== "undefined" && // @ts-expect-error
  typeof Deno.version !== "undefined" && // @ts-expect-error
  typeof Deno.version.deno !== "undefined"
);
typeof process !== "undefined" && process.versions != null && process.versions.bun != null;

var _a;
// Only use cross-fetch in CI
// FIXME: type global
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const fetch = process.env.CI ? _fetch : (_a = global.fetch) !== null && _a !== void 0 ? _a : _fetch;
function parseHeaders(httpHeaders) {
    if (!Array.isArray(httpHeaders)) {
        return {};
    }
    return httpHeaders.reduce(function (result, httpHeader) {
        if (httpHeader !== undefined && httpHeader.length > 0) {
            const split = httpHeader.indexOf(":");
            if (split < 0) {
                return panic(`Could not parse HTTP header "${httpHeader}".`);
            }
            const key = httpHeader.slice(0, split).trim();
            const value = httpHeader.slice(split + 1).trim();
            result[key] = value;
        }
        return result;
    }, {});
}
function readableFromFileOrURL(fileOrURL, httpHeaders) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (isURL(fileOrURL)) {
                const response = yield fetch(fileOrURL, {
                    headers: parseHeaders(httpHeaders)
                });
                return tsNecessities.defined(response.body);
            }
            else if (isNode) {
                if (fileOrURL === "-") {
                    // Cast node readable to isomorphic readable from readable-stream
                    return process.stdin;
                }
                const filePath = fs__namespace.lstatSync(fileOrURL).isSymbolicLink() ? fs__namespace.readlinkSync(fileOrURL) : fileOrURL;
                if (fs__namespace.existsSync(filePath)) {
                    // Cast node readable to isomorphic readable from readable-stream
                    return fs__namespace.createReadStream(filePath, "utf8");
                }
            }
        }
        catch (e) {
            return messageError("MiscReadError", { fileOrURL, message: tsNecessities.exceptionToString(e) });
        }
        return messageError("DriverInputFileDoesNotExist", { filename: fileOrURL });
    });
}
function readFromFileOrURL(fileOrURL, httpHeaders) {
    return __awaiter(this, void 0, void 0, function* () {
        const readable = yield readableFromFileOrURL(fileOrURL, httpHeaders);
        try {
            return yield getStream(readable);
        }
        catch (e) {
            return messageError("MiscReadError", { fileOrURL, message: tsNecessities.exceptionToString(e) });
        }
    });
}

class FetchingJSONSchemaStore extends JSONSchemaStore {
    constructor(_httpHeaders) {
        super();
        this._httpHeaders = _httpHeaders;
    }
    fetch(address) {
        return __awaiter(this, void 0, void 0, function* () {
            // console.log(`Fetching ${address}`);
            return parseJSON(yield readFromFileOrURL(address, this._httpHeaders), "JSON Schema", address);
        });
    }
}

function isValidJSON(s) {
    try {
        JSON.parse(s);
        return true;
    }
    catch (error) {
        return false;
    }
}
function sourcesFromPostmanCollection(collectionJSON, collectionJSONAddress) {
    const sources = [];
    const descriptions = [];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function processCollection(c) {
        if (typeof c !== "object")
            return;
        if (Array.isArray(c.item)) {
            for (const item of c.item) {
                processCollection(item);
            }
            if (typeof c.info === "object" && typeof c.info.description === "string") {
                descriptions.push(c.info.description);
            }
        }
        if (typeof c.name === "string" && Array.isArray(c.response)) {
            const samples = [];
            for (const r of c.response) {
                if (typeof r === "object" && typeof r.body === "string" && isValidJSON(r.body)) {
                    samples.push(r.body);
                }
            }
            if (samples.length > 0) {
                const source = { name: c.name, samples };
                const sourceDescription = [c.name];
                if (typeof c.request === "object") {
                    const { method, url } = c.request;
                    if (method !== undefined && typeof url === "object" && url.raw !== undefined) {
                        sourceDescription.push(`${method} ${url.raw}`);
                    }
                }
                if (typeof c.request === "object" && typeof c.request.description === "string") {
                    sourceDescription.push(c.request.description);
                }
                source.description = sourceDescription.length === 0 ? undefined : sourceDescription.join("\n\n");
                sources.push(source);
            }
        }
    }
    processCollection(parseJSON(collectionJSON, "Postman collection", collectionJSONAddress));
    const joinedDescription = descriptions.join("\n\n").trim();
    let description = undefined;
    if (joinedDescription !== "") {
        description = joinedDescription;
    }
    return { sources, description };
}

exports.ArrayType = ArrayType;
exports.CJSONRenderer = CJSONRenderer;
exports.CJSONTargetLanguage = CJSONTargetLanguage;
exports.CPlusPlusRenderer = CPlusPlusRenderer;
exports.CPlusPlusTargetLanguage = CPlusPlusTargetLanguage;
exports.CSharpRenderer = CSharpRenderer;
exports.CSharpTargetLanguage = CSharpTargetLanguage;
exports.ClassProperty = ClassProperty;
exports.ClassType = ClassType;
exports.CompressedJSON = CompressedJSON;
exports.ConvenienceRenderer = ConvenienceRenderer;
exports.CrystalRenderer = CrystalRenderer;
exports.CrystalTargetLanguage = CrystalTargetLanguage;
exports.DartRenderer = DartRenderer;
exports.DartTargetLanguage = DartTargetLanguage;
exports.ElixirRenderer = ElixirRenderer;
exports.ElixirTargetLanguage = ElixirTargetLanguage;
exports.ElmRenderer = ElmRenderer;
exports.ElmTargetLanguage = ElmTargetLanguage;
exports.EnumType = EnumType;
exports.FetchingJSONSchemaStore = FetchingJSONSchemaStore;
exports.FlowRenderer = FlowRenderer;
exports.FlowTargetLanguage = FlowTargetLanguage;
exports.GoRenderer = GoRenderer;
exports.GoTargetLanguage = GoTargetLanguage;
exports.HaskellRenderer = HaskellRenderer;
exports.HaskellTargetLanguage = HaskellTargetLanguage;
exports.InputData = InputData;
exports.IssueAnnotationData = IssueAnnotationData;
exports.JSONInput = JSONInput;
exports.JSONSchemaInput = JSONSchemaInput;
exports.JSONSchemaRenderer = JSONSchemaRenderer;
exports.JSONSchemaStore = JSONSchemaStore;
exports.JSONSchemaTargetLanguage = JSONSchemaTargetLanguage;
exports.JavaRenderer = JavaRenderer;
exports.JavaScriptPropTypesRenderer = JavaScriptPropTypesRenderer;
exports.JavaScriptPropTypesTargetLanguage = JavaScriptPropTypesTargetLanguage;
exports.JavaScriptRenderer = JavaScriptRenderer;
exports.JavaScriptTargetLanguage = JavaScriptTargetLanguage;
exports.JavaTargetLanguage = JavaTargetLanguage;
exports.KotlinRenderer = KotlinRenderer;
exports.KotlinTargetLanguage = KotlinTargetLanguage;
exports.MapType = MapType;
exports.Name = Name;
exports.Namer = Namer;
exports.ObjectType = ObjectType;
exports.ObjectiveCRenderer = ObjectiveCRenderer;
exports.ObjectiveCTargetLanguage = ObjectiveCTargetLanguage;
exports.Option = Option;
exports.PrimitiveType = PrimitiveType;
exports.PythonRenderer = PythonRenderer;
exports.PythonTargetLanguage = PythonTargetLanguage;
exports.QuickTypeError = QuickTypeError;
exports.Ref = Ref;
exports.RubyRenderer = RubyRenderer;
exports.RubyTargetLanguage = RubyTargetLanguage;
exports.RustRenderer = RustRenderer;
exports.RustTargetLanguage = RustTargetLanguage;
exports.Scala3Renderer = Scala3Renderer;
exports.Scala3TargetLanguage = Scala3TargetLanguage;
exports.Smithy4sRenderer = Smithy4sRenderer;
exports.SmithyOptions = SmithyOptions;
exports.SmithyTargetLanguage = SmithyTargetLanguage;
exports.StringTypes = StringTypes;
exports.SwiftRenderer = SwiftRenderer;
exports.SwiftTargetLanguage = SwiftTargetLanguage;
exports.TargetLanguage = TargetLanguage;
exports.Type = Type;
exports.TypeAttributeKind = TypeAttributeKind;
exports.TypeBuilder = TypeBuilder;
exports.TypeNames = TypeNames;
exports.TypeScriptRenderer = TypeScriptRenderer;
exports.TypeScriptTargetLanguage = TypeScriptTargetLanguage;
exports.UnionType = UnionType;
exports.allUpperWordStyle = allUpperWordStyle;
exports.assert = assert;
exports.assertNever = assertNever;
exports.cJSONOptions = cJSONOptions;
exports.cPlusPlusOptions = cPlusPlusOptions;
exports.cSharpOptions = cSharpOptions;
exports.capitalize = capitalize;
exports.checkArray = checkArray;
exports.checkStringMap = checkStringMap;
exports.combineRenderResults = combineRenderResults;
exports.combineWords = combineWords;
exports.dartOptions = dartOptions;
exports.defaultInferenceFlags = defaultInferenceFlags;
exports.defaultTargetLanguages = all;
exports.defined = defined;
exports.derefTypeRef = derefTypeRef;
exports.elixirOptions = elixirOptions;
exports.elmOptions = elmOptions;
exports.emptyTypeAttributes = emptyTypeAttributes;
exports.firstUpperWordStyle = firstUpperWordStyle;
exports.funPrefixNamer = funPrefixNamer;
exports.getOptionValues = getOptionValues;
exports.getStream = getStream;
exports.getTargetLanguage = getTargetLanguage;
exports.goOptions = goOptions;
exports.haskellOptions = haskellOptions;
exports.inferenceFlagNames = inferenceFlagNames;
exports.inferenceFlags = inferenceFlags;
exports.inferenceFlagsObject = inferenceFlagsObject;
exports.inflateBase64 = inflateBase64;
exports.isLetterOrDigit = isLetterOrDigit;
exports.javaOptions = javaOptions;
exports.javaScriptOptions = javaScriptOptions;
exports.javaScriptPropTypesOptions = javaScriptPropTypesOptions;
exports.jsonInputForTargetLanguage = jsonInputForTargetLanguage;
exports.kotlinOptions = kotlinOptions;
exports.languageNamed = languageNamed;
exports.legalizeCharacters = legalizeCharacters;
exports.makeNamesTypeAttributes = makeNamesTypeAttributes;
exports.matchType = matchType;
exports.messageAssert = messageAssert;
exports.messageError = messageError;
exports.modifySource = modifySource;
exports.namesTypeAttributeKind = namesTypeAttributeKind;
exports.nullableFromUnion = nullableFromUnion;
exports.objcOptions = objcOptions;
exports.panic = panic;
exports.parenIfNeeded = parenIfNeeded;
exports.parseJSON = parseJSON;
exports.pythonOptions = pythonOptions;
exports.quicktype = quicktype;
exports.quicktypeMultiFile = quicktypeMultiFile;
exports.quicktypeMultiFileSync = quicktypeMultiFileSync;
exports.readFromFileOrURL = readFromFileOrURL;
exports.readableFromFileOrURL = readableFromFileOrURL;
exports.removeNullFromUnion = removeNullFromUnion;
exports.rubyOptions = rubyOptions;
exports.rustOptions = rustOptions;
exports.scala3Options = scala3Options;
exports.singleWord = singleWord;
exports.sourcesFromPostmanCollection = sourcesFromPostmanCollection;
exports.splitIntoWords = splitIntoWords;
exports.swiftOptions = swiftOptions;
exports.trainMarkovChain = train;
exports.tsFlowOptions = tsFlowOptions;
exports.uriTypeAttributeKind = uriTypeAttributeKind;
//# sourceMappingURL=index.cjs.js.map
